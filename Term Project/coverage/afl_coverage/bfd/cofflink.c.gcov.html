<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - afl_coverage.info - bfd/cofflink.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">bfd</a> - cofflink.c<span style="font-size: 80%;"> (source / <a href="cofflink.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">afl_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1462</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-06-20 14:23:35</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* COFF specific linker code.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1994-2017 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Written by Ian Lance Taylor, Cygnus Support.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            :    This file is part of BFD, the Binary File Descriptor library.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            :    This program is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            :    it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            :    the Free Software Foundation; either version 3 of the License, or
<span class="lineNum">      10 </span>            :    (at your option) any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            :    This program is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            :    GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            :    You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            :    along with this program; if not, write to the Free Software
<span class="lineNum">      19 </span>            :    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
<span class="lineNum">      20 </span>            :    MA 02110-1301, USA.  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /* This file contains the COFF backend linker code.  */
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;sysdep.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;bfd.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;bfdlink.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;libbfd.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;coff/internal.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;libcoff.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;safe-ctype.h&quot;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : static bfd_boolean coff_link_add_object_symbols (bfd *, struct bfd_link_info *);
<span class="lineNum">      33 </span>            : static bfd_boolean coff_link_check_archive_element
<span class="lineNum">      34 </span>            :   (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, const char *,
<span class="lineNum">      35 </span>            :    bfd_boolean *);
<span class="lineNum">      36 </span>            : static bfd_boolean coff_link_add_symbols (bfd *, struct bfd_link_info *);
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : /* Return TRUE if SYM is a weak, external symbol.  */
<span class="lineNum">      39 </span>            : #define IS_WEAK_EXTERNAL(abfd, sym)                     \
<span class="lineNum">      40 </span>            :   ((sym).n_sclass == C_WEAKEXT                          \
<span class="lineNum">      41 </span>            :    || (obj_pe (abfd) &amp;&amp; (sym).n_sclass == C_NT_WEAK))
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /* Return TRUE if SYM is an external symbol.  */
<span class="lineNum">      44 </span>            : #define IS_EXTERNAL(abfd, sym)                          \
<span class="lineNum">      45 </span>            :   ((sym).n_sclass == C_EXT || IS_WEAK_EXTERNAL (abfd, sym))
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : /* Define macros so that the ISFCN, et. al., macros work correctly.
<span class="lineNum">      48 </span>            :    These macros are defined in include/coff/internal.h in terms of
<span class="lineNum">      49 </span>            :    N_TMASK, etc.  These definitions require a user to define local
<span class="lineNum">      50 </span>            :    variables with the appropriate names, and with values from the
<span class="lineNum">      51 </span>            :    coff_data (abfd) structure.  */
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : #define N_TMASK n_tmask
<span class="lineNum">      54 </span>            : #define N_BTSHFT n_btshft
<span class="lineNum">      55 </span>            : #define N_BTMASK n_btmask
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : /* Create an entry in a COFF linker hash table.  */
<a name="58"><span class="lineNum">      58 </span>            : </a>
<span class="lineNum">      59 </span>            : struct bfd_hash_entry *
<span class="lineNum">      60 </span><span class="lineNoCov">          0 : _bfd_coff_link_hash_newfunc (struct bfd_hash_entry *entry,</span>
<span class="lineNum">      61 </span>            :                              struct bfd_hash_table *table,
<span class="lineNum">      62 </span>            :                              const char *string)
<span class="lineNum">      63 </span>            : {
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   struct coff_link_hash_entry *ret = (struct coff_link_hash_entry *) entry;</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :   /* Allocate the structure if it has not already been allocated by a
<span class="lineNum">      67 </span>            :      subclass.  */
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   if (ret == (struct coff_link_hash_entry *) NULL)</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :     ret = ((struct coff_link_hash_entry *)</span>
<span class="lineNum">      70 </span>            :            bfd_hash_allocate (table, sizeof (struct coff_link_hash_entry)));
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   if (ret == (struct coff_link_hash_entry *) NULL)</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     return (struct bfd_hash_entry *) ret;</span>
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :   /* Call the allocation method of the superclass.  */
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   ret = ((struct coff_link_hash_entry *)</span>
<span class="lineNum">      76 </span>            :          _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
<span class="lineNum">      77 </span>            :                                  table, string));
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   if (ret != (struct coff_link_hash_entry *) NULL)</span>
<span class="lineNum">      79 </span>            :     {
<span class="lineNum">      80 </span>            :       /* Set local fields.  */
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :       ret-&gt;indx = -1;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :       ret-&gt;type = T_NULL;</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :       ret-&gt;symbol_class = C_NULL;</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :       ret-&gt;numaux = 0;</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :       ret-&gt;auxbfd = NULL;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :       ret-&gt;aux = NULL;</span>
<span class="lineNum">      87 </span>            :     }
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   return (struct bfd_hash_entry *) ret;</span>
<span class="lineNum">      90 </span>            : }
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : /* Initialize a COFF linker hash table.  */
<a name="93"><span class="lineNum">      93 </span>            : </a>
<span class="lineNum">      94 </span>            : bfd_boolean
<span class="lineNum">      95 </span><span class="lineNoCov">          0 : _bfd_coff_link_hash_table_init (struct coff_link_hash_table *table,</span>
<span class="lineNum">      96 </span>            :                                 bfd *abfd,
<span class="lineNum">      97 </span>            :                                 struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
<span class="lineNum">      98 </span>            :                                                                    struct bfd_hash_table *,
<span class="lineNum">      99 </span>            :                                                                    const char *),
<span class="lineNum">     100 </span>            :                                 unsigned int entsize)
<span class="lineNum">     101 </span>            : {
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   memset (&amp;table-&gt;stab_info, 0, sizeof (table-&gt;stab_info));</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   return _bfd_link_hash_table_init (&amp;table-&gt;root, abfd, newfunc, entsize);</span>
<span class="lineNum">     104 </span>            : }
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : /* Create a COFF linker hash table.  */
<a name="107"><span class="lineNum">     107 </span>            : </a>
<span class="lineNum">     108 </span>            : struct bfd_link_hash_table *
<span class="lineNum">     109 </span><span class="lineNoCov">          0 : _bfd_coff_link_hash_table_create (bfd *abfd)</span>
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span>            :   struct coff_link_hash_table *ret;
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   bfd_size_type amt = sizeof (struct coff_link_hash_table);</span>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   ret = (struct coff_link_hash_table *) bfd_malloc (amt);</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   if (ret == NULL)</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   if (! _bfd_coff_link_hash_table_init (ret, abfd,</span>
<span class="lineNum">     119 </span>            :                                         _bfd_coff_link_hash_newfunc,
<span class="lineNum">     120 </span>            :                                         sizeof (struct coff_link_hash_entry)))
<span class="lineNum">     121 </span>            :     {
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :       free (ret);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :       return (struct bfd_link_hash_table *) NULL;</span>
<span class="lineNum">     124 </span>            :     }
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   return &amp;ret-&gt;root;</span>
<span class="lineNum">     126 </span>            : }
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : /* Create an entry in a COFF debug merge hash table.  */
<a name="129"><span class="lineNum">     129 </span>            : </a>
<span class="lineNum">     130 </span>            : struct bfd_hash_entry *
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : _bfd_coff_debug_merge_hash_newfunc (struct bfd_hash_entry *entry,</span>
<span class="lineNum">     132 </span>            :                                     struct bfd_hash_table *table,
<span class="lineNum">     133 </span>            :                                     const char *string)
<span class="lineNum">     134 </span>            : {
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   struct coff_debug_merge_hash_entry *ret =</span>
<span class="lineNum">     136 </span>            :     (struct coff_debug_merge_hash_entry *) entry;
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   /* Allocate the structure if it has not already been allocated by a
<span class="lineNum">     139 </span>            :      subclass.  */
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   if (ret == (struct coff_debug_merge_hash_entry *) NULL)</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     ret = ((struct coff_debug_merge_hash_entry *)</span>
<span class="lineNum">     142 </span>            :            bfd_hash_allocate (table,
<span class="lineNum">     143 </span>            :                               sizeof (struct coff_debug_merge_hash_entry)));
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   if (ret == (struct coff_debug_merge_hash_entry *) NULL)</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     return (struct bfd_hash_entry *) ret;</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :   /* Call the allocation method of the superclass.  */
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   ret = ((struct coff_debug_merge_hash_entry *)</span>
<span class="lineNum">     149 </span>            :          bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   if (ret != (struct coff_debug_merge_hash_entry *) NULL)</span>
<span class="lineNum">     151 </span>            :     {
<span class="lineNum">     152 </span>            :       /* Set local fields.  */
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :       ret-&gt;types = NULL;</span>
<span class="lineNum">     154 </span>            :     }
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   return (struct bfd_hash_entry *) ret;</span>
<span class="lineNum">     157 </span>            : }
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : /* Given a COFF BFD, add symbols to the global hash table as
<span class="lineNum">     160 </span>            :    appropriate.  */
<a name="161"><span class="lineNum">     161 </span>            : </a>
<span class="lineNum">     162 </span>            : bfd_boolean
<span class="lineNum">     163 </span><span class="lineNoCov">          0 : _bfd_coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)</span>
<span class="lineNum">     164 </span>            : {
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   switch (bfd_get_format (abfd))</span>
<span class="lineNum">     166 </span>            :     {
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     case bfd_object:</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       return coff_link_add_object_symbols (abfd, info);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     case bfd_archive:</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :       return _bfd_generic_link_add_archive_symbols</span>
<span class="lineNum">     171 </span>            :         (abfd, info, coff_link_check_archive_element);
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">     175 </span>            :     }
<span class="lineNum">     176 </span>            : }
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : /* Add symbols from a COFF object file.  */
<a name="179"><span class="lineNum">     179 </span>            : </a>
<span class="lineNum">     180 </span>            : static bfd_boolean
<span class="lineNum">     181 </span><span class="lineNoCov">          0 : coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)</span>
<span class="lineNum">     182 </span>            : {
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   if (! _bfd_coff_get_external_symbols (abfd))</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   if (! coff_link_add_symbols (abfd, info))</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   if (! info-&gt;keep_memory</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :       &amp;&amp; ! _bfd_coff_free_symbols (abfd))</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">     193 </span>            : }
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /* Check a single archive element to see if we need to include it in
<span class="lineNum">     196 </span>            :    the link.  *PNEEDED is set according to whether this element is
<span class="lineNum">     197 </span>            :    needed in the link or not.  This is called via
<span class="lineNum">     198 </span>            :    _bfd_generic_link_add_archive_symbols.  */
<a name="199"><span class="lineNum">     199 </span>            : </a>
<span class="lineNum">     200 </span>            : static bfd_boolean
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : coff_link_check_archive_element (bfd *abfd,</span>
<span class="lineNum">     202 </span>            :                                  struct bfd_link_info *info,
<span class="lineNum">     203 </span>            :                                  struct bfd_link_hash_entry *h,
<span class="lineNum">     204 </span>            :                                  const char *name,
<span class="lineNum">     205 </span>            :                                  bfd_boolean *pneeded)
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   *pneeded = FALSE;</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   /* We are only interested in symbols that are currently undefined.
<span class="lineNum">     210 </span>            :      If a symbol is currently known to be common, COFF linkers do not
<span class="lineNum">     211 </span>            :      bring in an object file which defines it.  */
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   if (h-&gt;type != bfd_link_hash_undefined)</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   /* Include this element?  */
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   if (!(*info-&gt;callbacks-&gt;add_archive_element) (info, abfd, name, &amp;abfd))</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   *pneeded = TRUE;</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   return coff_link_add_object_symbols (abfd, info);</span>
<span class="lineNum">     221 </span>            : }
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : /* Add all the symbols from an object file to the hash table.  */
<a name="224"><span class="lineNum">     224 </span>            : </a>
<span class="lineNum">     225 </span>            : static bfd_boolean
<span class="lineNum">     226 </span><span class="lineNoCov">          0 : coff_link_add_symbols (bfd *abfd,</span>
<span class="lineNum">     227 </span>            :                        struct bfd_link_info *info)
<span class="lineNum">     228 </span>            : {
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   unsigned int n_tmask = coff_data (abfd)-&gt;local_n_tmask;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   unsigned int n_btshft = coff_data (abfd)-&gt;local_n_btshft;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   unsigned int n_btmask = coff_data (abfd)-&gt;local_n_btmask;</span>
<span class="lineNum">     232 </span>            :   bfd_boolean keep_syms;
<span class="lineNum">     233 </span>            :   bfd_boolean default_copy;
<span class="lineNum">     234 </span>            :   bfd_size_type symcount;
<span class="lineNum">     235 </span>            :   struct coff_link_hash_entry **sym_hash;
<span class="lineNum">     236 </span>            :   bfd_size_type symesz;
<span class="lineNum">     237 </span>            :   bfd_byte *esym;
<span class="lineNum">     238 </span>            :   bfd_byte *esym_end;
<span class="lineNum">     239 </span>            :   bfd_size_type amt;
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   symcount = obj_raw_syment_count (abfd);</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   if (symcount == 0)</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     return TRUE;                /* Nothing to do.  */</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :   /* Keep the symbols during this function, in case the linker needs
<span class="lineNum">     247 </span>            :      to read the generic symbols in order to report an error message.  */
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   keep_syms = obj_coff_keep_syms (abfd);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   obj_coff_keep_syms (abfd) = TRUE;</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   if (info-&gt;keep_memory)</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     default_copy = FALSE;</span>
<span class="lineNum">     253 </span>            :   else
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     default_copy = TRUE;</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :   /* We keep a list of the linker hash table entries that correspond
<span class="lineNum">     257 </span>            :      to particular symbols.  */
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :   amt = symcount * sizeof (struct coff_link_hash_entry *);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   if (sym_hash == NULL)</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     goto error_return;</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   obj_coff_sym_hashes (abfd) = sym_hash;</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   symesz = bfd_coff_symesz (abfd);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   esym = (bfd_byte *) obj_coff_external_syms (abfd);</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   esym_end = esym + symcount * symesz;</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   while (esym &lt; esym_end)</span>
<span class="lineNum">     269 </span>            :     {
<span class="lineNum">     270 </span>            :       struct internal_syment sym;
<span class="lineNum">     271 </span>            :       enum coff_symbol_classification classification;
<span class="lineNum">     272 </span>            :       bfd_boolean copy;
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       bfd_coff_swap_sym_in (abfd, esym, &amp;sym);</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       classification = bfd_coff_classify_symbol (abfd, &amp;sym);</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :       if (classification != COFF_SYMBOL_LOCAL)</span>
<span class="lineNum">     278 </span>            :         {
<span class="lineNum">     279 </span>            :           const char *name;
<span class="lineNum">     280 </span>            :           char buf[SYMNMLEN + 1];
<span class="lineNum">     281 </span>            :           flagword flags;
<span class="lineNum">     282 </span>            :           asection *section;
<span class="lineNum">     283 </span>            :           bfd_vma value;
<span class="lineNum">     284 </span>            :           bfd_boolean addit;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :           /* This symbol is externally visible.  */
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :           name = _bfd_coff_internal_syment_name (abfd, &amp;sym, buf);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :           if (name == NULL)</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :             goto error_return;</span>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :           /* We must copy the name into memory if we got it from the
<span class="lineNum">     293 </span>            :              syment itself, rather than the string table.  */
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :           copy = default_copy;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :           if (sym._n._n_n._n_zeroes != 0</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :               || sym._n._n_n._n_offset == 0)</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :             copy = TRUE;</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :           value = sym.n_value;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :           switch (classification)</span>
<span class="lineNum">     302 </span>            :             {
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :               abort ();</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :             case COFF_SYMBOL_GLOBAL:</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :               flags = BSF_EXPORT | BSF_GLOBAL;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :               section = coff_section_from_bfd_index (abfd, sym.n_scnum);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :               if (! obj_pe (abfd))</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :                 value -= section-&gt;vma;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :             case COFF_SYMBOL_UNDEFINED:</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :               flags = 0;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :               section = bfd_und_section_ptr;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :             case COFF_SYMBOL_COMMON:</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :               flags = BSF_GLOBAL;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :               section = bfd_com_section_ptr;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :             case COFF_SYMBOL_PE_SECTION:</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :               flags = BSF_SECTION_SYM | BSF_GLOBAL;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :               section = coff_section_from_bfd_index (abfd, sym.n_scnum);</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">     327 </span>            :             }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :           if (IS_WEAK_EXTERNAL (abfd, sym))</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             flags = BSF_WEAK;</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :           addit = TRUE;</span>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :           /* In the PE format, section symbols actually refer to the
<span class="lineNum">     335 </span>            :              start of the output section.  We handle them specially
<span class="lineNum">     336 </span>            :              here.  */
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :           if (obj_pe (abfd) &amp;&amp; (flags &amp; BSF_SECTION_SYM) != 0)</span>
<span class="lineNum">     338 </span>            :             {
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :               *sym_hash = coff_link_hash_lookup (coff_hash_table (info),</span>
<span class="lineNum">     340 </span>            :                                                  name, FALSE, copy, FALSE);
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :               if (*sym_hash != NULL)</span>
<span class="lineNum">     342 </span>            :                 {
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                   if (((*sym_hash)-&gt;coff_link_hash_flags</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                        &amp; COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :                       &amp;&amp; (*sym_hash)-&gt;root.type != bfd_link_hash_undefined</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                       &amp;&amp; (*sym_hash)-&gt;root.type != bfd_link_hash_undefweak)</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                     _bfd_error_handler</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                       (_(&quot;Warning: symbol `%s' is both section and non-section&quot;),</span>
<span class="lineNum">     349 </span>            :                        name);
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                   addit = FALSE;</span>
<span class="lineNum">     352 </span>            :                 }
<span class="lineNum">     353 </span>            :             }
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :           /* The Microsoft Visual C compiler does string pooling by
<span class="lineNum">     356 </span>            :              hashing the constants to an internal symbol name, and
<span class="lineNum">     357 </span>            :              relying on the linker comdat support to discard
<span class="lineNum">     358 </span>            :              duplicate names.  However, if one string is a literal and
<span class="lineNum">     359 </span>            :              one is a data initializer, one will end up in the .data
<span class="lineNum">     360 </span>            :              section and one will end up in the .rdata section.  The
<span class="lineNum">     361 </span>            :              Microsoft linker will combine them into the .data
<span class="lineNum">     362 </span>            :              section, which seems to be wrong since it might cause the
<span class="lineNum">     363 </span>            :              literal to change.
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :              As long as there are no external references to the
<span class="lineNum">     366 </span>            :              symbols, which there shouldn't be, we can treat the .data
<span class="lineNum">     367 </span>            :              and .rdata instances as separate symbols.  The comdat
<span class="lineNum">     368 </span>            :              code in the linker will do the appropriate merging.  Here
<span class="lineNum">     369 </span>            :              we avoid getting a multiple definition error for one of
<span class="lineNum">     370 </span>            :              these special symbols.
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :              FIXME: I don't think this will work in the case where
<span class="lineNum">     373 </span>            :              there are two object files which use the constants as a
<span class="lineNum">     374 </span>            :              literal and two object files which use it as a data
<span class="lineNum">     375 </span>            :              initializer.  One or the other of the second object files
<span class="lineNum">     376 </span>            :              is going to wind up with an inappropriate reference.  */
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :           if (obj_pe (abfd)</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :               &amp;&amp; (classification == COFF_SYMBOL_GLOBAL</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                   || classification == COFF_SYMBOL_PE_SECTION)</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :               &amp;&amp; coff_section_data (abfd, section) != NULL</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :               &amp;&amp; coff_section_data (abfd, section)-&gt;comdat != NULL</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :               &amp;&amp; CONST_STRNEQ (name, &quot;??_&quot;)</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :               &amp;&amp; strcmp (name, coff_section_data (abfd, section)-&gt;comdat-&gt;name) == 0)</span>
<span class="lineNum">     384 </span>            :             {
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :               if (*sym_hash == NULL)</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :                 *sym_hash = coff_link_hash_lookup (coff_hash_table (info),</span>
<span class="lineNum">     387 </span>            :                                                    name, FALSE, copy, FALSE);
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :               if (*sym_hash != NULL</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :                   &amp;&amp; (*sym_hash)-&gt;root.type == bfd_link_hash_defined</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                   &amp;&amp; coff_section_data (abfd, (*sym_hash)-&gt;root.u.def.section)-&gt;comdat != NULL</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :                   &amp;&amp; strcmp (coff_section_data (abfd, (*sym_hash)-&gt;root.u.def.section)-&gt;comdat-&gt;name,</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :                              coff_section_data (abfd, section)-&gt;comdat-&gt;name) == 0)</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :                 addit = FALSE;</span>
<span class="lineNum">     394 </span>            :             }
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :           if (addit)</span>
<span class="lineNum">     397 </span>            :             {
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :               if (! (bfd_coff_link_add_one_symbol</span>
<span class="lineNum">     399 </span>            :                      (info, abfd, name, flags, section, value,
<span class="lineNum">     400 </span>            :                       (const char *) NULL, copy, FALSE,
<span class="lineNum">     401 </span>            :                       (struct bfd_link_hash_entry **) sym_hash)))
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                 goto error_return;</span>
<span class="lineNum">     403 </span>            :             }
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :           if (obj_pe (abfd) &amp;&amp; (flags &amp; BSF_SECTION_SYM) != 0)</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :             (*sym_hash)-&gt;coff_link_hash_flags |=</span>
<span class="lineNum">     407 </span>            :               COFF_LINK_HASH_PE_SECTION_SYMBOL;
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :           /* Limit the alignment of a common symbol to the possible
<span class="lineNum">     410 </span>            :              alignment of a section.  There is no point to permitting
<span class="lineNum">     411 </span>            :              a higher alignment for a common symbol: we can not
<span class="lineNum">     412 </span>            :              guarantee it, and it may cause us to allocate extra space
<span class="lineNum">     413 </span>            :              in the common section.  */
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :           if (section == bfd_com_section_ptr</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :               &amp;&amp; (*sym_hash)-&gt;root.type == bfd_link_hash_common</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :               &amp;&amp; ((*sym_hash)-&gt;root.u.c.p-&gt;alignment_power</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :                   &gt; bfd_coff_default_section_alignment_power (abfd)))</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :             (*sym_hash)-&gt;root.u.c.p-&gt;alignment_power</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :               = bfd_coff_default_section_alignment_power (abfd);</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :           if (bfd_get_flavour (info-&gt;output_bfd) == bfd_get_flavour (abfd))</span>
<span class="lineNum">     422 </span>            :             {
<span class="lineNum">     423 </span>            :               /* If we don't have any symbol information currently in
<span class="lineNum">     424 </span>            :                  the hash table, or if we are looking at a symbol
<span class="lineNum">     425 </span>            :                  definition, then update the symbol class and type in
<span class="lineNum">     426 </span>            :                  the hash table.  */
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :               if (((*sym_hash)-&gt;symbol_class == C_NULL</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                    &amp;&amp; (*sym_hash)-&gt;type == T_NULL)</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                   || sym.n_scnum != 0</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                   || (sym.n_value != 0</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                       &amp;&amp; (*sym_hash)-&gt;root.type != bfd_link_hash_defined</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                       &amp;&amp; (*sym_hash)-&gt;root.type != bfd_link_hash_defweak))</span>
<span class="lineNum">     433 </span>            :                 {
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                   (*sym_hash)-&gt;symbol_class = sym.n_sclass;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                   if (sym.n_type != T_NULL)</span>
<span class="lineNum">     436 </span>            :                     {
<span class="lineNum">     437 </span>            :                       /* We want to warn if the type changed, but not
<span class="lineNum">     438 </span>            :                          if it changed from an unspecified type.
<span class="lineNum">     439 </span>            :                          Testing the whole type byte may work, but the
<span class="lineNum">     440 </span>            :                          change from (e.g.) a function of unspecified
<span class="lineNum">     441 </span>            :                          type to function of known type also wants to
<span class="lineNum">     442 </span>            :                          skip the warning.  */
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :                       if ((*sym_hash)-&gt;type != T_NULL</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                           &amp;&amp; (*sym_hash)-&gt;type != sym.n_type</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                           &amp;&amp; !(DTYPE ((*sym_hash)-&gt;type) == DTYPE (sym.n_type)</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                                &amp;&amp; (BTYPE ((*sym_hash)-&gt;type) == T_NULL</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :                                    || BTYPE (sym.n_type) == T_NULL)))</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :                         _bfd_error_handler</span>
<span class="lineNum">     449 </span>            :                           /* xgettext: c-format */
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                           (_(&quot;Warning: type of symbol `%s' changed from %d to %d in %B&quot;),</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                            abfd, name, (*sym_hash)-&gt;type, sym.n_type);</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :                       /* We don't want to change from a meaningful
<span class="lineNum">     454 </span>            :                          base type to a null one, but if we know
<span class="lineNum">     455 </span>            :                          nothing, take what little we might now know.  */
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :                       if (BTYPE (sym.n_type) != T_NULL</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                           || (*sym_hash)-&gt;type == T_NULL)</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                         (*sym_hash)-&gt;type = sym.n_type;</span>
<span class="lineNum">     459 </span>            :                     }
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :                   (*sym_hash)-&gt;auxbfd = abfd;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                   if (sym.n_numaux != 0)</span>
<span class="lineNum">     462 </span>            :                     {
<span class="lineNum">     463 </span>            :                       union internal_auxent *alloc;
<span class="lineNum">     464 </span>            :                       unsigned int i;
<span class="lineNum">     465 </span>            :                       bfd_byte *eaux;
<span class="lineNum">     466 </span>            :                       union internal_auxent *iaux;
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :                       (*sym_hash)-&gt;numaux = sym.n_numaux;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                       alloc = ((union internal_auxent *)</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :                                bfd_hash_allocate (&amp;info-&gt;hash-&gt;table,</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                                                   (sym.n_numaux</span>
<span class="lineNum">     472 </span>            :                                                    * sizeof (*alloc))));
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                       if (alloc == NULL)</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         goto error_return;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                       for (i = 0, eaux = esym + symesz, iaux = alloc;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                            i &lt; sym.n_numaux;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                            i++, eaux += symesz, iaux++)</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                         bfd_coff_swap_aux_in (abfd, eaux, sym.n_type,</span>
<span class="lineNum">     479 </span>            :                                               sym.n_sclass, (int) i,
<span class="lineNum">     480 </span>            :                                               sym.n_numaux, iaux);
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                       (*sym_hash)-&gt;aux = alloc;</span>
<span class="lineNum">     482 </span>            :                     }
<span class="lineNum">     483 </span>            :                 }
<span class="lineNum">     484 </span>            :             }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :           if (classification == COFF_SYMBOL_PE_SECTION</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :               &amp;&amp; (*sym_hash)-&gt;numaux != 0)</span>
<span class="lineNum">     488 </span>            :             {
<span class="lineNum">     489 </span>            :               /* Some PE sections (such as .bss) have a zero size in
<span class="lineNum">     490 </span>            :                  the section header, but a non-zero size in the AUX
<span class="lineNum">     491 </span>            :                  record.  Correct that here.
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :                  FIXME: This is not at all the right place to do this.
<span class="lineNum">     494 </span>            :                  For example, it won't help objdump.  This needs to be
<span class="lineNum">     495 </span>            :                  done when we swap in the section header.  */
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :               BFD_ASSERT ((*sym_hash)-&gt;numaux == 1);</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :               if (section-&gt;size == 0)</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :                 section-&gt;size = (*sym_hash)-&gt;aux[0].x_scn.x_scnlen;</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :               /* FIXME: We could test whether the section sizes
<span class="lineNum">     501 </span>            :                  matches the size in the aux entry, but apparently
<span class="lineNum">     502 </span>            :                  that sometimes fails unexpectedly.  */
<span class="lineNum">     503 </span>            :             }
<span class="lineNum">     504 </span>            :         }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :       esym += (sym.n_numaux + 1) * symesz;</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :       sym_hash += sym.n_numaux + 1;</span>
<span class="lineNum">     508 </span>            :     }
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            :   /* If this is a non-traditional, non-relocatable link, try to
<span class="lineNum">     511 </span>            :      optimize the handling of any .stab/.stabstr sections.  */
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   if (! bfd_link_relocatable (info)</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :       &amp;&amp; ! info-&gt;traditional_format</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       &amp;&amp; bfd_get_flavour (info-&gt;output_bfd) == bfd_get_flavour (abfd)</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       &amp;&amp; (info-&gt;strip != strip_all &amp;&amp; info-&gt;strip != strip_debugger))</span>
<span class="lineNum">     516 </span>            :     {
<span class="lineNum">     517 </span>            :       asection *stabstr;
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       stabstr = bfd_get_section_by_name (abfd, &quot;.stabstr&quot;);</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       if (stabstr != NULL)</span>
<span class="lineNum">     522 </span>            :         {
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :           bfd_size_type string_offset = 0;</span>
<span class="lineNum">     524 </span>            :           asection *stab;
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :           for (stab = abfd-&gt;sections; stab; stab = stab-&gt;next)</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :             if (CONST_STRNEQ (stab-&gt;name, &quot;.stab&quot;)</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                 &amp;&amp; (!stab-&gt;name[5]</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                     || (stab-&gt;name[5] == '.' &amp;&amp; ISDIGIT (stab-&gt;name[6]))))</span>
<span class="lineNum">     530 </span>            :             {
<span class="lineNum">     531 </span>            :               struct coff_link_hash_table *table;
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :               struct coff_section_tdata *secdata</span>
<span class="lineNum">     533 </span>            :                 = coff_section_data (abfd, stab);
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :               if (secdata == NULL)</span>
<span class="lineNum">     536 </span>            :                 {
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :                   amt = sizeof (struct coff_section_tdata);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :                   stab-&gt;used_by_bfd = bfd_zalloc (abfd, amt);</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                   if (stab-&gt;used_by_bfd == NULL)</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                     goto error_return;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :                   secdata = coff_section_data (abfd, stab);</span>
<span class="lineNum">     542 </span>            :                 }
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :               table = coff_hash_table (info);</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :               if (! _bfd_link_section_stabs (abfd, &amp;table-&gt;stab_info,</span>
<span class="lineNum">     547 </span>            :                                              stab, stabstr,
<span class="lineNum">     548 </span>            :                                              &amp;secdata-&gt;stab_info,
<span class="lineNum">     549 </span>            :                                              &amp;string_offset))
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :                 goto error_return;</span>
<span class="lineNum">     551 </span>            :             }
<span class="lineNum">     552 </span>            :         }
<span class="lineNum">     553 </span>            :     }
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   obj_coff_keep_syms (abfd) = keep_syms;</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :  error_return:</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   obj_coff_keep_syms (abfd) = keep_syms;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   return FALSE;</span>
<span class="lineNum">     562 </span>            : }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : /* Do the final link step.  */
<a name="565"><span class="lineNum">     565 </span>            : </a>
<span class="lineNum">     566 </span>            : bfd_boolean
<span class="lineNum">     567 </span><span class="lineNoCov">          0 : _bfd_coff_final_link (bfd *abfd,</span>
<span class="lineNum">     568 </span>            :                       struct bfd_link_info *info)
<span class="lineNum">     569 </span>            : {
<span class="lineNum">     570 </span>            :   bfd_size_type symesz;
<span class="lineNum">     571 </span>            :   struct coff_final_link_info flaginfo;
<span class="lineNum">     572 </span>            :   bfd_boolean debug_merge_allocated;
<span class="lineNum">     573 </span>            :   bfd_boolean long_section_names;
<span class="lineNum">     574 </span>            :   asection *o;
<span class="lineNum">     575 </span>            :   struct bfd_link_order *p;
<span class="lineNum">     576 </span>            :   bfd_size_type max_sym_count;
<span class="lineNum">     577 </span>            :   bfd_size_type max_lineno_count;
<span class="lineNum">     578 </span>            :   bfd_size_type max_reloc_count;
<span class="lineNum">     579 </span>            :   bfd_size_type max_output_reloc_count;
<span class="lineNum">     580 </span>            :   bfd_size_type max_contents_size;
<span class="lineNum">     581 </span>            :   file_ptr rel_filepos;
<span class="lineNum">     582 </span>            :   unsigned int relsz;
<span class="lineNum">     583 </span>            :   file_ptr line_filepos;
<span class="lineNum">     584 </span>            :   unsigned int linesz;
<span class="lineNum">     585 </span>            :   bfd *sub;
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   bfd_byte *external_relocs = NULL;</span>
<span class="lineNum">     587 </span>            :   char strbuf[STRING_SIZE_SIZE];
<span class="lineNum">     588 </span>            :   bfd_size_type amt;
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   symesz = bfd_coff_symesz (abfd);</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   flaginfo.info = info;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   flaginfo.output_bfd = abfd;</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   flaginfo.strtab = NULL;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   flaginfo.section_info = NULL;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   flaginfo.last_file_index = -1;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   flaginfo.last_bf_index = -1;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :   flaginfo.internal_syms = NULL;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :   flaginfo.sec_ptrs = NULL;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   flaginfo.sym_indices = NULL;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :   flaginfo.outsyms = NULL;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   flaginfo.linenos = NULL;</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   flaginfo.contents = NULL;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   flaginfo.external_relocs = NULL;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :   flaginfo.internal_relocs = NULL;</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   flaginfo.global_to_static = FALSE;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   debug_merge_allocated = FALSE;</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   coff_data (abfd)-&gt;link_info = info;</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :   flaginfo.strtab = _bfd_stringtab_init ();</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   if (flaginfo.strtab == NULL)</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     goto error_return;</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   if (! coff_debug_merge_hash_table_init (&amp;flaginfo.debug_merge))</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     goto error_return;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   debug_merge_allocated = TRUE;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :   /* Compute the file positions for all the sections.  */
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   if (! abfd-&gt;output_has_begun)</span>
<span class="lineNum">     621 </span>            :     {
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :       if (! bfd_coff_compute_section_file_positions (abfd))</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :         goto error_return;</span>
<span class="lineNum">     624 </span>            :     }
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :   /* Count the line numbers and relocation entries required for the
<span class="lineNum">     627 </span>            :      output file.  Set the file positions for the relocs.  */
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :   rel_filepos = obj_relocbase (abfd);</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :   relsz = bfd_coff_relsz (abfd);</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :   max_contents_size = 0;</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :   max_lineno_count = 0;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :   max_reloc_count = 0;</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   long_section_names = FALSE;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   for (o = abfd-&gt;sections; o != NULL; o = o-&gt;next)</span>
<span class="lineNum">     636 </span>            :     {
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       o-&gt;reloc_count = 0;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       o-&gt;lineno_count = 0;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :       for (p = o-&gt;map_head.link_order; p != NULL; p = p-&gt;next)</span>
<span class="lineNum">     640 </span>            :         {
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :           if (p-&gt;type == bfd_indirect_link_order)</span>
<span class="lineNum">     642 </span>            :             {
<span class="lineNum">     643 </span>            :               asection *sec;
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :               sec = p-&gt;u.indirect.section;</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            :               /* Mark all sections which are to be included in the
<span class="lineNum">     648 </span>            :                  link.  This will normally be every section.  We need
<span class="lineNum">     649 </span>            :                  to do this so that we can identify any sections which
<span class="lineNum">     650 </span>            :                  the linker has decided to not include.  */
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :               sec-&gt;linker_mark = TRUE;</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :               if (info-&gt;strip == strip_none</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                   || info-&gt;strip == strip_some)</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :                 o-&gt;lineno_count += sec-&gt;lineno_count;</span>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :               if (bfd_link_relocatable (info))</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :                 o-&gt;reloc_count += sec-&gt;reloc_count;</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :               if (sec-&gt;rawsize &gt; max_contents_size)</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :                 max_contents_size = sec-&gt;rawsize;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :               if (sec-&gt;size &gt; max_contents_size)</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 max_contents_size = sec-&gt;size;</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :               if (sec-&gt;lineno_count &gt; max_lineno_count)</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                 max_lineno_count = sec-&gt;lineno_count;</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :               if (sec-&gt;reloc_count &gt; max_reloc_count)</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                 max_reloc_count = sec-&gt;reloc_count;</span>
<span class="lineNum">     668 </span>            :             }
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :           else if (bfd_link_relocatable (info)</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                    &amp;&amp; (p-&gt;type == bfd_section_reloc_link_order</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :                        || p-&gt;type == bfd_symbol_reloc_link_order))</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :             ++o-&gt;reloc_count;</span>
<span class="lineNum">     673 </span>            :         }
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :       if (o-&gt;reloc_count == 0)</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         o-&gt;rel_filepos = 0;</span>
<span class="lineNum">     676 </span>            :       else
<span class="lineNum">     677 </span>            :         {
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :           o-&gt;flags |= SEC_RELOC;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :           o-&gt;rel_filepos = rel_filepos;</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :           rel_filepos += o-&gt;reloc_count * relsz;</span>
<span class="lineNum">     681 </span>            :           /* In PE COFF, if there are at least 0xffff relocations an
<span class="lineNum">     682 </span>            :              extra relocation will be written out to encode the count.  */
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :           if (obj_pe (abfd) &amp;&amp; o-&gt;reloc_count &gt;= 0xffff)</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :             rel_filepos += relsz;</span>
<span class="lineNum">     685 </span>            :         }
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :       if (bfd_coff_long_section_names (abfd)</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :           &amp;&amp; strlen (o-&gt;name) &gt; SCNNMLEN)</span>
<span class="lineNum">     689 </span>            :         {
<span class="lineNum">     690 </span>            :           /* This section has a long name which must go in the string
<span class="lineNum">     691 </span>            :              table.  This must correspond to the code in
<span class="lineNum">     692 </span>            :              coff_write_object_contents which puts the string index
<span class="lineNum">     693 </span>            :              into the s_name field of the section header.  That is why
<span class="lineNum">     694 </span>            :              we pass hash as FALSE.  */
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :           if (_bfd_stringtab_add (flaginfo.strtab, o-&gt;name, FALSE, FALSE)</span>
<span class="lineNum">     696 </span>            :               == (bfd_size_type) -1)
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :             goto error_return;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :           long_section_names = TRUE;</span>
<span class="lineNum">     699 </span>            :         }
<span class="lineNum">     700 </span>            :     }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :   /* If doing a relocatable link, allocate space for the pointers we
<span class="lineNum">     703 </span>            :      need to keep.  */
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   if (bfd_link_relocatable (info))</span>
<span class="lineNum">     705 </span>            :     {
<span class="lineNum">     706 </span>            :       unsigned int i;
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :       /* We use section_count + 1, rather than section_count, because
<span class="lineNum">     709 </span>            :          the target_index fields are 1 based.  */
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       amt = abfd-&gt;section_count + 1;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       amt *= sizeof (struct coff_link_section_info);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       flaginfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       if (flaginfo.section_info == NULL)</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         goto error_return;</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt;= abfd-&gt;section_count; i++)</span>
<span class="lineNum">     716 </span>            :         {
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :           flaginfo.section_info[i].relocs = NULL;</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :           flaginfo.section_info[i].rel_hashes = NULL;</span>
<span class="lineNum">     719 </span>            :         }
<span class="lineNum">     720 </span>            :     }
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :   /* We now know the size of the relocs, so we can determine the file
<span class="lineNum">     723 </span>            :      positions of the line numbers.  */
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   line_filepos = rel_filepos;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   linesz = bfd_coff_linesz (abfd);</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :   max_output_reloc_count = 0;</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   for (o = abfd-&gt;sections; o != NULL; o = o-&gt;next)</span>
<span class="lineNum">     728 </span>            :     {
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       if (o-&gt;lineno_count == 0)</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :         o-&gt;line_filepos = 0;</span>
<span class="lineNum">     731 </span>            :       else
<span class="lineNum">     732 </span>            :         {
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :           o-&gt;line_filepos = line_filepos;</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :           line_filepos += o-&gt;lineno_count * linesz;</span>
<span class="lineNum">     735 </span>            :         }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       if (o-&gt;reloc_count != 0)</span>
<span class="lineNum">     738 </span>            :         {
<span class="lineNum">     739 </span>            :           /* We don't know the indices of global symbols until we have
<span class="lineNum">     740 </span>            :              written out all the local symbols.  For each section in
<span class="lineNum">     741 </span>            :              the output file, we keep an array of pointers to hash
<span class="lineNum">     742 </span>            :              table entries.  Each entry in the array corresponds to a
<span class="lineNum">     743 </span>            :              reloc.  When we find a reloc against a global symbol, we
<span class="lineNum">     744 </span>            :              set the corresponding entry in this array so that we can
<span class="lineNum">     745 </span>            :              fix up the symbol index after we have written out all the
<span class="lineNum">     746 </span>            :              local symbols.
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            :              Because of this problem, we also keep the relocs in
<span class="lineNum">     749 </span>            :              memory until the end of the link.  This wastes memory,
<span class="lineNum">     750 </span>            :              but only when doing a relocatable link, which is not the
<span class="lineNum">     751 </span>            :              common case.  */
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :           BFD_ASSERT (bfd_link_relocatable (info));</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :           amt = o-&gt;reloc_count;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :           amt *= sizeof (struct internal_reloc);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :           flaginfo.section_info[o-&gt;target_index].relocs =</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :               (struct internal_reloc *) bfd_malloc (amt);</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :           amt = o-&gt;reloc_count;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :           amt *= sizeof (struct coff_link_hash_entry *);</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :           flaginfo.section_info[o-&gt;target_index].rel_hashes =</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :               (struct coff_link_hash_entry **) bfd_malloc (amt);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :           if (flaginfo.section_info[o-&gt;target_index].relocs == NULL</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :               || flaginfo.section_info[o-&gt;target_index].rel_hashes == NULL)</span>
<span class="lineNum">     763 </span>            :             goto error_return;
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :           if (o-&gt;reloc_count &gt; max_output_reloc_count)</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :             max_output_reloc_count = o-&gt;reloc_count;</span>
<span class="lineNum">     767 </span>            :         }
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :       /* Reset the reloc and lineno counts, so that we can use them to
<span class="lineNum">     770 </span>            :          count the number of entries we have output so far.  */
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :       o-&gt;reloc_count = 0;</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :       o-&gt;lineno_count = 0;</span>
<span class="lineNum">     773 </span>            :     }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   obj_sym_filepos (abfd) = line_filepos;</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :   /* Figure out the largest number of symbols in an input BFD.  Take
<span class="lineNum">     778 </span>            :      the opportunity to clear the output_has_begun fields of all the
<span class="lineNum">     779 </span>            :      input BFD's.  */
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   max_sym_count = 0;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   for (sub = info-&gt;input_bfds; sub != NULL; sub = sub-&gt;link.next)</span>
<span class="lineNum">     782 </span>            :     {
<span class="lineNum">     783 </span>            :       size_t sz;
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :       sub-&gt;output_has_begun = FALSE;</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :       sz = bfd_family_coff (sub) ? obj_raw_syment_count (sub) : 2;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :       if (sz &gt; max_sym_count)</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         max_sym_count = sz;</span>
<span class="lineNum">     789 </span>            :     }
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :   /* Allocate some buffers used while linking.  */
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :   amt = max_sym_count * sizeof (struct internal_syment);</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   amt = max_sym_count * sizeof (asection *);</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   amt = max_sym_count * sizeof (long);</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :   flaginfo.sym_indices = (long int *) bfd_malloc (amt);</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   flaginfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   amt = max_lineno_count * bfd_coff_linesz (abfd);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   flaginfo.linenos = (bfd_byte *) bfd_malloc (amt);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   flaginfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   amt = max_reloc_count * relsz;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   flaginfo.external_relocs = (bfd_byte *) bfd_malloc (amt);</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   if (! bfd_link_relocatable (info))</span>
<span class="lineNum">     805 </span>            :     {
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :       amt = max_reloc_count * sizeof (struct internal_reloc);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :       flaginfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);</span>
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   if ((flaginfo.internal_syms == NULL &amp;&amp; max_sym_count &gt; 0)</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :       || (flaginfo.sec_ptrs == NULL &amp;&amp; max_sym_count &gt; 0)</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :       || (flaginfo.sym_indices == NULL &amp;&amp; max_sym_count &gt; 0)</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       || flaginfo.outsyms == NULL</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :       || (flaginfo.linenos == NULL &amp;&amp; max_lineno_count &gt; 0)</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :       || (flaginfo.contents == NULL &amp;&amp; max_contents_size &gt; 0)</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :       || (flaginfo.external_relocs == NULL &amp;&amp; max_reloc_count &gt; 0)</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :       || (! bfd_link_relocatable (info)</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :           &amp;&amp; flaginfo.internal_relocs == NULL</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :           &amp;&amp; max_reloc_count &gt; 0))</span>
<span class="lineNum">     819 </span>            :     goto error_return;
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            :   /* We now know the position of everything in the file, except that
<span class="lineNum">     822 </span>            :      we don't know the size of the symbol table and therefore we don't
<span class="lineNum">     823 </span>            :      know where the string table starts.  We just build the string
<span class="lineNum">     824 </span>            :      table in memory as we go along.  We process all the relocations
<span class="lineNum">     825 </span>            :      for a single input file at once.  */
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   obj_raw_syment_count (abfd) = 0;</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   if (coff_backend_info (abfd)-&gt;_bfd_coff_start_final_link)</span>
<span class="lineNum">     829 </span>            :     {
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :       if (! bfd_coff_start_final_link (abfd, info))</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :         goto error_return;</span>
<span class="lineNum">     832 </span>            :     }
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   for (o = abfd-&gt;sections; o != NULL; o = o-&gt;next)</span>
<span class="lineNum">     835 </span>            :     {
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :       for (p = o-&gt;map_head.link_order; p != NULL; p = p-&gt;next)</span>
<span class="lineNum">     837 </span>            :         {
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :           if (p-&gt;type == bfd_indirect_link_order</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :               &amp;&amp; bfd_family_coff (p-&gt;u.indirect.section-&gt;owner))</span>
<span class="lineNum">     840 </span>            :             {
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :               sub = p-&gt;u.indirect.section-&gt;owner;</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :               if (! bfd_coff_link_output_has_begun (sub, &amp; flaginfo))</span>
<span class="lineNum">     843 </span>            :                 {
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :                   if (! _bfd_coff_link_input_bfd (&amp;flaginfo, sub))</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                     goto error_return;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :                   sub-&gt;output_has_begun = TRUE;</span>
<span class="lineNum">     847 </span>            :                 }
<span class="lineNum">     848 </span>            :             }
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :           else if (p-&gt;type == bfd_section_reloc_link_order</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :                    || p-&gt;type == bfd_symbol_reloc_link_order)</span>
<span class="lineNum">     851 </span>            :             {
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :               if (! _bfd_coff_reloc_link_order (abfd, &amp;flaginfo, o, p))</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :                 goto error_return;</span>
<span class="lineNum">     854 </span>            :             }
<span class="lineNum">     855 </span>            :           else
<span class="lineNum">     856 </span>            :             {
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :               if (! _bfd_default_link_order (abfd, info, o, p))</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                 goto error_return;</span>
<span class="lineNum">     859 </span>            :             }
<span class="lineNum">     860 </span>            :         }
<span class="lineNum">     861 </span>            :     }
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   if (flaginfo.info-&gt;strip != strip_all &amp;&amp; flaginfo.info-&gt;discard != discard_all)</span>
<span class="lineNum">     864 </span>            :     {
<span class="lineNum">     865 </span>            :       /* Add local symbols from foreign inputs.  */
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       for (sub = info-&gt;input_bfds; sub != NULL; sub = sub-&gt;link.next)</span>
<span class="lineNum">     867 </span>            :         {
<span class="lineNum">     868 </span>            :           unsigned int i;
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :           if (bfd_family_coff (sub) || ! bfd_get_outsymbols (sub))</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :           for (i = 0; i &lt; bfd_get_symcount (sub); ++i)</span>
<span class="lineNum">     873 </span>            :             {
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :               asymbol *sym = bfd_get_outsymbols (sub) [i];</span>
<span class="lineNum">     875 </span>            :               file_ptr pos;
<span class="lineNum">     876 </span>            :               struct internal_syment isym;
<span class="lineNum">     877 </span>            :               union internal_auxent iaux;
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :               bfd_size_type string_size = 0, indx;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :               bfd_vma written = 0;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :               bfd_boolean rewrite = FALSE, hash;</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :               if (! (sym-&gt;flags &amp; BSF_LOCAL)</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                   || (sym-&gt;flags &amp; (BSF_SECTION_SYM | BSF_DEBUGGING_RELOC</span>
<span class="lineNum">     884 </span>            :                                     | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC
<span class="lineNum">     885 </span>            :                                     | BSF_SYNTHETIC))
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :                   || ((sym-&gt;flags &amp; BSF_DEBUGGING)</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :                       &amp;&amp; ! (sym-&gt;flags &amp; BSF_FILE)))</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            :               /* See if we are discarding symbols with this name.  */
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :               if ((flaginfo.info-&gt;strip == strip_some</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :                    &amp;&amp; (bfd_hash_lookup (flaginfo.info-&gt;keep_hash,</span>
<span class="lineNum">     893 </span>            :                                         bfd_asymbol_name(sym), FALSE, FALSE)
<span class="lineNum">     894 </span>            :                        == NULL))
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                   || (((flaginfo.info-&gt;discard == discard_sec_merge</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                         &amp;&amp; (bfd_get_section (sym)-&gt;flags &amp; SEC_MERGE)</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :                         &amp;&amp; ! bfd_link_relocatable (flaginfo.info))</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :                        || flaginfo.info-&gt;discard == discard_l)</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :                       &amp;&amp; bfd_is_local_label_name (sub, bfd_asymbol_name(sym))))</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :               pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd)</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                                              * symesz;</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :               if (bfd_seek (abfd, pos, SEEK_SET) != 0)</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :                 goto error_return;</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :               if (! coff_write_alien_symbol(abfd, sym, &amp;isym, &amp;iaux, &amp;written,</span>
<span class="lineNum">     907 </span>            :                                             &amp;string_size, NULL, NULL))
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :                 goto error_return;</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :               hash = !flaginfo.info-&gt;traditional_format;</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :               if (string_size &gt;= 6 &amp;&amp; isym.n_sclass == C_FILE</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :                   &amp;&amp; ! isym._n._n_n._n_zeroes &amp;&amp; isym.n_numaux)</span>
<span class="lineNum">     914 </span>            :                 {
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :                   indx = _bfd_stringtab_add (flaginfo.strtab, &quot;.file&quot;, hash,</span>
<span class="lineNum">     916 </span>            :                                              FALSE);
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                   if (indx == (bfd_size_type) -1)</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                     goto error_return;</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                   isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :                   bfd_coff_swap_sym_out (abfd, &amp;isym, flaginfo.outsyms);</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :                   if (bfd_seek (abfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :                       || bfd_bwrite (flaginfo.outsyms, symesz,</span>
<span class="lineNum">     923 </span>            :                                      abfd) != symesz)
<span class="lineNum">     924 </span>            :                     goto error_return;
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :                   string_size -= 6;</span>
<span class="lineNum">     926 </span>            :                 }
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :               if (string_size)</span>
<span class="lineNum">     929 </span>            :                 {
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                   indx = _bfd_stringtab_add (flaginfo.strtab,</span>
<span class="lineNum">     931 </span>            :                                              bfd_asymbol_name (sym), hash,
<span class="lineNum">     932 </span>            :                                              FALSE);
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :                   if (indx == (bfd_size_type) -1)</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :                     goto error_return;</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :                   if (isym.n_sclass != C_FILE)</span>
<span class="lineNum">     936 </span>            :                     {
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :                       isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :                       bfd_coff_swap_sym_out (abfd, &amp;isym, flaginfo.outsyms);</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :                       rewrite = TRUE;</span>
<span class="lineNum">     940 </span>            :                     }
<span class="lineNum">     941 </span>            :                   else
<span class="lineNum">     942 </span>            :                     {
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :                       BFD_ASSERT (isym.n_numaux == 1);</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :                       iaux.x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                       bfd_coff_swap_aux_out (abfd, &amp;iaux, isym.n_type, C_FILE,</span>
<span class="lineNum">     946 </span>            :                                              0, 1, flaginfo.outsyms + symesz);
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :                       if (bfd_seek (abfd, pos + symesz, SEEK_SET) != 0</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :                           || bfd_bwrite (flaginfo.outsyms + symesz, symesz,</span>
<span class="lineNum">     949 </span>            :                                          abfd) != symesz)
<span class="lineNum">     950 </span>            :                         goto error_return;
<span class="lineNum">     951 </span>            :                     }
<span class="lineNum">     952 </span>            :                 }
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :               if (isym.n_sclass == C_FILE)</span>
<span class="lineNum">     955 </span>            :                 {
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :                   if (flaginfo.last_file_index != -1)</span>
<span class="lineNum">     957 </span>            :                     {
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :                       flaginfo.last_file.n_value = obj_raw_syment_count (abfd);</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                       bfd_coff_swap_sym_out (abfd, &amp;flaginfo.last_file,</span>
<span class="lineNum">     960 </span>            :                                              flaginfo.outsyms);
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                       pos = obj_sym_filepos (abfd) + flaginfo.last_file_index</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :                                                      * symesz;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                       rewrite = TRUE;</span>
<span class="lineNum">     964 </span>            :                     }
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :                   flaginfo.last_file_index = obj_raw_syment_count (abfd);</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :                   flaginfo.last_file = isym;</span>
<span class="lineNum">     967 </span>            :                 }
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :               if (rewrite</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :                   &amp;&amp; (bfd_seek (abfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :                       || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz))</span>
<span class="lineNum">     972 </span>            :                 goto error_return;
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :               obj_raw_syment_count (abfd) += written;</span>
<span class="lineNum">     975 </span>            :             }
<span class="lineNum">     976 </span>            :         }
<span class="lineNum">     977 </span>            :     }
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   if (! bfd_coff_final_link_postscript (abfd, &amp; flaginfo))</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :     goto error_return;</span>
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :   /* Free up the buffers used by _bfd_coff_link_input_bfd.  */
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   coff_debug_merge_hash_table_free (&amp;flaginfo.debug_merge);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   debug_merge_allocated = FALSE;</span>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   if (flaginfo.internal_syms != NULL)</span>
<span class="lineNum">     988 </span>            :     {
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :       free (flaginfo.internal_syms);</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :       flaginfo.internal_syms = NULL;</span>
<span class="lineNum">     991 </span>            :     }
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   if (flaginfo.sec_ptrs != NULL)</span>
<span class="lineNum">     993 </span>            :     {
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :       free (flaginfo.sec_ptrs);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :       flaginfo.sec_ptrs = NULL;</span>
<span class="lineNum">     996 </span>            :     }
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   if (flaginfo.sym_indices != NULL)</span>
<span class="lineNum">     998 </span>            :     {
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :       free (flaginfo.sym_indices);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :       flaginfo.sym_indices = NULL;</span>
<span class="lineNum">    1001 </span>            :     }
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   if (flaginfo.linenos != NULL)</span>
<span class="lineNum">    1003 </span>            :     {
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :       free (flaginfo.linenos);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :       flaginfo.linenos = NULL;</span>
<span class="lineNum">    1006 </span>            :     }
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   if (flaginfo.contents != NULL)</span>
<span class="lineNum">    1008 </span>            :     {
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :       free (flaginfo.contents);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       flaginfo.contents = NULL;</span>
<span class="lineNum">    1011 </span>            :     }
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   if (flaginfo.external_relocs != NULL)</span>
<span class="lineNum">    1013 </span>            :     {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :       free (flaginfo.external_relocs);</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :       flaginfo.external_relocs = NULL;</span>
<span class="lineNum">    1016 </span>            :     }
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   if (flaginfo.internal_relocs != NULL)</span>
<span class="lineNum">    1018 </span>            :     {
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :       free (flaginfo.internal_relocs);</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       flaginfo.internal_relocs = NULL;</span>
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :   /* The value of the last C_FILE symbol is supposed to be the symbol
<span class="lineNum">    1024 </span>            :      index of the first external symbol.  Write it out again if
<span class="lineNum">    1025 </span>            :      necessary.  */
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   if (flaginfo.last_file_index != -1</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :       &amp;&amp; (unsigned int) flaginfo.last_file.n_value != obj_raw_syment_count (abfd))</span>
<span class="lineNum">    1028 </span>            :     {
<span class="lineNum">    1029 </span>            :       file_ptr pos;
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :       flaginfo.last_file.n_value = obj_raw_syment_count (abfd);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :       bfd_coff_swap_sym_out (abfd, &amp;flaginfo.last_file,</span>
<span class="lineNum">    1033 </span>            :                              flaginfo.outsyms);
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :       pos = obj_sym_filepos (abfd) + flaginfo.last_file_index * symesz;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       if (bfd_seek (abfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :           || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz)</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1039 </span>            :     }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :   /* If doing task linking (ld --task-link) then make a pass through the
<span class="lineNum">    1042 </span>            :      global symbols, writing out any that are defined, and making them
<span class="lineNum">    1043 </span>            :      static.  */
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   if (info-&gt;task_link)</span>
<span class="lineNum">    1045 </span>            :     {
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :       flaginfo.failed = FALSE;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :       coff_link_hash_traverse (coff_hash_table (info),</span>
<span class="lineNum">    1048 </span>            :                                _bfd_coff_write_task_globals, &amp;flaginfo);
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :       if (flaginfo.failed)</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         goto error_return;</span>
<span class="lineNum">    1051 </span>            :     }
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :   /* Write out the global symbols.  */
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   flaginfo.failed = FALSE;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   bfd_hash_traverse (&amp;info-&gt;hash-&gt;table, _bfd_coff_write_global_sym, &amp;flaginfo);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   if (flaginfo.failed)</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     goto error_return;</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :   /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   if (flaginfo.outsyms != NULL)</span>
<span class="lineNum">    1061 </span>            :     {
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :       free (flaginfo.outsyms);</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :       flaginfo.outsyms = NULL;</span>
<span class="lineNum">    1064 </span>            :     }
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   if (bfd_link_relocatable (info) &amp;&amp; max_output_reloc_count &gt; 0)</span>
<span class="lineNum">    1067 </span>            :     {
<span class="lineNum">    1068 </span>            :       /* Now that we have written out all the global symbols, we know
<span class="lineNum">    1069 </span>            :          the symbol indices to use for relocs against them, and we can
<span class="lineNum">    1070 </span>            :          finally write out the relocs.  */
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :       amt = max_output_reloc_count * relsz;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :       external_relocs = (bfd_byte *) bfd_malloc (amt);</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :       if (external_relocs == NULL)</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :         goto error_return;</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :       for (o = abfd-&gt;sections; o != NULL; o = o-&gt;next)</span>
<span class="lineNum">    1077 </span>            :         {
<span class="lineNum">    1078 </span>            :           struct internal_reloc *irel;
<span class="lineNum">    1079 </span>            :           struct internal_reloc *irelend;
<span class="lineNum">    1080 </span>            :           struct coff_link_hash_entry **rel_hash;
<span class="lineNum">    1081 </span>            :           bfd_byte *erel;
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :           if (o-&gt;reloc_count == 0)</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :           irel = flaginfo.section_info[o-&gt;target_index].relocs;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :           irelend = irel + o-&gt;reloc_count;</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :           rel_hash = flaginfo.section_info[o-&gt;target_index].rel_hashes;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :           erel = external_relocs;</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :           for (; irel &lt; irelend; irel++, rel_hash++, erel += relsz)</span>
<span class="lineNum">    1091 </span>            :             {
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :               if (*rel_hash != NULL)</span>
<span class="lineNum">    1093 </span>            :                 {
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :                   BFD_ASSERT ((*rel_hash)-&gt;indx &gt;= 0);</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                   irel-&gt;r_symndx = (*rel_hash)-&gt;indx;</span>
<span class="lineNum">    1096 </span>            :                 }
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :               bfd_coff_swap_reloc_out (abfd, irel, erel);</span>
<span class="lineNum">    1098 </span>            :             }
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :           if (bfd_seek (abfd, o-&gt;rel_filepos, SEEK_SET) != 0)</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :             goto error_return;</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :           if (obj_pe (abfd) &amp;&amp; o-&gt;reloc_count &gt;= 0xffff)</span>
<span class="lineNum">    1103 </span>            :             {
<span class="lineNum">    1104 </span>            :               /* In PE COFF, write the count of relocs as the first
<span class="lineNum">    1105 </span>            :                  reloc.  The header overflow bit will be set
<span class="lineNum">    1106 </span>            :                  elsewhere. */
<span class="lineNum">    1107 </span>            :               struct internal_reloc incount;
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :               bfd_byte *excount = (bfd_byte *)bfd_malloc (relsz);</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :               memset (&amp;incount, 0, sizeof (incount));</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :               incount.r_vaddr = o-&gt;reloc_count + 1;</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :               bfd_coff_swap_reloc_out (abfd, &amp;incount, excount);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :               if (bfd_bwrite (excount, relsz, abfd) != relsz)</span>
<span class="lineNum">    1114 </span>            :                 /* We'll leak, but it's an error anyway. */
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                 goto error_return;</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :               free (excount);</span>
<span class="lineNum">    1117 </span>            :             }
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :           if (bfd_bwrite (external_relocs,</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :                           (bfd_size_type) relsz * o-&gt;reloc_count, abfd)</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :               != (bfd_size_type) relsz * o-&gt;reloc_count)</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :             goto error_return;</span>
<span class="lineNum">    1122 </span>            :         }
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :       free (external_relocs);</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :       external_relocs = NULL;</span>
<span class="lineNum">    1126 </span>            :     }
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :   /* Free up the section information.  */
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   if (flaginfo.section_info != NULL)</span>
<span class="lineNum">    1130 </span>            :     {
<span class="lineNum">    1131 </span>            :       unsigned int i;
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; abfd-&gt;section_count; i++)</span>
<span class="lineNum">    1134 </span>            :         {
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :           if (flaginfo.section_info[i].relocs != NULL)</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :             free (flaginfo.section_info[i].relocs);</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :           if (flaginfo.section_info[i].rel_hashes != NULL)</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :             free (flaginfo.section_info[i].rel_hashes);</span>
<span class="lineNum">    1139 </span>            :         }
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :       free (flaginfo.section_info);</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :       flaginfo.section_info = NULL;</span>
<span class="lineNum">    1142 </span>            :     }
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            :   /* If we have optimized stabs strings, output them.  */
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :   if (coff_hash_table (info)-&gt;stab_info.stabstr != NULL)</span>
<span class="lineNum">    1146 </span>            :     {
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :       if (! _bfd_write_stab_strings (abfd, &amp;coff_hash_table (info)-&gt;stab_info))</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1149 </span>            :     }
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            :   /* Write out the string table.  */
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   if (obj_raw_syment_count (abfd) != 0 || long_section_names)</span>
<span class="lineNum">    1153 </span>            :     {
<span class="lineNum">    1154 </span>            :       file_ptr pos;
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       if (bfd_seek (abfd, pos, SEEK_SET) != 0)</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            : #if STRING_SIZE_SIZE == 4
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :       H_PUT_32 (abfd,</span>
<span class="lineNum">    1162 </span>            :                 _bfd_stringtab_size (flaginfo.strtab) + STRING_SIZE_SIZE,
<span class="lineNum">    1163 </span>            :                 strbuf);
<span class="lineNum">    1164 </span>            : #else
<span class="lineNum">    1165 </span>            :  #error Change H_PUT_32 above
<span class="lineNum">    1166 </span>            : #endif
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :       if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)</span>
<span class="lineNum">    1169 </span>            :           != STRING_SIZE_SIZE)
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :       if (! _bfd_stringtab_emit (abfd, flaginfo.strtab))</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :       obj_coff_strings_written (abfd) = TRUE;</span>
<span class="lineNum">    1176 </span>            :     }
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   _bfd_stringtab_free (flaginfo.strtab);</span>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :   /* Setting bfd_get_symcount to 0 will cause write_object_contents to
<span class="lineNum">    1181 </span>            :      not try to write out the symbols.  */
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :   bfd_get_symcount (abfd) = 0;</span>
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :  error_return:</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :   if (debug_merge_allocated)</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :     coff_debug_merge_hash_table_free (&amp;flaginfo.debug_merge);</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :   if (flaginfo.strtab != NULL)</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     _bfd_stringtab_free (flaginfo.strtab);</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   if (flaginfo.section_info != NULL)</span>
<span class="lineNum">    1192 </span>            :     {
<span class="lineNum">    1193 </span>            :       unsigned int i;
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; abfd-&gt;section_count; i++)</span>
<span class="lineNum">    1196 </span>            :         {
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :           if (flaginfo.section_info[i].relocs != NULL)</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :             free (flaginfo.section_info[i].relocs);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :           if (flaginfo.section_info[i].rel_hashes != NULL)</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :             free (flaginfo.section_info[i].rel_hashes);</span>
<span class="lineNum">    1201 </span>            :         }
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :       free (flaginfo.section_info);</span>
<span class="lineNum">    1203 </span>            :     }
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   if (flaginfo.internal_syms != NULL)</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :     free (flaginfo.internal_syms);</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :   if (flaginfo.sec_ptrs != NULL)</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :     free (flaginfo.sec_ptrs);</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   if (flaginfo.sym_indices != NULL)</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     free (flaginfo.sym_indices);</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :   if (flaginfo.outsyms != NULL)</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :     free (flaginfo.outsyms);</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   if (flaginfo.linenos != NULL)</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     free (flaginfo.linenos);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   if (flaginfo.contents != NULL)</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     free (flaginfo.contents);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :   if (flaginfo.external_relocs != NULL)</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :     free (flaginfo.external_relocs);</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :   if (flaginfo.internal_relocs != NULL)</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     free (flaginfo.internal_relocs);</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :   if (external_relocs != NULL)</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     free (external_relocs);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   return FALSE;</span>
<span class="lineNum">    1223 </span>            : }
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span>            : /* Parse out a -heap &lt;reserved&gt;,&lt;commit&gt; line.  */
<a name="1226"><span class="lineNum">    1226 </span>            : </a>
<span class="lineNum">    1227 </span>            : static char *
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 : dores_com (char *ptr, bfd *output_bfd, int heap)</span>
<span class="lineNum">    1229 </span>            : {
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :   if (coff_data(output_bfd)-&gt;pe)</span>
<span class="lineNum">    1231 </span>            :     {
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       int val = strtoul (ptr, &amp;ptr, 0);</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :       if (heap)</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :         pe_data(output_bfd)-&gt;pe_opthdr.SizeOfHeapReserve = val;</span>
<span class="lineNum">    1236 </span>            :       else
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :         pe_data(output_bfd)-&gt;pe_opthdr.SizeOfStackReserve = val;</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :       if (ptr[0] == ',')</span>
<span class="lineNum">    1240 </span>            :         {
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :           val = strtoul (ptr+1, &amp;ptr, 0);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :           if (heap)</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :             pe_data(output_bfd)-&gt;pe_opthdr.SizeOfHeapCommit = val;</span>
<span class="lineNum">    1244 </span>            :           else
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :             pe_data(output_bfd)-&gt;pe_opthdr.SizeOfStackCommit = val;</span>
<span class="lineNum">    1246 </span>            :         }
<span class="lineNum">    1247 </span>            :     }
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :   return ptr;</span>
<span class="lineNum">    1249 </span>            : }
<a name="1250"><span class="lineNum">    1250 </span>            : </a>
<span class="lineNum">    1251 </span>            : static char *
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 : get_name (char *ptr, char **dst)</span>
<span class="lineNum">    1253 </span>            : {
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   while (*ptr == ' ')</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :     ptr++;</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :   *dst = ptr;</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :   while (*ptr &amp;&amp; *ptr != ' ')</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     ptr++;</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   *ptr = 0;</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :   return ptr+1;</span>
<span class="lineNum">    1261 </span>            : }
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            : /* Process any magic embedded commands in a section called .drectve.  */
<a name="1264"><span class="lineNum">    1264 </span>            : </a>
<span class="lineNum">    1265 </span>            : static int
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 : process_embedded_commands (bfd *output_bfd,</span>
<span class="lineNum">    1267 </span>            :                            struct bfd_link_info *info ATTRIBUTE_UNUSED,
<span class="lineNum">    1268 </span>            :                            bfd *abfd)
<span class="lineNum">    1269 </span>            : {
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   asection *sec = bfd_get_section_by_name (abfd, &quot;.drectve&quot;);</span>
<span class="lineNum">    1271 </span>            :   char *s;
<span class="lineNum">    1272 </span>            :   char *e;
<span class="lineNum">    1273 </span>            :   bfd_byte *copy;
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :   if (!sec)</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   if (!bfd_malloc_and_get_section (abfd, sec, &amp;copy))</span>
<span class="lineNum">    1279 </span>            :     {
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :       if (copy != NULL)</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :         free (copy);</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    1283 </span>            :     }
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :   e = (char *) copy + sec-&gt;size;</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :   for (s = (char *) copy; s &lt; e ; )</span>
<span class="lineNum">    1287 </span>            :     {
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :       if (s[0] != '-')</span>
<span class="lineNum">    1289 </span>            :         {
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :           s++;</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    1292 </span>            :         }
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :       if (CONST_STRNEQ (s, &quot;-attr&quot;))</span>
<span class="lineNum">    1294 </span>            :         {
<span class="lineNum">    1295 </span>            :           char *name;
<span class="lineNum">    1296 </span>            :           char *attribs;
<span class="lineNum">    1297 </span>            :           asection *asec;
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :           int loop = 1;</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :           int had_write = 0;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :           int had_exec= 0;</span>
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :           s += 5;</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :           s = get_name (s, &amp;name);</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :           s = get_name (s, &amp;attribs);</span>
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :           while (loop)</span>
<span class="lineNum">    1307 </span>            :             {
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :               switch (*attribs++)</span>
<span class="lineNum">    1309 </span>            :                 {
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :                 case 'W':</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :                   had_write = 1;</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :                 case 'R':</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :                 case 'S':</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :                 case 'X':</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :                   had_exec = 1;</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :                 default:</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :                   loop = 0;</span>
<span class="lineNum">    1322 </span>            :                 }
<span class="lineNum">    1323 </span>            :             }
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :           asec = bfd_get_section_by_name (abfd, name);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :           if (asec)</span>
<span class="lineNum">    1326 </span>            :             {
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :               if (had_exec)</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :                 asec-&gt;flags |= SEC_CODE;</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :               if (!had_write)</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                 asec-&gt;flags |= SEC_READONLY;</span>
<span class="lineNum">    1331 </span>            :             }
<span class="lineNum">    1332 </span>            :         }
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :       else if (CONST_STRNEQ (s, &quot;-heap&quot;))</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :         s = dores_com (s + 5, output_bfd, 1);</span>
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :       else if (CONST_STRNEQ (s, &quot;-stack&quot;))</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :         s = dores_com (s + 6, output_bfd, 0);</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            :       /* GNU extension for aligned commons.  */
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :       else if (CONST_STRNEQ (s, &quot;-aligncomm:&quot;))</span>
<span class="lineNum">    1341 </span>            :         {
<span class="lineNum">    1342 </span>            :           /* Common symbols must be aligned on reading, as it
<span class="lineNum">    1343 </span>            :           is too late to do anything here, after they have
<span class="lineNum">    1344 </span>            :           already been allocated, so just skip the directive.  */
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :           s += 11;</span>
<span class="lineNum">    1346 </span>            :         }
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            :       else
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :         s++;</span>
<span class="lineNum">    1350 </span>            :     }
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :   free (copy);</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1353 </span>            : }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            : /* Place a marker against all symbols which are used by relocations.
<span class="lineNum">    1356 </span>            :    This marker can be picked up by the 'do we skip this symbol ?'
<span class="lineNum">    1357 </span>            :    loop in _bfd_coff_link_input_bfd() and used to prevent skipping
<span class="lineNum">    1358 </span>            :    that symbol.  */
<a name="1359"><span class="lineNum">    1359 </span>            : </a>
<span class="lineNum">    1360 </span>            : static void
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 : mark_relocs (struct coff_final_link_info *flaginfo, bfd *input_bfd)</span>
<span class="lineNum">    1362 </span>            : {
<span class="lineNum">    1363 </span>            :   asection * a;
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :   if ((bfd_get_file_flags (input_bfd) &amp; HAS_SYMS) == 0)</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :   for (a = input_bfd-&gt;sections; a != (asection *) NULL; a = a-&gt;next)</span>
<span class="lineNum">    1369 </span>            :     {
<span class="lineNum">    1370 </span>            :       struct internal_reloc *   internal_relocs;
<span class="lineNum">    1371 </span>            :       struct internal_reloc *   irel;
<span class="lineNum">    1372 </span>            :       struct internal_reloc *   irelend;
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :       if ((a-&gt;flags &amp; SEC_RELOC) == 0 || a-&gt;reloc_count  &lt; 1</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :           || a-&gt;linker_mark == 0)</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1377 </span>            :       /* Don't mark relocs in excluded sections.  */
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :       if (a-&gt;output_section == bfd_abs_section_ptr)</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            :       /* Read in the relocs.  */
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :       internal_relocs = _bfd_coff_read_internal_relocs</span>
<span class="lineNum">    1383 </span>            :         (input_bfd, a, FALSE,
<span class="lineNum">    1384 </span>            :          flaginfo-&gt;external_relocs,
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :          bfd_link_relocatable (flaginfo-&gt;info),</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :          (bfd_link_relocatable (flaginfo-&gt;info)</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :           ? (flaginfo-&gt;section_info[ a-&gt;output_section-&gt;target_index ].relocs + a-&gt;output_section-&gt;reloc_count)</span>
<span class="lineNum">    1388 </span>            :           : flaginfo-&gt;internal_relocs)
<span class="lineNum">    1389 </span>            :         );
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :       if (internal_relocs == NULL)</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :       irel     = internal_relocs;</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :       irelend  = irel + a-&gt;reloc_count;</span>
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            :       /* Place a mark in the sym_indices array (whose entries have
<span class="lineNum">    1398 </span>            :          been initialised to 0) for all of the symbols that are used
<span class="lineNum">    1399 </span>            :          in the relocation table.  This will then be picked up in the
<span class="lineNum">    1400 </span>            :          skip/don't-skip pass.  */
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :       for (; irel &lt; irelend; irel++)</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :         if ((unsigned long) irel-&gt;r_symndx &lt; obj_raw_syment_count (input_bfd))</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :           flaginfo-&gt;sym_indices[irel-&gt;r_symndx] = -1;</span>
<span class="lineNum">    1404 </span>            :     }
<span class="lineNum">    1405 </span>            : }
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            : /* Link an input file into the linker output file.  This function
<span class="lineNum">    1408 </span>            :    handles all the sections and relocations of the input file at once.  */
<a name="1409"><span class="lineNum">    1409 </span>            : </a>
<span class="lineNum">    1410 </span>            : bfd_boolean
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 : _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)</span>
<span class="lineNum">    1412 </span>            : {
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :   unsigned int n_tmask = coff_data (input_bfd)-&gt;local_n_tmask;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :   unsigned int n_btshft = coff_data (input_bfd)-&gt;local_n_btshft;</span>
<span class="lineNum">    1415 </span>            :   bfd_boolean (*adjust_symndx)
<span class="lineNum">    1416 </span>            :     (bfd *, struct bfd_link_info *, bfd *, asection *,
<span class="lineNum">    1417 </span>            :      struct internal_reloc *, bfd_boolean *);
<span class="lineNum">    1418 </span>            :   bfd *output_bfd;
<span class="lineNum">    1419 </span>            :   const char *strings;
<span class="lineNum">    1420 </span>            :   bfd_size_type syment_base;
<span class="lineNum">    1421 </span>            :   bfd_boolean copy, hash;
<span class="lineNum">    1422 </span>            :   bfd_size_type isymesz;
<span class="lineNum">    1423 </span>            :   bfd_size_type osymesz;
<span class="lineNum">    1424 </span>            :   bfd_size_type linesz;
<span class="lineNum">    1425 </span>            :   bfd_byte *esym;
<span class="lineNum">    1426 </span>            :   bfd_byte *esym_end;
<span class="lineNum">    1427 </span>            :   struct internal_syment *isymp;
<span class="lineNum">    1428 </span>            :   asection **secpp;
<span class="lineNum">    1429 </span>            :   long *indexp;
<span class="lineNum">    1430 </span>            :   unsigned long output_index;
<span class="lineNum">    1431 </span>            :   bfd_byte *outsym;
<span class="lineNum">    1432 </span>            :   struct coff_link_hash_entry **sym_hash;
<span class="lineNum">    1433 </span>            :   asection *o;
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            :   /* Move all the symbols to the output file.  */
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :   output_bfd = flaginfo-&gt;output_bfd;</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :   strings = NULL;</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   syment_base = obj_raw_syment_count (output_bfd);</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :   isymesz = bfd_coff_symesz (input_bfd);</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :   osymesz = bfd_coff_symesz (output_bfd);</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   linesz = bfd_coff_linesz (input_bfd);</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   copy = FALSE;</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :   if (! flaginfo-&gt;info-&gt;keep_memory)</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :     copy = TRUE;</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :   hash = TRUE;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :   if (flaginfo-&gt;info-&gt;traditional_format)</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :     hash = FALSE;</span>
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :   if (! _bfd_coff_get_external_symbols (input_bfd))</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :   esym = (bfd_byte *) obj_coff_external_syms (input_bfd);</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :   esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :   isymp = flaginfo-&gt;internal_syms;</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :   secpp = flaginfo-&gt;sec_ptrs;</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :   indexp = flaginfo-&gt;sym_indices;</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   output_index = syment_base;</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :   outsym = flaginfo-&gt;outsyms;</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   if (coff_data (output_bfd)-&gt;pe</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :       &amp;&amp; ! process_embedded_commands (output_bfd, flaginfo-&gt;info, input_bfd))</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span>            :   /* If we are going to perform relocations and also strip/discard some
<span class="lineNum">    1468 </span>            :      symbols then we must make sure that we do not strip/discard those
<span class="lineNum">    1469 </span>            :      symbols that are going to be involved in the relocations.  */
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :   if ((   flaginfo-&gt;info-&gt;strip   != strip_none</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :        || flaginfo-&gt;info-&gt;discard != discard_none)</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :       &amp;&amp; bfd_link_relocatable (flaginfo-&gt;info))</span>
<span class="lineNum">    1473 </span>            :     {
<span class="lineNum">    1474 </span>            :       /* Mark the symbol array as 'not-used'.  */
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :       memset (indexp, 0, obj_raw_syment_count (input_bfd) * sizeof * indexp);</span>
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :       mark_relocs (flaginfo, input_bfd);</span>
<span class="lineNum">    1478 </span>            :     }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :   while (esym &lt; esym_end)</span>
<span class="lineNum">    1481 </span>            :     {
<span class="lineNum">    1482 </span>            :       struct internal_syment isym;
<span class="lineNum">    1483 </span>            :       enum coff_symbol_classification classification;
<span class="lineNum">    1484 </span>            :       bfd_boolean skip;
<span class="lineNum">    1485 </span>            :       bfd_boolean global;
<span class="lineNum">    1486 </span>            :       bfd_boolean dont_skip_symbol;
<span class="lineNum">    1487 </span>            :       int add;
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :       bfd_coff_swap_sym_in (input_bfd, esym, isymp);</span>
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span>            :       /* Make a copy of *isymp so that the relocate_section function
<span class="lineNum">    1492 </span>            :          always sees the original values.  This is more reliable than
<span class="lineNum">    1493 </span>            :          always recomputing the symbol value even if we are stripping
<span class="lineNum">    1494 </span>            :          the symbol.  */
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :       isym = *isymp;</span>
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :       classification = bfd_coff_classify_symbol (input_bfd, &amp;isym);</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :       switch (classification)</span>
<span class="lineNum">    1499 </span>            :         {
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :           abort ();</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :         case COFF_SYMBOL_GLOBAL:</span>
<span class="lineNum">    1503 </span>            :         case COFF_SYMBOL_PE_SECTION:
<span class="lineNum">    1504 </span>            :         case COFF_SYMBOL_LOCAL:
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :           *secpp = coff_section_from_bfd_index (input_bfd, isym.n_scnum);</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :         case COFF_SYMBOL_COMMON:</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :           *secpp = bfd_com_section_ptr;</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :         case COFF_SYMBOL_UNDEFINED:</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :           *secpp = bfd_und_section_ptr;</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1513 </span>            :         }
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            :       /* Extract the flag indicating if this symbol is used by a
<span class="lineNum">    1516 </span>            :          relocation.  */
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :       if ((flaginfo-&gt;info-&gt;strip != strip_none</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :            || flaginfo-&gt;info-&gt;discard != discard_none)</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :           &amp;&amp; bfd_link_relocatable (flaginfo-&gt;info))</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :         dont_skip_symbol = *indexp;</span>
<span class="lineNum">    1521 </span>            :       else
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :         dont_skip_symbol = FALSE;</span>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :       *indexp = -1;</span>
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :       skip = FALSE;</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :       global = FALSE;</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :       add = 1 + isym.n_numaux;</span>
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            :       /* If we are stripping all symbols, we want to skip this one.  */
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :       if (flaginfo-&gt;info-&gt;strip == strip_all &amp;&amp; ! dont_skip_symbol)</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :         skip = TRUE;</span>
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :       if (! skip)</span>
<span class="lineNum">    1535 </span>            :         {
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :           switch (classification)</span>
<span class="lineNum">    1537 </span>            :             {
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :               abort ();</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :             case COFF_SYMBOL_GLOBAL:</span>
<span class="lineNum">    1541 </span>            :             case COFF_SYMBOL_COMMON:
<span class="lineNum">    1542 </span>            :             case COFF_SYMBOL_PE_SECTION:
<span class="lineNum">    1543 </span>            :               /* This is a global symbol.  Global symbols come at the
<span class="lineNum">    1544 </span>            :                  end of the symbol table, so skip them for now.
<span class="lineNum">    1545 </span>            :                  Locally defined function symbols, however, are an
<span class="lineNum">    1546 </span>            :                  exception, and are not moved to the end.  */
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :               global = TRUE;</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :               if (! ISFCN (isym.n_type))</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :                 skip = TRUE;</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :             case COFF_SYMBOL_UNDEFINED:</span>
<span class="lineNum">    1553 </span>            :               /* Undefined symbols are left for the end.  */
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :               global = TRUE;</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :               skip = TRUE;</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :             case COFF_SYMBOL_LOCAL:</span>
<span class="lineNum">    1559 </span>            :               /* This is a local symbol.  Skip it if we are discarding
<span class="lineNum">    1560 </span>            :                  local symbols.  */
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :               if (flaginfo-&gt;info-&gt;discard == discard_all &amp;&amp; ! dont_skip_symbol)</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :                 skip = TRUE;</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1564 </span>            :             }
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span>            : #ifndef COFF_WITH_PE
<span class="lineNum">    1568 </span>            :       /* Skip section symbols for sections which are not going to be
<span class="lineNum">    1569 </span>            :          emitted.  */
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :       if (!skip</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :           &amp;&amp; !dont_skip_symbol</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :           &amp;&amp; isym.n_sclass == C_STAT</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :           &amp;&amp; isym.n_type == T_NULL</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :           &amp;&amp; isym.n_numaux &gt; 0</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :           &amp;&amp; ((*secpp)-&gt;output_section == bfd_abs_section_ptr</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :               || bfd_section_removed_from_list (output_bfd,</span>
<span class="lineNum">    1577 </span>            :                                                 (*secpp)-&gt;output_section)))
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :         skip = TRUE;</span>
<span class="lineNum">    1579 </span>            : #endif
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span>            :       /* If we stripping debugging symbols, and this is a debugging
<span class="lineNum">    1582 </span>            :          symbol, then skip it.  FIXME: gas sets the section to N_ABS
<span class="lineNum">    1583 </span>            :          for some types of debugging symbols; I don't know if this is
<span class="lineNum">    1584 </span>            :          a bug or not.  In any case, we handle it here.  */
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :       if (! skip</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :           &amp;&amp; flaginfo-&gt;info-&gt;strip == strip_debugger</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :           &amp;&amp; ! dont_skip_symbol</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :           &amp;&amp; (isym.n_scnum == N_DEBUG</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :               || (isym.n_scnum == N_ABS</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :                   &amp;&amp; (isym.n_sclass == C_AUTO</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_REG</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_MOS</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_MOE</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_MOU</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_ARG</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_REGPARM</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_FIELD</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :                       || isym.n_sclass == C_EOS))))</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :         skip = TRUE;</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            :       /* If some symbols are stripped based on the name, work out the
<span class="lineNum">    1602 </span>            :          name and decide whether to skip this symbol.  */
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :       if (! skip</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :           &amp;&amp; (flaginfo-&gt;info-&gt;strip == strip_some</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :               || flaginfo-&gt;info-&gt;discard == discard_l))</span>
<span class="lineNum">    1606 </span>            :         {
<span class="lineNum">    1607 </span>            :           const char *name;
<span class="lineNum">    1608 </span>            :           char buf[SYMNMLEN + 1];
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :           name = _bfd_coff_internal_syment_name (input_bfd, &amp;isym, buf);</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :           if (name == NULL)</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :           if (! dont_skip_symbol</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :               &amp;&amp; ((flaginfo-&gt;info-&gt;strip == strip_some</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :                    &amp;&amp; (bfd_hash_lookup (flaginfo-&gt;info-&gt;keep_hash, name, FALSE,</span>
<span class="lineNum">    1617 </span>            :                                     FALSE) == NULL))
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :                    || (! global</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                        &amp;&amp; flaginfo-&gt;info-&gt;discard == discard_l</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :                        &amp;&amp; bfd_is_local_label_name (input_bfd, name))))</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :             skip = TRUE;</span>
<span class="lineNum">    1622 </span>            :         }
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            :       /* If this is an enum, struct, or union tag, see if we have
<span class="lineNum">    1625 </span>            :          already output an identical type.  */
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :       if (! skip</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :           &amp;&amp; !flaginfo-&gt;info-&gt;traditional_format</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :           &amp;&amp; (isym.n_sclass == C_ENTAG</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :               || isym.n_sclass == C_STRTAG</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :               || isym.n_sclass == C_UNTAG)</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :           &amp;&amp; isym.n_numaux == 1)</span>
<span class="lineNum">    1632 </span>            :         {
<span class="lineNum">    1633 </span>            :           const char *name;
<span class="lineNum">    1634 </span>            :           char buf[SYMNMLEN + 1];
<span class="lineNum">    1635 </span>            :           struct coff_debug_merge_hash_entry *mh;
<span class="lineNum">    1636 </span>            :           struct coff_debug_merge_type *mt;
<span class="lineNum">    1637 </span>            :           union internal_auxent aux;
<span class="lineNum">    1638 </span>            :           struct coff_debug_merge_element **epp;
<span class="lineNum">    1639 </span>            :           bfd_byte *esl, *eslend;
<span class="lineNum">    1640 </span>            :           struct internal_syment *islp;
<span class="lineNum">    1641 </span>            :           bfd_size_type amt;
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :           name = _bfd_coff_internal_syment_name (input_bfd, &amp;isym, buf);</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :           if (name == NULL)</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span>            :           /* Ignore fake names invented by compiler; treat them all as
<span class="lineNum">    1648 </span>            :              the same name.  */
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :           if (*name == '~' || *name == '.' || *name == '$'</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :               || (*name == bfd_get_symbol_leading_char (input_bfd)</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :                   &amp;&amp; (name[1] == '~' || name[1] == '.' || name[1] == '$')))</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :             name = &quot;&quot;;</span>
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :           mh = coff_debug_merge_hash_lookup (&amp;flaginfo-&gt;debug_merge, name,</span>
<span class="lineNum">    1655 </span>            :                                              TRUE, TRUE);
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :           if (mh == NULL)</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :           /* Allocate memory to hold type information.  If this turns
<span class="lineNum">    1660 </span>            :              out to be a duplicate, we pass this address to
<span class="lineNum">    1661 </span>            :              bfd_release.  */
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :           amt = sizeof (struct coff_debug_merge_type);</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :           mt = (struct coff_debug_merge_type *) bfd_alloc (input_bfd, amt);</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :           if (mt == NULL)</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :           mt-&gt;type_class = isym.n_sclass;</span>
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            :           /* Pick up the aux entry, which points to the end of the tag
<span class="lineNum">    1669 </span>            :              entries.  */
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :           bfd_coff_swap_aux_in (input_bfd, (esym + isymesz),</span>
<span class="lineNum">    1671 </span>            :                                 isym.n_type, isym.n_sclass, 0, isym.n_numaux,
<span class="lineNum">    1672 </span>            :                                 &amp;aux);
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            :           /* Gather the elements.  */
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :           epp = &amp;mt-&gt;elements;</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :           mt-&gt;elements = NULL;</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :           islp = isymp + 2;</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :           esl = esym + 2 * isymesz;</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :           eslend = ((bfd_byte *) obj_coff_external_syms (input_bfd)</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :                     + aux.x_sym.x_fcnary.x_fcn.x_endndx.l * isymesz);</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :           while (esl &lt; eslend)</span>
<span class="lineNum">    1682 </span>            :             {
<span class="lineNum">    1683 </span>            :               const char *elename;
<span class="lineNum">    1684 </span>            :               char elebuf[SYMNMLEN + 1];
<span class="lineNum">    1685 </span>            :               char *name_copy;
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :               bfd_coff_swap_sym_in (input_bfd, esl, islp);</span>
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :               amt = sizeof (struct coff_debug_merge_element);</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :               *epp = (struct coff_debug_merge_element *)</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :                   bfd_alloc (input_bfd, amt);</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :               if (*epp == NULL)</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :               elename = _bfd_coff_internal_syment_name (input_bfd, islp,</span>
<span class="lineNum">    1696 </span>            :                                                         elebuf);
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :               if (elename == NULL)</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :               amt = strlen (elename) + 1;</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :               name_copy = (char *) bfd_alloc (input_bfd, amt);</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :               if (name_copy == NULL)</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :               strcpy (name_copy, elename);</span>
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :               (*epp)-&gt;name = name_copy;</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :               (*epp)-&gt;type = islp-&gt;n_type;</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :               (*epp)-&gt;tagndx = 0;</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :               if (islp-&gt;n_numaux &gt;= 1</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :                   &amp;&amp; islp-&gt;n_type != T_NULL</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :                   &amp;&amp; islp-&gt;n_sclass != C_EOS)</span>
<span class="lineNum">    1712 </span>            :                 {
<span class="lineNum">    1713 </span>            :                   union internal_auxent eleaux;
<span class="lineNum">    1714 </span>            :                   long indx;
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :                   bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),</span>
<span class="lineNum">    1717 </span>            :                                         islp-&gt;n_type, islp-&gt;n_sclass, 0,
<span class="lineNum">    1718 </span>            :                                         islp-&gt;n_numaux, &amp;eleaux);
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :                   indx = eleaux.x_sym.x_tagndx.l;</span>
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :                   /* FIXME: If this tagndx entry refers to a symbol
<span class="lineNum">    1722 </span>            :                      defined later in this file, we just ignore it.
<span class="lineNum">    1723 </span>            :                      Handling this correctly would be tedious, and may
<span class="lineNum">    1724 </span>            :                      not be required.  */
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :                   if (indx &gt; 0</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :                       &amp;&amp; (indx</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :                           &lt; ((esym -</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :                               (bfd_byte *) obj_coff_external_syms (input_bfd))</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :                              / (long) isymesz)))</span>
<span class="lineNum">    1730 </span>            :                     {
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :                       (*epp)-&gt;tagndx = flaginfo-&gt;sym_indices[indx];</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :                       if ((*epp)-&gt;tagndx &lt; 0)</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :                         (*epp)-&gt;tagndx = 0;</span>
<span class="lineNum">    1734 </span>            :                     }
<span class="lineNum">    1735 </span>            :                 }
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :               epp = &amp;(*epp)-&gt;next;</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :               *epp = NULL;</span>
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :               esl += (islp-&gt;n_numaux + 1) * isymesz;</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :               islp += islp-&gt;n_numaux + 1;</span>
<span class="lineNum">    1741 </span>            :             }
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :           /* See if we already have a definition which matches this
<span class="lineNum">    1744 </span>            :              type.  We always output the type if it has no elements,
<span class="lineNum">    1745 </span>            :              for simplicity.  */
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :           if (mt-&gt;elements == NULL)</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :             bfd_release (input_bfd, mt);</span>
<span class="lineNum">    1748 </span>            :           else
<span class="lineNum">    1749 </span>            :             {
<span class="lineNum">    1750 </span>            :               struct coff_debug_merge_type *mtl;
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :               for (mtl = mh-&gt;types; mtl != NULL; mtl = mtl-&gt;next)</span>
<span class="lineNum">    1753 </span>            :                 {
<span class="lineNum">    1754 </span>            :                   struct coff_debug_merge_element *me, *mel;
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :                   if (mtl-&gt;type_class != mt-&gt;type_class)</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :                   for (me = mt-&gt;elements, mel = mtl-&gt;elements;</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :                        me != NULL &amp;&amp; mel != NULL;</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :                        me = me-&gt;next, mel = mel-&gt;next)</span>
<span class="lineNum">    1762 </span>            :                     {
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :                       if (strcmp (me-&gt;name, mel-&gt;name) != 0</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :                           || me-&gt;type != mel-&gt;type</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :                           || me-&gt;tagndx != mel-&gt;tagndx)</span>
<span class="lineNum">    1766 </span>            :                         break;
<span class="lineNum">    1767 </span>            :                     }
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :                   if (me == NULL &amp;&amp; mel == NULL)</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1771 </span>            :                 }
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :               if (mtl == NULL || (bfd_size_type) mtl-&gt;indx &gt;= syment_base)</span>
<span class="lineNum">    1774 </span>            :                 {
<span class="lineNum">    1775 </span>            :                   /* This is the first definition of this type.  */
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :                   mt-&gt;indx = output_index;</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :                   mt-&gt;next = mh-&gt;types;</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :                   mh-&gt;types = mt;</span>
<span class="lineNum">    1779 </span>            :                 }
<span class="lineNum">    1780 </span>            :               else
<span class="lineNum">    1781 </span>            :                 {
<span class="lineNum">    1782 </span>            :                   /* This is a redefinition which can be merged.  */
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :                   bfd_release (input_bfd, mt);</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :                   *indexp = mtl-&gt;indx;</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :                   add = (eslend - esym) / isymesz;</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :                   skip = TRUE;</span>
<span class="lineNum">    1787 </span>            :                 }
<span class="lineNum">    1788 </span>            :             }
<span class="lineNum">    1789 </span>            :         }
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span>            :       /* We now know whether we are to skip this symbol or not.  */
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :       if (! skip)</span>
<span class="lineNum">    1793 </span>            :         {
<span class="lineNum">    1794 </span>            :           /* Adjust the symbol in order to output it.  */
<span class="lineNum">    1795 </span>            : 
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :           if (isym._n._n_n._n_zeroes == 0</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :               &amp;&amp; isym._n._n_n._n_offset != 0)</span>
<span class="lineNum">    1798 </span>            :             {
<span class="lineNum">    1799 </span>            :               const char *name;
<span class="lineNum">    1800 </span>            :               bfd_size_type indx;
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span>            :               /* This symbol has a long name.  Enter it in the string
<span class="lineNum">    1803 </span>            :                  table we are building.  Note that we do not check
<span class="lineNum">    1804 </span>            :                  bfd_coff_symname_in_debug.  That is only true for
<span class="lineNum">    1805 </span>            :                  XCOFF, and XCOFF requires different linking code
<span class="lineNum">    1806 </span>            :                  anyhow.  */
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :               name = _bfd_coff_internal_syment_name (input_bfd, &amp;isym, NULL);</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :               if (name == NULL)</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :               indx = _bfd_stringtab_add (flaginfo-&gt;strtab, name, hash, copy);</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :               if (indx == (bfd_size_type) -1)</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :               isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;</span>
<span class="lineNum">    1814 </span>            :             }
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :           switch (isym.n_sclass)</span>
<span class="lineNum">    1817 </span>            :             {
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :             case C_AUTO:</span>
<span class="lineNum">    1819 </span>            :             case C_MOS:
<span class="lineNum">    1820 </span>            :             case C_EOS:
<span class="lineNum">    1821 </span>            :             case C_MOE:
<span class="lineNum">    1822 </span>            :             case C_MOU:
<span class="lineNum">    1823 </span>            :             case C_UNTAG:
<span class="lineNum">    1824 </span>            :             case C_STRTAG:
<span class="lineNum">    1825 </span>            :             case C_ENTAG:
<span class="lineNum">    1826 </span>            :             case C_TPDEF:
<span class="lineNum">    1827 </span>            :             case C_ARG:
<span class="lineNum">    1828 </span>            :             case C_USTATIC:
<span class="lineNum">    1829 </span>            :             case C_REG:
<span class="lineNum">    1830 </span>            :             case C_REGPARM:
<span class="lineNum">    1831 </span>            :             case C_FIELD:
<span class="lineNum">    1832 </span>            :               /* The symbol value should not be modified.  */
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :             case C_FCN:</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :               if (obj_pe (input_bfd)</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :                   &amp;&amp; strcmp (isym.n_name, &quot;.bf&quot;) != 0</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :                   &amp;&amp; isym.n_scnum &gt; 0)</span>
<span class="lineNum">    1839 </span>            :                 {
<span class="lineNum">    1840 </span>            :                   /* For PE, .lf and .ef get their value left alone,
<span class="lineNum">    1841 </span>            :                      while .bf gets relocated.  However, they all have
<span class="lineNum">    1842 </span>            :                      &quot;real&quot; section numbers, and need to be moved into
<span class="lineNum">    1843 </span>            :                      the new section.  */
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :                   isym.n_scnum = (*secpp)-&gt;output_section-&gt;target_index;</span>
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">    1846 </span>            :                 }
<span class="lineNum">    1847 </span>            :               /* Fall through.  */
<span class="lineNum">    1848 </span>            :             default:
<span class="lineNum">    1849 </span>            :             case C_LABEL:  /* Not completely sure about these 2 */
<span class="lineNum">    1850 </span>            :             case C_EXTDEF:
<span class="lineNum">    1851 </span>            :             case C_BLOCK:
<span class="lineNum">    1852 </span>            :             case C_EFCN:
<span class="lineNum">    1853 </span>            :             case C_NULL:
<span class="lineNum">    1854 </span>            :             case C_EXT:
<span class="lineNum">    1855 </span>            :             case C_STAT:
<span class="lineNum">    1856 </span>            :             case C_SECTION:
<span class="lineNum">    1857 </span>            :             case C_NT_WEAK:
<span class="lineNum">    1858 </span>            :               /* Compute new symbol location.  */
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :             if (isym.n_scnum &gt; 0)</span>
<span class="lineNum">    1860 </span>            :               {
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :                 isym.n_scnum = (*secpp)-&gt;output_section-&gt;target_index;</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :                 isym.n_value += (*secpp)-&gt;output_offset;</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :                 if (! obj_pe (input_bfd))</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :                   isym.n_value -= (*secpp)-&gt;vma;</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :                 if (! obj_pe (flaginfo-&gt;output_bfd))</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :                   isym.n_value += (*secpp)-&gt;output_section-&gt;vma;</span>
<span class="lineNum">    1867 </span>            :               }
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1869 </span>            : 
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :             case C_FILE:</span>
<span class="lineNum">    1871 </span>            :               /* The value of a C_FILE symbol is the symbol index of
<span class="lineNum">    1872 </span>            :                  the next C_FILE symbol.  The value of the last C_FILE
<span class="lineNum">    1873 </span>            :                  symbol is the symbol index to the first external
<span class="lineNum">    1874 </span>            :                  symbol (actually, coff_renumber_symbols does not get
<span class="lineNum">    1875 </span>            :                  this right--it just sets the value of the last C_FILE
<span class="lineNum">    1876 </span>            :                  symbol to zero--and nobody has ever complained about
<span class="lineNum">    1877 </span>            :                  it).  We try to get this right, below, just before we
<span class="lineNum">    1878 </span>            :                  write the symbols out, but in the general case we may
<span class="lineNum">    1879 </span>            :                  have to write the symbol out twice.  */
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :               if (flaginfo-&gt;last_file_index != -1</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :                   &amp;&amp; flaginfo-&gt;last_file.n_value != (bfd_vma) output_index)</span>
<span class="lineNum">    1882 </span>            :                 {
<span class="lineNum">    1883 </span>            :                   /* We must correct the value of the last C_FILE
<span class="lineNum">    1884 </span>            :                      entry.  */
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :                   flaginfo-&gt;last_file.n_value = output_index;</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :                   if ((bfd_size_type) flaginfo-&gt;last_file_index &gt;= syment_base)</span>
<span class="lineNum">    1887 </span>            :                     {
<span class="lineNum">    1888 </span>            :                       /* The last C_FILE symbol is in this input file.  */
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :                       bfd_coff_swap_sym_out (output_bfd,</span>
<span class="lineNum">    1890 </span>            :                                              &amp;flaginfo-&gt;last_file,
<span class="lineNum">    1891 </span>            :                                              (flaginfo-&gt;outsyms
<span class="lineNum">    1892 </span>            :                                               + ((flaginfo-&gt;last_file_index
<span class="lineNum">    1893 </span>            :                                                   - syment_base)
<span class="lineNum">    1894 </span>            :                                                  * osymesz)));
<span class="lineNum">    1895 </span>            :                     }
<span class="lineNum">    1896 </span>            :                   else
<span class="lineNum">    1897 </span>            :                     {
<span class="lineNum">    1898 </span>            :                       file_ptr pos;
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span>            :                       /* We have already written out the last C_FILE
<span class="lineNum">    1901 </span>            :                          symbol.  We need to write it out again.  We
<span class="lineNum">    1902 </span>            :                          borrow *outsym temporarily.  */
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :                       bfd_coff_swap_sym_out (output_bfd,</span>
<span class="lineNum">    1904 </span>            :                                              &amp;flaginfo-&gt;last_file, outsym);
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :                       pos = obj_sym_filepos (output_bfd);</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :                       pos += flaginfo-&gt;last_file_index * osymesz;</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :                       if (bfd_seek (output_bfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :                           || bfd_bwrite (outsym, osymesz, output_bfd) != osymesz)</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :                         return FALSE;</span>
<span class="lineNum">    1910 </span>            :                     }
<span class="lineNum">    1911 </span>            :                 }
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :               flaginfo-&gt;last_file_index = output_index;</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :               flaginfo-&gt;last_file = isym;</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1916 </span>            :             }
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span>            :           /* If doing task linking, convert normal global function symbols to
<span class="lineNum">    1919 </span>            :              static functions.  */
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :           if (flaginfo-&gt;info-&gt;task_link &amp;&amp; IS_EXTERNAL (input_bfd, isym))</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :             isym.n_sclass = C_STAT;</span>
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            :           /* Output the symbol.  */
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :           bfd_coff_swap_sym_out (output_bfd, &amp;isym, outsym);</span>
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :           *indexp = output_index;</span>
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :           if (global)</span>
<span class="lineNum">    1929 </span>            :             {
<span class="lineNum">    1930 </span>            :               long indx;
<span class="lineNum">    1931 </span>            :               struct coff_link_hash_entry *h;
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :               indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                       / isymesz);</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :               h = obj_coff_sym_hashes (input_bfd)[indx];</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :               if (h == NULL)</span>
<span class="lineNum">    1937 </span>            :                 {
<span class="lineNum">    1938 </span>            :                   /* This can happen if there were errors earlier in
<span class="lineNum">    1939 </span>            :                      the link.  */
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :                   bfd_set_error (bfd_error_bad_value);</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                   return FALSE;</span>
<span class="lineNum">    1942 </span>            :                 }
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :               h-&gt;indx = output_index;</span>
<span class="lineNum">    1944 </span>            :             }
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :           output_index += add;</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :           outsym += add * osymesz;</span>
<span class="lineNum">    1948 </span>            :         }
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :       esym += add * isymesz;</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :       isymp += add;</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :       ++secpp;</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :       ++indexp;</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :       for (--add; add &gt; 0; --add)</span>
<span class="lineNum">    1955 </span>            :         {
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :           *secpp++ = NULL;</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :           *indexp++ = -1;</span>
<span class="lineNum">    1958 </span>            :         }
<span class="lineNum">    1959 </span>            :     }
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span>            :   /* Fix up the aux entries.  This must be done in a separate pass,
<span class="lineNum">    1962 </span>            :      because we don't know the correct symbol indices until we have
<span class="lineNum">    1963 </span>            :      already decided which symbols we are going to keep.  */
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :   esym = (bfd_byte *) obj_coff_external_syms (input_bfd);</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :   esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :   isymp = flaginfo-&gt;internal_syms;</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :   indexp = flaginfo-&gt;sym_indices;</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :   sym_hash = obj_coff_sym_hashes (input_bfd);</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :   outsym = flaginfo-&gt;outsyms;</span>
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :   while (esym &lt; esym_end)</span>
<span class="lineNum">    1972 </span>            :     {
<span class="lineNum">    1973 </span>            :       int add;
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :       add = 1 + isymp-&gt;n_numaux;</span>
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :       if ((*indexp &lt; 0</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :            || (bfd_size_type) *indexp &lt; syment_base)</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :           &amp;&amp; (*sym_hash == NULL</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :               || (*sym_hash)-&gt;auxbfd != input_bfd))</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :         esym += add * isymesz;</span>
<span class="lineNum">    1982 </span>            :       else
<span class="lineNum">    1983 </span>            :         {
<span class="lineNum">    1984 </span>            :           struct coff_link_hash_entry *h;
<span class="lineNum">    1985 </span>            :           int i;
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :           h = NULL;</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :           if (*indexp &lt; 0)</span>
<span class="lineNum">    1989 </span>            :             {
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :               h = *sym_hash;</span>
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            :               /* The m68k-motorola-sysv assembler will sometimes
<span class="lineNum">    1993 </span>            :                  generate two symbols with the same name, but only one
<span class="lineNum">    1994 </span>            :                  will have aux entries.  */
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :               BFD_ASSERT (isymp-&gt;n_numaux == 0</span>
<span class="lineNum">    1996 </span>            :                           || h-&gt;numaux == 0
<span class="lineNum">    1997 </span>            :                           || h-&gt;numaux == isymp-&gt;n_numaux);
<span class="lineNum">    1998 </span>            :             }
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :           esym += isymesz;</span>
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :           if (h == NULL)</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :             outsym += osymesz;</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span>            :           /* Handle the aux entries.  This handling is based on
<span class="lineNum">    2006 </span>            :              coff_pointerize_aux.  I don't know if it always correct.  */
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :           for (i = 0; i &lt; isymp-&gt;n_numaux &amp;&amp; esym &lt; esym_end; i++)</span>
<span class="lineNum">    2008 </span>            :             {
<span class="lineNum">    2009 </span>            :               union internal_auxent aux;
<span class="lineNum">    2010 </span>            :               union internal_auxent *auxp;
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :               if (h != NULL &amp;&amp; h-&gt;aux != NULL &amp;&amp; (h-&gt;numaux &gt; i))</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :                 auxp = h-&gt;aux + i;</span>
<span class="lineNum">    2014 </span>            :               else
<span class="lineNum">    2015 </span>            :                 {
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :                   bfd_coff_swap_aux_in (input_bfd, esym, isymp-&gt;n_type,</span>
<span class="lineNum">    2017 </span>            :                                         isymp-&gt;n_sclass, i, isymp-&gt;n_numaux, &amp;aux);
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :                   auxp = &amp;aux;</span>
<span class="lineNum">    2019 </span>            :                 }
<span class="lineNum">    2020 </span>            : 
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :               if (isymp-&gt;n_sclass == C_FILE)</span>
<span class="lineNum">    2022 </span>            :                 {
<span class="lineNum">    2023 </span>            :                   /* If this is a long filename, we must put it in the
<span class="lineNum">    2024 </span>            :                      string table.  */
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :                   if (auxp-&gt;x_file.x_n.x_zeroes == 0</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :                       &amp;&amp; auxp-&gt;x_file.x_n.x_offset != 0)</span>
<span class="lineNum">    2027 </span>            :                     {
<span class="lineNum">    2028 </span>            :                       const char *filename;
<span class="lineNum">    2029 </span>            :                       bfd_size_type indx;
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :                       BFD_ASSERT (auxp-&gt;x_file.x_n.x_offset</span>
<span class="lineNum">    2032 </span>            :                                   &gt;= STRING_SIZE_SIZE);
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :                       if (strings == NULL)</span>
<span class="lineNum">    2034 </span>            :                         {
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :                           strings = _bfd_coff_read_string_table (input_bfd);</span>
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :                           if (strings == NULL)</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :                             return FALSE;</span>
<span class="lineNum">    2038 </span>            :                         }
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :                       if ((bfd_size_type) auxp-&gt;x_file.x_n.x_offset &gt;= obj_coff_strings_len (input_bfd))</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :                         filename = _(&quot;&lt;corrupt&gt;&quot;);</span>
<span class="lineNum">    2041 </span>            :                       else
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :                         filename = strings + auxp-&gt;x_file.x_n.x_offset;</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :                       indx = _bfd_stringtab_add (flaginfo-&gt;strtab, filename,</span>
<span class="lineNum">    2044 </span>            :                                                  hash, copy);
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :                       if (indx == (bfd_size_type) -1)</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :                         return FALSE;</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :                       auxp-&gt;x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;</span>
<span class="lineNum">    2048 </span>            :                     }
<span class="lineNum">    2049 </span>            :                 }
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :               else if ((isymp-&gt;n_sclass != C_STAT || isymp-&gt;n_type != T_NULL)</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :                        &amp;&amp; isymp-&gt;n_sclass != C_NT_WEAK)</span>
<span class="lineNum">    2052 </span>            :                 {
<span class="lineNum">    2053 </span>            :                   unsigned long indx;
<span class="lineNum">    2054 </span>            : 
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :                   if (ISFCN (isymp-&gt;n_type)</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :                       || ISTAG (isymp-&gt;n_sclass)</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :                       || isymp-&gt;n_sclass == C_BLOCK</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :                       || isymp-&gt;n_sclass == C_FCN)</span>
<span class="lineNum">    2059 </span>            :                     {
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :                       indx = auxp-&gt;x_sym.x_fcnary.x_fcn.x_endndx.l;</span>
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :                       if (indx &gt; 0</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :                           &amp;&amp; indx &lt; obj_raw_syment_count (input_bfd))</span>
<span class="lineNum">    2063 </span>            :                         {
<span class="lineNum">    2064 </span>            :                           /* We look forward through the symbol for
<span class="lineNum">    2065 </span>            :                              the index of the next symbol we are going
<span class="lineNum">    2066 </span>            :                              to include.  I don't know if this is
<span class="lineNum">    2067 </span>            :                              entirely right.  */
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :                           while ((flaginfo-&gt;sym_indices[indx] &lt; 0</span>
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :                                   || ((bfd_size_type) flaginfo-&gt;sym_indices[indx]</span>
<span class="lineNum">    2070 </span>            :                                       &lt; syment_base))
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :                                  &amp;&amp; indx &lt; obj_raw_syment_count (input_bfd))</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :                             ++indx;</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :                           if (indx &gt;= obj_raw_syment_count (input_bfd))</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :                             indx = output_index;</span>
<span class="lineNum">    2075 </span>            :                           else
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :                             indx = flaginfo-&gt;sym_indices[indx];</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :                           auxp-&gt;x_sym.x_fcnary.x_fcn.x_endndx.l = indx;</span>
<span class="lineNum">    2078 </span>            :                         }
<span class="lineNum">    2079 </span>            :                     }
<span class="lineNum">    2080 </span>            : 
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :                   indx = auxp-&gt;x_sym.x_tagndx.l;</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :                   if (indx &gt; 0 &amp;&amp; indx &lt; obj_raw_syment_count (input_bfd))</span>
<span class="lineNum">    2083 </span>            :                     {
<span class="lineNum">    2084 </span>            :                       long symindx;
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :                       symindx = flaginfo-&gt;sym_indices[indx];</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :                       if (symindx &lt; 0)</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :                         auxp-&gt;x_sym.x_tagndx.l = 0;</span>
<span class="lineNum">    2089 </span>            :                       else
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :                         auxp-&gt;x_sym.x_tagndx.l = symindx;</span>
<span class="lineNum">    2091 </span>            :                     }
<span class="lineNum">    2092 </span>            : 
<span class="lineNum">    2093 </span>            :                   /* The .bf symbols are supposed to be linked through
<span class="lineNum">    2094 </span>            :                      the endndx field.  We need to carry this list
<span class="lineNum">    2095 </span>            :                      across object files.  */
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :                   if (i == 0</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :                       &amp;&amp; h == NULL</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :                       &amp;&amp; isymp-&gt;n_sclass == C_FCN</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :                       &amp;&amp; (isymp-&gt;_n._n_n._n_zeroes != 0</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :                           || isymp-&gt;_n._n_n._n_offset == 0)</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :                       &amp;&amp; isymp-&gt;_n._n_name[0] == '.'</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :                       &amp;&amp; isymp-&gt;_n._n_name[1] == 'b'</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :                       &amp;&amp; isymp-&gt;_n._n_name[2] == 'f'</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :                       &amp;&amp; isymp-&gt;_n._n_name[3] == '\0')</span>
<span class="lineNum">    2105 </span>            :                     {
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :                       if (flaginfo-&gt;last_bf_index != -1)</span>
<span class="lineNum">    2107 </span>            :                         {
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :                           flaginfo-&gt;last_bf.x_sym.x_fcnary.x_fcn.x_endndx.l =</span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :                             *indexp;</span>
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :                           if ((bfd_size_type) flaginfo-&gt;last_bf_index</span>
<span class="lineNum">    2112 </span>            :                               &gt;= syment_base)
<span class="lineNum">    2113 </span>            :                             {
<span class="lineNum">    2114 </span>            :                               void *auxout;
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            :                               /* The last .bf symbol is in this input
<span class="lineNum">    2117 </span>            :                                  file.  This will only happen if the
<span class="lineNum">    2118 </span>            :                                  assembler did not set up the .bf
<span class="lineNum">    2119 </span>            :                                  endndx symbols correctly.  */
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :                               auxout = (flaginfo-&gt;outsyms</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :                                         + ((flaginfo-&gt;last_bf_index</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :                                             - syment_base)</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :                                            * osymesz));</span>
<span class="lineNum">    2124 </span>            : 
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :                               bfd_coff_swap_aux_out (output_bfd,</span>
<span class="lineNum">    2126 </span>            :                                                      &amp;flaginfo-&gt;last_bf,
<span class="lineNum">    2127 </span>            :                                                      isymp-&gt;n_type,
<span class="lineNum">    2128 </span>            :                                                      isymp-&gt;n_sclass,
<span class="lineNum">    2129 </span>            :                                                      0, isymp-&gt;n_numaux,
<span class="lineNum">    2130 </span>            :                                                      auxout);
<span class="lineNum">    2131 </span>            :                             }
<span class="lineNum">    2132 </span>            :                           else
<span class="lineNum">    2133 </span>            :                             {
<span class="lineNum">    2134 </span>            :                               file_ptr pos;
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span>            :                               /* We have already written out the last
<span class="lineNum">    2137 </span>            :                                  .bf aux entry.  We need to write it
<span class="lineNum">    2138 </span>            :                                  out again.  We borrow *outsym
<span class="lineNum">    2139 </span>            :                                  temporarily.  FIXME: This case should
<span class="lineNum">    2140 </span>            :                                  be made faster.  */
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :                               bfd_coff_swap_aux_out (output_bfd,</span>
<span class="lineNum">    2142 </span>            :                                                      &amp;flaginfo-&gt;last_bf,
<span class="lineNum">    2143 </span>            :                                                      isymp-&gt;n_type,
<span class="lineNum">    2144 </span>            :                                                      isymp-&gt;n_sclass,
<span class="lineNum">    2145 </span>            :                                                      0, isymp-&gt;n_numaux,
<span class="lineNum">    2146 </span>            :                                                      outsym);
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :                               pos = obj_sym_filepos (output_bfd);</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :                               pos += flaginfo-&gt;last_bf_index * osymesz;</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :                               if (bfd_seek (output_bfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :                                   || (bfd_bwrite (outsym, osymesz, output_bfd)</span>
<span class="lineNum">    2151 </span>            :                                       != osymesz))
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :                                 return FALSE;</span>
<span class="lineNum">    2153 </span>            :                             }
<span class="lineNum">    2154 </span>            :                         }
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :                       if (auxp-&gt;x_sym.x_fcnary.x_fcn.x_endndx.l != 0)</span>
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :                         flaginfo-&gt;last_bf_index = -1;</span>
<span class="lineNum">    2158 </span>            :                       else
<span class="lineNum">    2159 </span>            :                         {
<span class="lineNum">    2160 </span>            :                           /* The endndx field of this aux entry must
<span class="lineNum">    2161 </span>            :                              be updated with the symbol number of the
<span class="lineNum">    2162 </span>            :                              next .bf symbol.  */
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :                           flaginfo-&gt;last_bf = *auxp;</span>
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :                           flaginfo-&gt;last_bf_index = (((outsym - flaginfo-&gt;outsyms)</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :                                                    / osymesz)</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :                                                   + syment_base);</span>
<span class="lineNum">    2167 </span>            :                         }
<span class="lineNum">    2168 </span>            :                     }
<span class="lineNum">    2169 </span>            :                 }
<span class="lineNum">    2170 </span>            : 
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :               if (h == NULL)</span>
<span class="lineNum">    2172 </span>            :                 {
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :                   bfd_coff_swap_aux_out (output_bfd, auxp, isymp-&gt;n_type,</span>
<span class="lineNum">    2174 </span>            :                                          isymp-&gt;n_sclass, i, isymp-&gt;n_numaux,
<span class="lineNum">    2175 </span>            :                                          outsym);
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :                   outsym += osymesz;</span>
<span class="lineNum">    2177 </span>            :                 }
<span class="lineNum">    2178 </span>            : 
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :               esym += isymesz;</span>
<span class="lineNum">    2180 </span>            :             }
<span class="lineNum">    2181 </span>            :         }
<span class="lineNum">    2182 </span>            : 
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :       indexp += add;</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :       isymp += add;</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :       sym_hash += add;</span>
<span class="lineNum">    2186 </span>            :     }
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span>            :   /* Relocate the line numbers, unless we are stripping them.  */
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :   if (flaginfo-&gt;info-&gt;strip == strip_none</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :       || flaginfo-&gt;info-&gt;strip == strip_some)</span>
<span class="lineNum">    2191 </span>            :     {
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :       for (o = input_bfd-&gt;sections; o != NULL; o = o-&gt;next)</span>
<span class="lineNum">    2193 </span>            :         {
<span class="lineNum">    2194 </span>            :           bfd_vma offset;
<span class="lineNum">    2195 </span>            :           bfd_byte *eline;
<span class="lineNum">    2196 </span>            :           bfd_byte *elineend;
<span class="lineNum">    2197 </span>            :           bfd_byte *oeline;
<span class="lineNum">    2198 </span>            :           bfd_boolean skipping;
<span class="lineNum">    2199 </span>            :           file_ptr pos;
<span class="lineNum">    2200 </span>            :           bfd_size_type amt;
<span class="lineNum">    2201 </span>            : 
<span class="lineNum">    2202 </span>            :           /* FIXME: If SEC_HAS_CONTENTS is not for the section, then
<span class="lineNum">    2203 </span>            :              build_link_order in ldwrite.c will not have created a
<span class="lineNum">    2204 </span>            :              link order, which means that we will not have seen this
<span class="lineNum">    2205 </span>            :              input section in _bfd_coff_final_link, which means that
<span class="lineNum">    2206 </span>            :              we will not have allocated space for the line numbers of
<span class="lineNum">    2207 </span>            :              this section.  I don't think line numbers can be
<span class="lineNum">    2208 </span>            :              meaningful for a section which does not have
<span class="lineNum">    2209 </span>            :              SEC_HAS_CONTENTS set, but, if they do, this must be
<span class="lineNum">    2210 </span>            :              changed.  */
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :           if (o-&gt;lineno_count == 0</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :               || (o-&gt;output_section-&gt;flags &amp; SEC_HAS_CONTENTS) == 0)</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :           if (bfd_seek (input_bfd, o-&gt;line_filepos, SEEK_SET) != 0</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :               || bfd_bread (flaginfo-&gt;linenos, linesz * o-&gt;lineno_count,</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :                            input_bfd) != linesz * o-&gt;lineno_count)</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :           offset = o-&gt;output_section-&gt;vma + o-&gt;output_offset - o-&gt;vma;</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :           eline = flaginfo-&gt;linenos;</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :           oeline = flaginfo-&gt;linenos;</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :           elineend = eline + linesz * o-&gt;lineno_count;</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :           skipping = FALSE;</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :           for (; eline &lt; elineend; eline += linesz)</span>
<span class="lineNum">    2226 </span>            :             {
<span class="lineNum">    2227 </span>            :               struct internal_lineno iline;
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :               bfd_coff_swap_lineno_in (input_bfd, eline, &amp;iline);</span>
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :               if (iline.l_lnno != 0)</span>
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :                 iline.l_addr.l_paddr += offset;</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :               else if (iline.l_addr.l_symndx &gt;= 0</span>
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :                        &amp;&amp; ((unsigned long) iline.l_addr.l_symndx</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :                            &lt; obj_raw_syment_count (input_bfd)))</span>
<span class="lineNum">    2236 </span>            :                 {
<span class="lineNum">    2237 </span>            :                   long indx;
<span class="lineNum">    2238 </span>            : 
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :                   indx = flaginfo-&gt;sym_indices[iline.l_addr.l_symndx];</span>
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :                   if (indx &lt; 0)</span>
<span class="lineNum">    2242 </span>            :                     {
<span class="lineNum">    2243 </span>            :                       /* These line numbers are attached to a symbol
<span class="lineNum">    2244 </span>            :                          which we are stripping.  We must discard the
<span class="lineNum">    2245 </span>            :                          line numbers because reading them back with
<span class="lineNum">    2246 </span>            :                          no associated symbol (or associating them all
<span class="lineNum">    2247 </span>            :                          with symbol #0) will fail.  We can't regain
<span class="lineNum">    2248 </span>            :                          the space in the output file, but at least
<span class="lineNum">    2249 </span>            :                          they're dense.  */
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :                       skipping = TRUE;</span>
<span class="lineNum">    2251 </span>            :                     }
<span class="lineNum">    2252 </span>            :                   else
<span class="lineNum">    2253 </span>            :                     {
<span class="lineNum">    2254 </span>            :                       struct internal_syment is;
<span class="lineNum">    2255 </span>            :                       union internal_auxent ia;
<span class="lineNum">    2256 </span>            : 
<span class="lineNum">    2257 </span>            :                       /* Fix up the lnnoptr field in the aux entry of
<span class="lineNum">    2258 </span>            :                          the symbol.  It turns out that we can't do
<span class="lineNum">    2259 </span>            :                          this when we modify the symbol aux entries,
<span class="lineNum">    2260 </span>            :                          because gas sometimes screws up the lnnoptr
<span class="lineNum">    2261 </span>            :                          field and makes it an offset from the start
<span class="lineNum">    2262 </span>            :                          of the line numbers rather than an absolute
<span class="lineNum">    2263 </span>            :                          file index.  */
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :                       bfd_coff_swap_sym_in (output_bfd,</span>
<span class="lineNum">    2265 </span>            :                                             (flaginfo-&gt;outsyms
<span class="lineNum">    2266 </span>            :                                              + ((indx - syment_base)
<span class="lineNum">    2267 </span>            :                                                 * osymesz)), &amp;is);
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :                       if ((ISFCN (is.n_type)</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :                            || is.n_sclass == C_BLOCK)</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :                           &amp;&amp; is.n_numaux &gt;= 1)</span>
<span class="lineNum">    2271 </span>            :                         {
<span class="lineNum">    2272 </span>            :                           void *auxptr;
<span class="lineNum">    2273 </span>            : 
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :                           auxptr = (flaginfo-&gt;outsyms</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :                                     + ((indx - syment_base + 1)</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :                                        * osymesz));</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :                           bfd_coff_swap_aux_in (output_bfd, auxptr,</span>
<span class="lineNum">    2278 </span>            :                                                 is.n_type, is.n_sclass,
<span class="lineNum">    2279 </span>            :                                                 0, is.n_numaux, &amp;ia);
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :                           ia.x_sym.x_fcnary.x_fcn.x_lnnoptr =</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :                             (o-&gt;output_section-&gt;line_filepos</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :                              + o-&gt;output_section-&gt;lineno_count * linesz</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :                              + eline - flaginfo-&gt;linenos);</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :                           bfd_coff_swap_aux_out (output_bfd, &amp;ia,</span>
<span class="lineNum">    2285 </span>            :                                                  is.n_type, is.n_sclass, 0,
<span class="lineNum">    2286 </span>            :                                                  is.n_numaux, auxptr);
<span class="lineNum">    2287 </span>            :                         }
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :                       skipping = FALSE;</span>
<span class="lineNum">    2290 </span>            :                     }
<span class="lineNum">    2291 </span>            : 
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :                   iline.l_addr.l_symndx = indx;</span>
<span class="lineNum">    2293 </span>            :                 }
<span class="lineNum">    2294 </span>            : 
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :               if (!skipping)</span>
<span class="lineNum">    2296 </span>            :                 {
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :                   bfd_coff_swap_lineno_out (output_bfd, &amp;iline, oeline);</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :                   oeline += linesz;</span>
<span class="lineNum">    2299 </span>            :                 }
<span class="lineNum">    2300 </span>            :             }
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :           pos = o-&gt;output_section-&gt;line_filepos;</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :           pos += o-&gt;output_section-&gt;lineno_count * linesz;</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :           amt = oeline - flaginfo-&gt;linenos;</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :           if (bfd_seek (output_bfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :               || bfd_bwrite (flaginfo-&gt;linenos, amt, output_bfd) != amt)</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :           o-&gt;output_section-&gt;lineno_count += amt / linesz;</span>
<span class="lineNum">    2310 </span>            :         }
<span class="lineNum">    2311 </span>            :     }
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span>            :   /* If we swapped out a C_FILE symbol, guess that the next C_FILE
<span class="lineNum">    2314 </span>            :      symbol will be the first symbol in the next input file.  In the
<span class="lineNum">    2315 </span>            :      normal case, this will save us from writing out the C_FILE symbol
<span class="lineNum">    2316 </span>            :      again.  */
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :   if (flaginfo-&gt;last_file_index != -1</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :       &amp;&amp; (bfd_size_type) flaginfo-&gt;last_file_index &gt;= syment_base)</span>
<span class="lineNum">    2319 </span>            :     {
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :       flaginfo-&gt;last_file.n_value = output_index;</span>
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :       bfd_coff_swap_sym_out (output_bfd, &amp;flaginfo-&gt;last_file,</span>
<span class="lineNum">    2322 </span>            :                              (flaginfo-&gt;outsyms
<span class="lineNum">    2323 </span>            :                               + ((flaginfo-&gt;last_file_index - syment_base)
<span class="lineNum">    2324 </span>            :                                  * osymesz)));
<span class="lineNum">    2325 </span>            :     }
<span class="lineNum">    2326 </span>            : 
<span class="lineNum">    2327 </span>            :   /* Write the modified symbols to the output file.  */
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :   if (outsym &gt; flaginfo-&gt;outsyms)</span>
<span class="lineNum">    2329 </span>            :     {
<span class="lineNum">    2330 </span>            :       file_ptr pos;
<span class="lineNum">    2331 </span>            :       bfd_size_type amt;
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :       pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :       amt = outsym - flaginfo-&gt;outsyms;</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :       if (bfd_seek (output_bfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :           || bfd_bwrite (flaginfo-&gt;outsyms, amt, output_bfd) != amt)</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2338 </span>            : 
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :       BFD_ASSERT ((obj_raw_syment_count (output_bfd)</span>
<span class="lineNum">    2340 </span>            :                    + (outsym - flaginfo-&gt;outsyms) / osymesz)
<span class="lineNum">    2341 </span>            :                   == output_index);
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :       obj_raw_syment_count (output_bfd) = output_index;</span>
<span class="lineNum">    2344 </span>            :     }
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span>            :   /* Relocate the contents of each section.  */
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :   adjust_symndx = coff_backend_info (input_bfd)-&gt;_bfd_coff_adjust_symndx;</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :   for (o = input_bfd-&gt;sections; o != NULL; o = o-&gt;next)</span>
<span class="lineNum">    2349 </span>            :     {
<span class="lineNum">    2350 </span>            :       bfd_byte *contents;
<span class="lineNum">    2351 </span>            :       struct coff_section_tdata *secdata;
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :       if (! o-&gt;linker_mark)</span>
<span class="lineNum">    2354 </span>            :         /* This section was omitted from the link.  */
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2356 </span>            : 
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :       if ((o-&gt;flags &amp; SEC_LINKER_CREATED) != 0)</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :       if ((o-&gt;flags &amp; SEC_HAS_CONTENTS) == 0</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :           || (o-&gt;size == 0 &amp;&amp; (o-&gt;flags &amp; SEC_RELOC) == 0))</span>
<span class="lineNum">    2362 </span>            :         {
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :           if ((o-&gt;flags &amp; SEC_RELOC) != 0</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :               &amp;&amp; o-&gt;reloc_count != 0)</span>
<span class="lineNum">    2365 </span>            :             {
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :               _bfd_error_handler</span>
<span class="lineNum">    2367 </span>            :                 /* xgettext: c-format */
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :                 (_(&quot;%B: relocs in section `%A', but it has no contents&quot;),</span>
<span class="lineNum">    2369 </span>            :                  input_bfd, o);
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :               bfd_set_error (bfd_error_no_contents);</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :               return FALSE;</span>
<span class="lineNum">    2372 </span>            :             }
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    2375 </span>            :         }
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :       secdata = coff_section_data (input_bfd, o);</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :       if (secdata != NULL &amp;&amp; secdata-&gt;contents != NULL)</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :         contents = secdata-&gt;contents;</span>
<span class="lineNum">    2380 </span>            :       else
<span class="lineNum">    2381 </span>            :         {
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :           contents = flaginfo-&gt;contents;</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :           if (! bfd_get_full_section_contents (input_bfd, o, &amp;contents))</span>
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    2385 </span>            :         }
<span class="lineNum">    2386 </span>            : 
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :       if ((o-&gt;flags &amp; SEC_RELOC) != 0)</span>
<span class="lineNum">    2388 </span>            :         {
<span class="lineNum">    2389 </span>            :           int target_index;
<span class="lineNum">    2390 </span>            :           struct internal_reloc *internal_relocs;
<span class="lineNum">    2391 </span>            :           struct internal_reloc *irel;
<span class="lineNum">    2392 </span>            : 
<span class="lineNum">    2393 </span>            :           /* Read in the relocs.  */
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :           target_index = o-&gt;output_section-&gt;target_index;</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :           internal_relocs = (_bfd_coff_read_internal_relocs</span>
<span class="lineNum">    2396 </span>            :                              (input_bfd, o, FALSE, flaginfo-&gt;external_relocs,
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :                               bfd_link_relocatable (flaginfo-&gt;info),</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :                               (bfd_link_relocatable (flaginfo-&gt;info)</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :                                ? (flaginfo-&gt;section_info[target_index].relocs</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :                                   + o-&gt;output_section-&gt;reloc_count)</span>
<span class="lineNum">    2401 </span>            :                                : flaginfo-&gt;internal_relocs)));
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :           if (internal_relocs == NULL</span>
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :               &amp;&amp; o-&gt;reloc_count &gt; 0)</span>
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span>            :           /* Run through the relocs looking for relocs against symbols
<span class="lineNum">    2407 </span>            :              coming from discarded sections and complain about them.  */
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :           irel = internal_relocs;</span>
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :           for (; irel &lt; &amp;internal_relocs[o-&gt;reloc_count]; irel++)</span>
<span class="lineNum">    2410 </span>            :             {
<span class="lineNum">    2411 </span>            :               struct coff_link_hash_entry *h;
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :               asection *ps = NULL;</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :               long symndx = irel-&gt;r_symndx;</span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :               if (symndx &lt; 0)</span>
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :               h = obj_coff_sym_hashes (input_bfd)[symndx];</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :               if (h == NULL)</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :               while (h-&gt;root.type == bfd_link_hash_indirect</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :                      || h-&gt;root.type == bfd_link_hash_warning)</span>
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :                 h = (struct coff_link_hash_entry *) h-&gt;root.u.i.link;</span>
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :               if (h-&gt;root.type == bfd_link_hash_defined</span>
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :                   || h-&gt;root.type == bfd_link_hash_defweak)</span>
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :                 ps = h-&gt;root.u.def.section;</span>
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :               if (ps == NULL)</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2427 </span>            :               /* Complain if definition comes from an excluded section.  */
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :               if (ps-&gt;flags &amp; SEC_EXCLUDE)</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :                 (*flaginfo-&gt;info-&gt;callbacks-&gt;einfo)</span>
<span class="lineNum">    2430 </span>            :                   /* xgettext: c-format */
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :                   (_(&quot;%X`%s' referenced in section `%A' of %B: &quot;</span>
<span class="lineNum">    2432 </span>            :                      &quot;defined in discarded section `%A' of %B\n&quot;),
<span class="lineNum">    2433 </span>            :                    h-&gt;root.root.string, o, input_bfd, ps, ps-&gt;owner);
<span class="lineNum">    2434 </span>            :             }
<span class="lineNum">    2435 </span>            : 
<span class="lineNum">    2436 </span>            :           /* Call processor specific code to relocate the section
<span class="lineNum">    2437 </span>            :              contents.  */
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :           if (! bfd_coff_relocate_section (output_bfd, flaginfo-&gt;info,</span>
<span class="lineNum">    2439 </span>            :                                            input_bfd, o,
<span class="lineNum">    2440 </span>            :                                            contents,
<span class="lineNum">    2441 </span>            :                                            internal_relocs,
<span class="lineNum">    2442 </span>            :                                            flaginfo-&gt;internal_syms,
<span class="lineNum">    2443 </span>            :                                            flaginfo-&gt;sec_ptrs))
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :           if (bfd_link_relocatable (flaginfo-&gt;info))</span>
<span class="lineNum">    2447 </span>            :             {
<span class="lineNum">    2448 </span>            :               bfd_vma offset;
<span class="lineNum">    2449 </span>            :               struct internal_reloc *irelend;
<span class="lineNum">    2450 </span>            :               struct coff_link_hash_entry **rel_hash;
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :               offset = o-&gt;output_section-&gt;vma + o-&gt;output_offset - o-&gt;vma;</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :               irel = internal_relocs;</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :               irelend = irel + o-&gt;reloc_count;</span>
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :               rel_hash = (flaginfo-&gt;section_info[target_index].rel_hashes</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :                           + o-&gt;output_section-&gt;reloc_count);</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :               for (; irel &lt; irelend; irel++, rel_hash++)</span>
<span class="lineNum">    2458 </span>            :                 {
<span class="lineNum">    2459 </span>            :                   struct coff_link_hash_entry *h;
<span class="lineNum">    2460 </span>            :                   bfd_boolean adjusted;
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :                   *rel_hash = NULL;</span>
<span class="lineNum">    2463 </span>            : 
<span class="lineNum">    2464 </span>            :                   /* Adjust the reloc address and symbol index.  */
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :                   irel-&gt;r_vaddr += offset;</span>
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :                   if (irel-&gt;r_symndx == -1)</span>
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    2469 </span>            : 
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :                   if (adjust_symndx)</span>
<span class="lineNum">    2471 </span>            :                     {
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :                       if (! (*adjust_symndx) (output_bfd, flaginfo-&gt;info,</span>
<span class="lineNum">    2473 </span>            :                                               input_bfd, o, irel,
<span class="lineNum">    2474 </span>            :                                               &amp;adjusted))
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :                         return FALSE;</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :                       if (adjusted)</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2478 </span>            :                     }
<span class="lineNum">    2479 </span>            : 
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :                   h = obj_coff_sym_hashes (input_bfd)[irel-&gt;r_symndx];</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :                   if (h != NULL)</span>
<span class="lineNum">    2482 </span>            :                     {
<span class="lineNum">    2483 </span>            :                       /* This is a global symbol.  */
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :                       if (h-&gt;indx &gt;= 0)</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :                         irel-&gt;r_symndx = h-&gt;indx;</span>
<span class="lineNum">    2486 </span>            :                       else
<span class="lineNum">    2487 </span>            :                         {
<span class="lineNum">    2488 </span>            :                           /* This symbol is being written at the end
<span class="lineNum">    2489 </span>            :                              of the file, and we do not yet know the
<span class="lineNum">    2490 </span>            :                              symbol index.  We save the pointer to the
<span class="lineNum">    2491 </span>            :                              hash table entry in the rel_hash list.
<span class="lineNum">    2492 </span>            :                              We set the indx field to -2 to indicate
<span class="lineNum">    2493 </span>            :                              that this symbol must not be stripped.  */
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :                           *rel_hash = h;</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :                           h-&gt;indx = -2;</span>
<span class="lineNum">    2496 </span>            :                         }
<span class="lineNum">    2497 </span>            :                     }
<span class="lineNum">    2498 </span>            :                   else
<span class="lineNum">    2499 </span>            :                     {
<span class="lineNum">    2500 </span>            :                       long indx;
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :                       indx = flaginfo-&gt;sym_indices[irel-&gt;r_symndx];</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :                       if (indx != -1)</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :                         irel-&gt;r_symndx = indx;</span>
<span class="lineNum">    2505 </span>            :                       else
<span class="lineNum">    2506 </span>            :                         {
<span class="lineNum">    2507 </span>            :                           struct internal_syment *is;
<span class="lineNum">    2508 </span>            :                           const char *name;
<span class="lineNum">    2509 </span>            :                           char buf[SYMNMLEN + 1];
<span class="lineNum">    2510 </span>            : 
<span class="lineNum">    2511 </span>            :                           /* This reloc is against a symbol we are
<span class="lineNum">    2512 </span>            :                              stripping.  This should have been handled
<span class="lineNum">    2513 </span>            :                              by the 'dont_skip_symbol' code in the while
<span class="lineNum">    2514 </span>            :                              loop at the top of this function.  */
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :                           is = flaginfo-&gt;internal_syms + irel-&gt;r_symndx;</span>
<span class="lineNum">    2516 </span>            : 
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :                           name = (_bfd_coff_internal_syment_name</span>
<span class="lineNum">    2518 </span>            :                                   (input_bfd, is, buf));
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 :                           if (name == NULL)</span>
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :                             return FALSE;</span>
<span class="lineNum">    2521 </span>            : 
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :                           (*flaginfo-&gt;info-&gt;callbacks-&gt;unattached_reloc)</span>
<span class="lineNum">    2523 </span>            :                             (flaginfo-&gt;info, name, input_bfd, o, irel-&gt;r_vaddr);
<span class="lineNum">    2524 </span>            :                         }
<span class="lineNum">    2525 </span>            :                     }
<span class="lineNum">    2526 </span>            :                 }
<span class="lineNum">    2527 </span>            : 
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :               o-&gt;output_section-&gt;reloc_count += o-&gt;reloc_count;</span>
<span class="lineNum">    2529 </span>            :             }
<span class="lineNum">    2530 </span>            :         }
<span class="lineNum">    2531 </span>            : 
<span class="lineNum">    2532 </span>            :       /* Write out the modified section contents.  */
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :       if (secdata == NULL || secdata-&gt;stab_info == NULL)</span>
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :           file_ptr loc = o-&gt;output_offset * bfd_octets_per_byte (output_bfd);</span>
<span class="lineNum">    2536 </span><span class="lineNoCov">          0 :           if (! bfd_set_section_contents (output_bfd, o-&gt;output_section,</span>
<span class="lineNum">    2537 </span>            :                                           contents, loc, o-&gt;size))
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    2539 </span>            :         }
<span class="lineNum">    2540 </span>            :       else
<span class="lineNum">    2541 </span>            :         {
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :           if (! (_bfd_write_section_stabs</span>
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :                  (output_bfd, &amp;coff_hash_table (flaginfo-&gt;info)-&gt;stab_info,</span>
<span class="lineNum">    2544 </span>            :                   o, &amp;secdata-&gt;stab_info, contents)))
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    2546 </span>            :         }
<span class="lineNum">    2547 </span>            :     }
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :   if (! flaginfo-&gt;info-&gt;keep_memory</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :       &amp;&amp; ! _bfd_coff_free_symbols (input_bfd))</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    2552 </span>            : 
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    2554 </span>            : }
<span class="lineNum">    2555 </span>            : 
<span class="lineNum">    2556 </span>            : /* Write out a global symbol.  Called via bfd_hash_traverse.  */
<a name="2557"><span class="lineNum">    2557 </span>            : </a>
<span class="lineNum">    2558 </span>            : bfd_boolean
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 : _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)</span>
<span class="lineNum">    2560 </span>            : {
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :   struct coff_link_hash_entry *h = (struct coff_link_hash_entry *) bh;</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :   struct coff_final_link_info *flaginfo = (struct coff_final_link_info *) data;</span>
<span class="lineNum">    2563 </span>            :   bfd *output_bfd;
<span class="lineNum">    2564 </span>            :   struct internal_syment isym;
<span class="lineNum">    2565 </span>            :   bfd_size_type symesz;
<span class="lineNum">    2566 </span>            :   unsigned int i;
<span class="lineNum">    2567 </span>            :   file_ptr pos;
<span class="lineNum">    2568 </span>            : 
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :   output_bfd = flaginfo-&gt;output_bfd;</span>
<span class="lineNum">    2570 </span>            : 
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :   if (h-&gt;root.type == bfd_link_hash_warning)</span>
<span class="lineNum">    2572 </span>            :     {
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :       h = (struct coff_link_hash_entry *) h-&gt;root.u.i.link;</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :       if (h-&gt;root.type == bfd_link_hash_new)</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">    2576 </span>            :     }
<span class="lineNum">    2577 </span>            : 
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :   if (h-&gt;indx &gt;= 0)</span>
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :   if (h-&gt;indx != -2</span>
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :       &amp;&amp; (flaginfo-&gt;info-&gt;strip == strip_all</span>
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :           || (flaginfo-&gt;info-&gt;strip == strip_some</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :               &amp;&amp; (bfd_hash_lookup (flaginfo-&gt;info-&gt;keep_hash,</span>
<span class="lineNum">    2585 </span>            :                                    h-&gt;root.root.string, FALSE, FALSE)
<span class="lineNum">    2586 </span>            :                   == NULL))))
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    2588 </span>            : 
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :   switch (h-&gt;root.type)</span>
<span class="lineNum">    2590 </span>            :     {
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    2592 </span>            :     case bfd_link_hash_new:
<span class="lineNum">    2593 </span>            :     case bfd_link_hash_warning:
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :       abort ();</span>
<span class="lineNum">    2595 </span>            :       return FALSE;
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :     case bfd_link_hash_undefined:</span>
<span class="lineNum">    2598 </span>            :     case bfd_link_hash_undefweak:
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :       isym.n_scnum = N_UNDEF;</span>
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :       isym.n_value = 0;</span>
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2602 </span>            : 
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :     case bfd_link_hash_defined:</span>
<span class="lineNum">    2604 </span>            :     case bfd_link_hash_defweak:
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    2606 </span>            :         asection *sec;
<span class="lineNum">    2607 </span>            : 
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :         sec = h-&gt;root.u.def.section-&gt;output_section;</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :         if (bfd_is_abs_section (sec))</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :           isym.n_scnum = N_ABS;</span>
<span class="lineNum">    2611 </span>            :         else
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :           isym.n_scnum = sec-&gt;target_index;</span>
<span class="lineNum">    2613 </span><span class="lineNoCov">          0 :         isym.n_value = (h-&gt;root.u.def.value</span>
<span class="lineNum">    2614 </span><span class="lineNoCov">          0 :                         + h-&gt;root.u.def.section-&gt;output_offset);</span>
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :         if (! obj_pe (flaginfo-&gt;output_bfd))</span>
<span class="lineNum">    2616 </span><span class="lineNoCov">          0 :           isym.n_value += sec-&gt;vma;</span>
<span class="lineNum">    2617 </span>            :       }
<span class="lineNum">    2618 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2619 </span>            : 
<span class="lineNum">    2620 </span><span class="lineNoCov">          0 :     case bfd_link_hash_common:</span>
<span class="lineNum">    2621 </span><span class="lineNoCov">          0 :       isym.n_scnum = N_UNDEF;</span>
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 :       isym.n_value = h-&gt;root.u.c.size;</span>
<span class="lineNum">    2623 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2624 </span>            : 
<span class="lineNum">    2625 </span><span class="lineNoCov">          0 :     case bfd_link_hash_indirect:</span>
<span class="lineNum">    2626 </span>            :       /* Just ignore these.  They can't be handled anyhow.  */
<span class="lineNum">    2627 </span><span class="lineNoCov">          0 :       return TRUE;</span>
<span class="lineNum">    2628 </span>            :     }
<span class="lineNum">    2629 </span>            : 
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :   if (strlen (h-&gt;root.root.string) &lt;= SYMNMLEN)</span>
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :     strncpy (isym._n._n_name, h-&gt;root.root.string, SYMNMLEN);</span>
<span class="lineNum">    2632 </span>            :   else
<span class="lineNum">    2633 </span>            :     {
<span class="lineNum">    2634 </span>            :       bfd_boolean hash;
<span class="lineNum">    2635 </span>            :       bfd_size_type indx;
<span class="lineNum">    2636 </span>            : 
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :       hash = TRUE;</span>
<span class="lineNum">    2638 </span><span class="lineNoCov">          0 :       if (flaginfo-&gt;info-&gt;traditional_format)</span>
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :         hash = FALSE;</span>
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :       indx = _bfd_stringtab_add (flaginfo-&gt;strtab, h-&gt;root.root.string, hash,</span>
<span class="lineNum">    2641 </span>            :                                  FALSE);
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :       if (indx == (bfd_size_type) -1)</span>
<span class="lineNum">    2643 </span>            :         {
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :           flaginfo-&gt;failed = TRUE;</span>
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :           return FALSE;</span>
<span class="lineNum">    2646 </span>            :         }
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 :       isym._n._n_n._n_zeroes = 0;</span>
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :       isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;</span>
<span class="lineNum">    2649 </span>            :     }
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span><span class="lineNoCov">          0 :   isym.n_sclass = h-&gt;symbol_class;</span>
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :   isym.n_type = h-&gt;type;</span>
<span class="lineNum">    2653 </span>            : 
<span class="lineNum">    2654 </span><span class="lineNoCov">          0 :   if (isym.n_sclass == C_NULL)</span>
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :     isym.n_sclass = C_EXT;</span>
<span class="lineNum">    2656 </span>            : 
<span class="lineNum">    2657 </span>            :   /* If doing task linking and this is the pass where we convert
<span class="lineNum">    2658 </span>            :      defined globals to statics, then do that conversion now.  If the
<span class="lineNum">    2659 </span>            :      symbol is not being converted, just ignore it and it will be
<span class="lineNum">    2660 </span>            :      output during a later pass.  */
<span class="lineNum">    2661 </span><span class="lineNoCov">          0 :   if (flaginfo-&gt;global_to_static)</span>
<span class="lineNum">    2662 </span>            :     {
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :       if (! IS_EXTERNAL (output_bfd, isym))</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">    2665 </span>            : 
<span class="lineNum">    2666 </span><span class="lineNoCov">          0 :       isym.n_sclass = C_STAT;</span>
<span class="lineNum">    2667 </span>            :     }
<span class="lineNum">    2668 </span>            : 
<span class="lineNum">    2669 </span>            :   /* When a weak symbol is not overridden by a strong one,
<span class="lineNum">    2670 </span>            :      turn it into an external symbol when not building a
<span class="lineNum">    2671 </span>            :      shared or relocatable object.  */
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :   if (! bfd_link_pic (flaginfo-&gt;info)</span>
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :       &amp;&amp; ! bfd_link_relocatable (flaginfo-&gt;info)</span>
<span class="lineNum">    2674 </span><span class="lineNoCov">          0 :       &amp;&amp; IS_WEAK_EXTERNAL (flaginfo-&gt;output_bfd, isym))</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :     isym.n_sclass = C_EXT;</span>
<span class="lineNum">    2676 </span>            : 
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :   isym.n_numaux = h-&gt;numaux;</span>
<span class="lineNum">    2678 </span>            : 
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :   bfd_coff_swap_sym_out (output_bfd, &amp;isym, flaginfo-&gt;outsyms);</span>
<span class="lineNum">    2680 </span>            : 
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :   symesz = bfd_coff_symesz (output_bfd);</span>
<span class="lineNum">    2682 </span>            : 
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :   pos = obj_sym_filepos (output_bfd);</span>
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 :   pos += obj_raw_syment_count (output_bfd) * symesz;</span>
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 :   if (bfd_seek (output_bfd, pos, SEEK_SET) != 0</span>
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 :       || bfd_bwrite (flaginfo-&gt;outsyms, symesz, output_bfd) != symesz)</span>
<span class="lineNum">    2687 </span>            :     {
<span class="lineNum">    2688 </span><span class="lineNoCov">          0 :       flaginfo-&gt;failed = TRUE;</span>
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    2690 </span>            :     }
<span class="lineNum">    2691 </span>            : 
<span class="lineNum">    2692 </span><span class="lineNoCov">          0 :   h-&gt;indx = obj_raw_syment_count (output_bfd);</span>
<span class="lineNum">    2693 </span>            : 
<span class="lineNum">    2694 </span><span class="lineNoCov">          0 :   ++obj_raw_syment_count (output_bfd);</span>
<span class="lineNum">    2695 </span>            : 
<span class="lineNum">    2696 </span>            :   /* Write out any associated aux entries.  Most of the aux entries
<span class="lineNum">    2697 </span>            :      will have been modified in _bfd_coff_link_input_bfd.  We have to
<span class="lineNum">    2698 </span>            :      handle section aux entries here, now that we have the final
<span class="lineNum">    2699 </span>            :      relocation and line number counts.  */
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; isym.n_numaux; i++)</span>
<span class="lineNum">    2701 </span>            :     {
<span class="lineNum">    2702 </span>            :       union internal_auxent *auxp;
<span class="lineNum">    2703 </span>            : 
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :       auxp = h-&gt;aux + i;</span>
<span class="lineNum">    2705 </span>            : 
<span class="lineNum">    2706 </span>            :       /* Look for a section aux entry here using the same tests that
<span class="lineNum">    2707 </span>            :          coff_swap_aux_out uses.  */
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :       if (i == 0</span>
<span class="lineNum">    2709 </span><span class="lineNoCov">          0 :           &amp;&amp; (isym.n_sclass == C_STAT</span>
<span class="lineNum">    2710 </span><span class="lineNoCov">          0 :               || isym.n_sclass == C_HIDDEN)</span>
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :           &amp;&amp; isym.n_type == T_NULL</span>
<span class="lineNum">    2712 </span><span class="lineNoCov">          0 :           &amp;&amp; (h-&gt;root.type == bfd_link_hash_defined</span>
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :               || h-&gt;root.type == bfd_link_hash_defweak))</span>
<span class="lineNum">    2714 </span>            :         {
<span class="lineNum">    2715 </span>            :           asection *sec;
<span class="lineNum">    2716 </span>            : 
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :           sec = h-&gt;root.u.def.section-&gt;output_section;</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :           if (sec != NULL)</span>
<span class="lineNum">    2719 </span>            :             {
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :               auxp-&gt;x_scn.x_scnlen = sec-&gt;size;</span>
<span class="lineNum">    2721 </span>            : 
<span class="lineNum">    2722 </span>            :               /* For PE, an overflow on the final link reportedly does
<span class="lineNum">    2723 </span>            :                  not matter.  FIXME: Why not?  */
<span class="lineNum">    2724 </span><span class="lineNoCov">          0 :               if (sec-&gt;reloc_count &gt; 0xffff</span>
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :                   &amp;&amp; (! obj_pe (output_bfd)</span>
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :                       || bfd_link_relocatable (flaginfo-&gt;info)))</span>
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :                 _bfd_error_handler</span>
<span class="lineNum">    2728 </span>            :                   /* xgettext: c-format */
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :                   (_(&quot;%s: %s: reloc overflow: 0x%lx &gt; 0xffff&quot;),</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :                    bfd_get_filename (output_bfd),</span>
<span class="lineNum">    2731 </span>            :                    bfd_get_section_name (output_bfd, sec),
<span class="lineNum">    2732 </span>            :                    sec-&gt;reloc_count);
<span class="lineNum">    2733 </span>            : 
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :               if (sec-&gt;lineno_count &gt; 0xffff</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :                   &amp;&amp; (! obj_pe (output_bfd)</span>
<span class="lineNum">    2736 </span><span class="lineNoCov">          0 :                       || bfd_link_relocatable (flaginfo-&gt;info)))</span>
<span class="lineNum">    2737 </span><span class="lineNoCov">          0 :                 _bfd_error_handler</span>
<span class="lineNum">    2738 </span>            :                   /* xgettext: c-format */
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :                   (_(&quot;%s: warning: %s: line number overflow: 0x%lx &gt; 0xffff&quot;),</span>
<span class="lineNum">    2740 </span><span class="lineNoCov">          0 :                    bfd_get_filename (output_bfd),</span>
<span class="lineNum">    2741 </span>            :                    bfd_get_section_name (output_bfd, sec),
<span class="lineNum">    2742 </span>            :                    sec-&gt;lineno_count);
<span class="lineNum">    2743 </span>            : 
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :               auxp-&gt;x_scn.x_nreloc = sec-&gt;reloc_count;</span>
<span class="lineNum">    2745 </span><span class="lineNoCov">          0 :               auxp-&gt;x_scn.x_nlinno = sec-&gt;lineno_count;</span>
<span class="lineNum">    2746 </span><span class="lineNoCov">          0 :               auxp-&gt;x_scn.x_checksum = 0;</span>
<span class="lineNum">    2747 </span><span class="lineNoCov">          0 :               auxp-&gt;x_scn.x_associated = 0;</span>
<span class="lineNum">    2748 </span><span class="lineNoCov">          0 :               auxp-&gt;x_scn.x_comdat = 0;</span>
<span class="lineNum">    2749 </span>            :             }
<span class="lineNum">    2750 </span>            :         }
<span class="lineNum">    2751 </span>            : 
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 :       bfd_coff_swap_aux_out (output_bfd, auxp, isym.n_type,</span>
<span class="lineNum">    2753 </span>            :                              isym.n_sclass, (int) i, isym.n_numaux,
<span class="lineNum">    2754 </span>            :                              flaginfo-&gt;outsyms);
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :       if (bfd_bwrite (flaginfo-&gt;outsyms, symesz, output_bfd) != symesz)</span>
<span class="lineNum">    2756 </span>            :         {
<span class="lineNum">    2757 </span><span class="lineNoCov">          0 :           flaginfo-&gt;failed = TRUE;</span>
<span class="lineNum">    2758 </span><span class="lineNoCov">          0 :           return FALSE;</span>
<span class="lineNum">    2759 </span>            :         }
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 :       ++obj_raw_syment_count (output_bfd);</span>
<span class="lineNum">    2761 </span>            :     }
<span class="lineNum">    2762 </span>            : 
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    2764 </span>            : }
<span class="lineNum">    2765 </span>            : 
<span class="lineNum">    2766 </span>            : /* Write out task global symbols, converting them to statics.  Called
<span class="lineNum">    2767 </span>            :    via coff_link_hash_traverse.  Calls bfd_coff_write_global_sym to do
<span class="lineNum">    2768 </span>            :    the dirty work, if the symbol we are processing needs conversion.  */
<a name="2769"><span class="lineNum">    2769 </span>            : </a>
<span class="lineNum">    2770 </span>            : bfd_boolean
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 : _bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)</span>
<span class="lineNum">    2772 </span>            : {
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :   struct coff_final_link_info *flaginfo = (struct coff_final_link_info *) data;</span>
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :   bfd_boolean rtnval = TRUE;</span>
<span class="lineNum">    2775 </span>            :   bfd_boolean save_global_to_static;
<span class="lineNum">    2776 </span>            : 
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :   if (h-&gt;root.type == bfd_link_hash_warning)</span>
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :     h = (struct coff_link_hash_entry *) h-&gt;root.u.i.link;</span>
<span class="lineNum">    2779 </span>            : 
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :   if (h-&gt;indx &lt; 0)</span>
<span class="lineNum">    2781 </span>            :     {
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :       switch (h-&gt;root.type)</span>
<span class="lineNum">    2783 </span>            :         {
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :         case bfd_link_hash_defined:</span>
<span class="lineNum">    2785 </span>            :         case bfd_link_hash_defweak:
<span class="lineNum">    2786 </span><span class="lineNoCov">          0 :           save_global_to_static = flaginfo-&gt;global_to_static;</span>
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 :           flaginfo-&gt;global_to_static = TRUE;</span>
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 :           rtnval = _bfd_coff_write_global_sym (&amp;h-&gt;root.root, data);</span>
<span class="lineNum">    2789 </span><span class="lineNoCov">          0 :           flaginfo-&gt;global_to_static = save_global_to_static;</span>
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2793 </span>            :         }
<span class="lineNum">    2794 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 :   return (rtnval);</span>
<span class="lineNum">    2796 </span>            : }
<span class="lineNum">    2797 </span>            : 
<span class="lineNum">    2798 </span>            : /* Handle a link order which is supposed to generate a reloc.  */
<a name="2799"><span class="lineNum">    2799 </span>            : </a>
<span class="lineNum">    2800 </span>            : bfd_boolean
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 : _bfd_coff_reloc_link_order (bfd *output_bfd,</span>
<span class="lineNum">    2802 </span>            :                             struct coff_final_link_info *flaginfo,
<span class="lineNum">    2803 </span>            :                             asection *output_section,
<span class="lineNum">    2804 </span>            :                             struct bfd_link_order *link_order)
<span class="lineNum">    2805 </span>            : {
<span class="lineNum">    2806 </span>            :   reloc_howto_type *howto;
<span class="lineNum">    2807 </span>            :   struct internal_reloc *irel;
<span class="lineNum">    2808 </span>            :   struct coff_link_hash_entry **rel_hash_ptr;
<span class="lineNum">    2809 </span>            : 
<span class="lineNum">    2810 </span><span class="lineNoCov">          0 :   howto = bfd_reloc_type_lookup (output_bfd, link_order-&gt;u.reloc.p-&gt;reloc);</span>
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :   if (howto == NULL)</span>
<span class="lineNum">    2812 </span>            :     {
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_bad_value);</span>
<span class="lineNum">    2814 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    2815 </span>            :     }
<span class="lineNum">    2816 </span>            : 
<span class="lineNum">    2817 </span><span class="lineNoCov">          0 :   if (link_order-&gt;u.reloc.p-&gt;addend != 0)</span>
<span class="lineNum">    2818 </span>            :     {
<span class="lineNum">    2819 </span>            :       bfd_size_type size;
<span class="lineNum">    2820 </span>            :       bfd_byte *buf;
<span class="lineNum">    2821 </span>            :       bfd_reloc_status_type rstat;
<span class="lineNum">    2822 </span>            :       bfd_boolean ok;
<span class="lineNum">    2823 </span>            :       file_ptr loc;
<span class="lineNum">    2824 </span>            : 
<span class="lineNum">    2825 </span><span class="lineNoCov">          0 :       size = bfd_get_reloc_size (howto);</span>
<span class="lineNum">    2826 </span><span class="lineNoCov">          0 :       buf = (bfd_byte *) bfd_zmalloc (size);</span>
<span class="lineNum">    2827 </span><span class="lineNoCov">          0 :       if (buf == NULL &amp;&amp; size != 0)</span>
<span class="lineNum">    2828 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2829 </span>            : 
<span class="lineNum">    2830 </span><span class="lineNoCov">          0 :       rstat = _bfd_relocate_contents (howto, output_bfd,</span>
<span class="lineNum">    2831 </span><span class="lineNoCov">          0 :                                       (bfd_vma) link_order-&gt;u.reloc.p-&gt;addend,\</span>
<span class="lineNum">    2832 </span>            :                                       buf);
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :       switch (rstat)</span>
<span class="lineNum">    2834 </span>            :         {
<span class="lineNum">    2835 </span><span class="lineNoCov">          0 :         case bfd_reloc_ok:</span>
<span class="lineNum">    2836 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2837 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    2838 </span>            :         case bfd_reloc_outofrange:
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :           abort ();</span>
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :         case bfd_reloc_overflow:</span>
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :           (*flaginfo-&gt;info-&gt;callbacks-&gt;reloc_overflow)</span>
<span class="lineNum">    2842 </span>            :             (flaginfo-&gt;info, NULL,
<span class="lineNum">    2843 </span><span class="lineNoCov">          0 :              (link_order-&gt;type == bfd_section_reloc_link_order</span>
<span class="lineNum">    2844 </span><span class="lineNoCov">          0 :               ? bfd_section_name (output_bfd,</span>
<span class="lineNum">    2845 </span>            :                                   link_order-&gt;u.reloc.p-&gt;u.section)
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 :               : link_order-&gt;u.reloc.p-&gt;u.name),</span>
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 :              howto-&gt;name, link_order-&gt;u.reloc.p-&gt;addend,</span>
<span class="lineNum">    2848 </span>            :              (bfd *) NULL, (asection *) NULL, (bfd_vma) 0);
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2850 </span>            :         }
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 :       loc = link_order-&gt;offset * bfd_octets_per_byte (output_bfd);</span>
<span class="lineNum">    2852 </span><span class="lineNoCov">          0 :       ok = bfd_set_section_contents (output_bfd, output_section, buf,</span>
<span class="lineNum">    2853 </span>            :                                      loc, size);
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :       free (buf);</span>
<span class="lineNum">    2855 </span><span class="lineNoCov">          0 :       if (! ok)</span>
<span class="lineNum">    2856 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2857 </span>            :     }
<span class="lineNum">    2858 </span>            : 
<span class="lineNum">    2859 </span>            :   /* Store the reloc information in the right place.  It will get
<span class="lineNum">    2860 </span>            :      swapped and written out at the end of the final_link routine.  */
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :   irel = (flaginfo-&gt;section_info[output_section-&gt;target_index].relocs</span>
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :           + output_section-&gt;reloc_count);</span>
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :   rel_hash_ptr = (flaginfo-&gt;section_info[output_section-&gt;target_index].rel_hashes</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :                   + output_section-&gt;reloc_count);</span>
<span class="lineNum">    2865 </span>            : 
<span class="lineNum">    2866 </span><span class="lineNoCov">          0 :   memset (irel, 0, sizeof (struct internal_reloc));</span>
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 :   *rel_hash_ptr = NULL;</span>
<span class="lineNum">    2868 </span>            : 
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :   irel-&gt;r_vaddr = output_section-&gt;vma + link_order-&gt;offset;</span>
<span class="lineNum">    2870 </span>            : 
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :   if (link_order-&gt;type == bfd_section_reloc_link_order)</span>
<span class="lineNum">    2872 </span>            :     {
<span class="lineNum">    2873 </span>            :       /* We need to somehow locate a symbol in the right section.  The
<span class="lineNum">    2874 </span>            :          symbol must either have a value of zero, or we must adjust
<span class="lineNum">    2875 </span>            :          the addend by the value of the symbol.  FIXME: Write this
<span class="lineNum">    2876 </span>            :          when we need it.  The old linker couldn't handle this anyhow.  */
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :       abort ();</span>
<span class="lineNum">    2878 </span>            :       *rel_hash_ptr = NULL;
<span class="lineNum">    2879 </span>            :       irel-&gt;r_symndx = 0;
<span class="lineNum">    2880 </span>            :     }
<span class="lineNum">    2881 </span>            :   else
<span class="lineNum">    2882 </span>            :     {
<span class="lineNum">    2883 </span>            :       struct coff_link_hash_entry *h;
<span class="lineNum">    2884 </span>            : 
<span class="lineNum">    2885 </span><span class="lineNoCov">          0 :       h = ((struct coff_link_hash_entry *)</span>
<span class="lineNum">    2886 </span><span class="lineNoCov">          0 :            bfd_wrapped_link_hash_lookup (output_bfd, flaginfo-&gt;info,</span>
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :                                          link_order-&gt;u.reloc.p-&gt;u.name,</span>
<span class="lineNum">    2888 </span>            :                                          FALSE, FALSE, TRUE));
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :       if (h != NULL)</span>
<span class="lineNum">    2890 </span>            :         {
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :           if (h-&gt;indx &gt;= 0)</span>
<span class="lineNum">    2892 </span><span class="lineNoCov">          0 :             irel-&gt;r_symndx = h-&gt;indx;</span>
<span class="lineNum">    2893 </span>            :           else
<span class="lineNum">    2894 </span>            :             {
<span class="lineNum">    2895 </span>            :               /* Set the index to -2 to force this symbol to get
<span class="lineNum">    2896 </span>            :                  written out.  */
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :               h-&gt;indx = -2;</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :               *rel_hash_ptr = h;</span>
<span class="lineNum">    2899 </span><span class="lineNoCov">          0 :               irel-&gt;r_symndx = 0;</span>
<span class="lineNum">    2900 </span>            :             }
<span class="lineNum">    2901 </span>            :         }
<span class="lineNum">    2902 </span>            :       else
<span class="lineNum">    2903 </span>            :         {
<span class="lineNum">    2904 </span><span class="lineNoCov">          0 :           (*flaginfo-&gt;info-&gt;callbacks-&gt;unattached_reloc)</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :             (flaginfo-&gt;info, link_order-&gt;u.reloc.p-&gt;u.name,</span>
<span class="lineNum">    2906 </span>            :              (bfd *) NULL, (asection *) NULL, (bfd_vma) 0);
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :           irel-&gt;r_symndx = 0;</span>
<span class="lineNum">    2908 </span>            :         }
<span class="lineNum">    2909 </span>            :     }
<span class="lineNum">    2910 </span>            : 
<span class="lineNum">    2911 </span>            :   /* FIXME: Is this always right?  */
<span class="lineNum">    2912 </span><span class="lineNoCov">          0 :   irel-&gt;r_type = howto-&gt;type;</span>
<span class="lineNum">    2913 </span>            : 
<span class="lineNum">    2914 </span>            :   /* r_size is only used on the RS/6000, which needs its own linker
<span class="lineNum">    2915 </span>            :      routines anyhow.  r_extern is only used for ECOFF.  */
<span class="lineNum">    2916 </span>            : 
<span class="lineNum">    2917 </span>            :   /* FIXME: What is the right value for r_offset?  Is zero OK?  */
<span class="lineNum">    2918 </span><span class="lineNoCov">          0 :   ++output_section-&gt;reloc_count;</span>
<span class="lineNum">    2919 </span>            : 
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    2921 </span>            : }
<span class="lineNum">    2922 </span>            : 
<span class="lineNum">    2923 </span>            : /* A basic reloc handling routine which may be used by processors with
<span class="lineNum">    2924 </span>            :    simple relocs.  */
<a name="2925"><span class="lineNum">    2925 </span>            : </a>
<span class="lineNum">    2926 </span>            : bfd_boolean
<span class="lineNum">    2927 </span><span class="lineNoCov">          0 : _bfd_coff_generic_relocate_section (bfd *output_bfd,</span>
<span class="lineNum">    2928 </span>            :                                     struct bfd_link_info *info,
<span class="lineNum">    2929 </span>            :                                     bfd *input_bfd,
<span class="lineNum">    2930 </span>            :                                     asection *input_section,
<span class="lineNum">    2931 </span>            :                                     bfd_byte *contents,
<span class="lineNum">    2932 </span>            :                                     struct internal_reloc *relocs,
<span class="lineNum">    2933 </span>            :                                     struct internal_syment *syms,
<span class="lineNum">    2934 </span>            :                                     asection **sections)
<span class="lineNum">    2935 </span>            : {
<span class="lineNum">    2936 </span>            :   struct internal_reloc *rel;
<span class="lineNum">    2937 </span>            :   struct internal_reloc *relend;
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :   rel = relocs;</span>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :   relend = rel + input_section-&gt;reloc_count;</span>
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :   for (; rel &lt; relend; rel++)</span>
<span class="lineNum">    2942 </span>            :     {
<span class="lineNum">    2943 </span>            :       long symndx;
<span class="lineNum">    2944 </span>            :       struct coff_link_hash_entry *h;
<span class="lineNum">    2945 </span>            :       struct internal_syment *sym;
<span class="lineNum">    2946 </span>            :       bfd_vma addend;
<span class="lineNum">    2947 </span>            :       bfd_vma val;
<span class="lineNum">    2948 </span>            :       asection *sec;
<span class="lineNum">    2949 </span>            :       reloc_howto_type *howto;
<span class="lineNum">    2950 </span>            :       bfd_reloc_status_type rstat;
<span class="lineNum">    2951 </span>            : 
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :       symndx = rel-&gt;r_symndx;</span>
<span class="lineNum">    2953 </span>            : 
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :       if (symndx == -1)</span>
<span class="lineNum">    2955 </span>            :         {
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :           h = NULL;</span>
<span class="lineNum">    2957 </span><span class="lineNoCov">          0 :           sym = NULL;</span>
<span class="lineNum">    2958 </span>            :         }
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :       else if (symndx &lt; 0</span>
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :                || (unsigned long) symndx &gt;= obj_raw_syment_count (input_bfd))</span>
<span class="lineNum">    2961 </span>            :         {
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :           _bfd_error_handler</span>
<span class="lineNum">    2963 </span>            :             /* xgettext: c-format */
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :             (_(&quot;%B: illegal symbol index %ld in relocs&quot;), input_bfd, symndx);</span>
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :           return FALSE;</span>
<span class="lineNum">    2966 </span>            :         }
<span class="lineNum">    2967 </span>            :       else
<span class="lineNum">    2968 </span>            :         {
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :           h = obj_coff_sym_hashes (input_bfd)[symndx];</span>
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :           sym = syms + symndx;</span>
<span class="lineNum">    2971 </span>            :         }
<span class="lineNum">    2972 </span>            : 
<span class="lineNum">    2973 </span>            :       /* COFF treats common symbols in one of two ways.  Either the
<span class="lineNum">    2974 </span>            :          size of the symbol is included in the section contents, or it
<span class="lineNum">    2975 </span>            :          is not.  We assume that the size is not included, and force
<span class="lineNum">    2976 </span>            :          the rtype_to_howto function to adjust the addend as needed.  */
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :       if (sym != NULL &amp;&amp; sym-&gt;n_scnum != 0)</span>
<span class="lineNum">    2978 </span><span class="lineNoCov">          0 :         addend = - sym-&gt;n_value;</span>
<span class="lineNum">    2979 </span>            :       else
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :         addend = 0;</span>
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :       howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,</span>
<span class="lineNum">    2983 </span>            :                                        sym, &amp;addend);
<span class="lineNum">    2984 </span><span class="lineNoCov">          0 :       if (howto == NULL)</span>
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2986 </span>            : 
<span class="lineNum">    2987 </span>            :       /* If we are doing a relocatable link, then we can just ignore
<span class="lineNum">    2988 </span>            :          a PC relative reloc that is pcrel_offset.  It will already
<span class="lineNum">    2989 </span>            :          have the correct value.  If this is not a relocatable link,
<span class="lineNum">    2990 </span>            :          then we should ignore the symbol value.  */
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :       if (howto-&gt;pc_relative &amp;&amp; howto-&gt;pcrel_offset)</span>
<span class="lineNum">    2992 </span>            :         {
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :           if (bfd_link_relocatable (info))</span>
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :           if (sym != NULL &amp;&amp; sym-&gt;n_scnum != 0)</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :             addend += sym-&gt;n_value;</span>
<span class="lineNum">    2997 </span>            :         }
<span class="lineNum">    2998 </span>            : 
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :       val = 0;</span>
<span class="lineNum">    3000 </span><span class="lineNoCov">          0 :       sec = NULL;</span>
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :       if (h == NULL)</span>
<span class="lineNum">    3002 </span>            :         {
<span class="lineNum">    3003 </span><span class="lineNoCov">          0 :           if (symndx == -1)</span>
<span class="lineNum">    3004 </span>            :             {
<span class="lineNum">    3005 </span><span class="lineNoCov">          0 :               sec = bfd_abs_section_ptr;</span>
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :               val = 0;</span>
<span class="lineNum">    3007 </span>            :             }
<span class="lineNum">    3008 </span>            :           else
<span class="lineNum">    3009 </span>            :             {
<span class="lineNum">    3010 </span><span class="lineNoCov">          0 :               sec = sections[symndx];</span>
<span class="lineNum">    3011 </span>            : 
<span class="lineNum">    3012 </span>            :               /* PR 19623: Relocations against symbols in
<span class="lineNum">    3013 </span>            :                  the absolute sections should ignored.  */
<span class="lineNum">    3014 </span><span class="lineNoCov">          0 :               if (bfd_is_abs_section (sec))</span>
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    3016 </span>            : 
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :               val = (sec-&gt;output_section-&gt;vma</span>
<span class="lineNum">    3018 </span><span class="lineNoCov">          0 :                      + sec-&gt;output_offset</span>
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 :                      + sym-&gt;n_value);</span>
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :               if (! obj_pe (input_bfd))</span>
<span class="lineNum">    3021 </span><span class="lineNoCov">          0 :                 val -= sec-&gt;vma;</span>
<span class="lineNum">    3022 </span>            :             }
<span class="lineNum">    3023 </span>            :         }
<span class="lineNum">    3024 </span>            :       else
<span class="lineNum">    3025 </span>            :         {
<span class="lineNum">    3026 </span><span class="lineNoCov">          0 :           if (h-&gt;root.type == bfd_link_hash_defined</span>
<span class="lineNum">    3027 </span><span class="lineNoCov">          0 :               || h-&gt;root.type == bfd_link_hash_defweak)</span>
<span class="lineNum">    3028 </span>            :             {
<span class="lineNum">    3029 </span>            :               /* Defined weak symbols are a GNU extension. */
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 :               sec = h-&gt;root.u.def.section;</span>
<span class="lineNum">    3031 </span><span class="lineNoCov">          0 :               val = (h-&gt;root.u.def.value</span>
<span class="lineNum">    3032 </span><span class="lineNoCov">          0 :                      + sec-&gt;output_section-&gt;vma</span>
<span class="lineNum">    3033 </span><span class="lineNoCov">          0 :                      + sec-&gt;output_offset);</span>
<span class="lineNum">    3034 </span>            :             }
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 :           else if (h-&gt;root.type == bfd_link_hash_undefweak)</span>
<span class="lineNum">    3037 </span>            :             {
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :               if (h-&gt;symbol_class == C_NT_WEAK &amp;&amp; h-&gt;numaux == 1)</span>
<span class="lineNum">    3039 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">    3040 </span>            :                   /* See _Microsoft Portable Executable and Common Object
<span class="lineNum">    3041 </span>            :                      File Format Specification_, section 5.5.3.
<span class="lineNum">    3042 </span>            :                      Note that weak symbols without aux records are a GNU
<span class="lineNum">    3043 </span>            :                      extension.
<span class="lineNum">    3044 </span>            :                      FIXME: All weak externals are treated as having
<span class="lineNum">    3045 </span>            :                      characteristic IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY (1).
<span class="lineNum">    3046 </span>            :                      These behave as per SVR4 ABI:  A library member
<span class="lineNum">    3047 </span>            :                      will resolve a weak external only if a normal
<span class="lineNum">    3048 </span>            :                      external causes the library member to be linked.
<span class="lineNum">    3049 </span>            :                      See also linker.c: generic_link_check_archive_element. */
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :                   struct coff_link_hash_entry *h2 =</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :                     h-&gt;auxbfd-&gt;tdata.coff_obj_data-&gt;sym_hashes[</span>
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :                     h-&gt;aux-&gt;x_sym.x_tagndx.l];</span>
<span class="lineNum">    3053 </span>            : 
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :                   if (!h2 || h2-&gt;root.type == bfd_link_hash_undefined)</span>
<span class="lineNum">    3055 </span>            :                     {
<span class="lineNum">    3056 </span><span class="lineNoCov">          0 :                       sec = bfd_abs_section_ptr;</span>
<span class="lineNum">    3057 </span><span class="lineNoCov">          0 :                       val = 0;</span>
<span class="lineNum">    3058 </span>            :                     }
<span class="lineNum">    3059 </span>            :                   else
<span class="lineNum">    3060 </span>            :                     {
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 :                       sec = h2-&gt;root.u.def.section;</span>
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :                       val = h2-&gt;root.u.def.value</span>
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :                         + sec-&gt;output_section-&gt;vma + sec-&gt;output_offset;</span>
<span class="lineNum">    3064 </span>            :                     }
<span class="lineNum">    3065 </span>            :                 }
<span class="lineNum">    3066 </span>            :               else
<span class="lineNum">    3067 </span>            :                 /* This is a GNU extension.  */
<span class="lineNum">    3068 </span><span class="lineNoCov">          0 :                 val = 0;</span>
<span class="lineNum">    3069 </span>            :             }
<span class="lineNum">    3070 </span>            : 
<span class="lineNum">    3071 </span><span class="lineNoCov">          0 :           else if (! bfd_link_relocatable (info))</span>
<span class="lineNum">    3072 </span><span class="lineNoCov">          0 :             (*info-&gt;callbacks-&gt;undefined_symbol)</span>
<span class="lineNum">    3073 </span>            :               (info, h-&gt;root.root.string, input_bfd, input_section,
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :                rel-&gt;r_vaddr - input_section-&gt;vma, TRUE);</span>
<span class="lineNum">    3075 </span>            :         }
<span class="lineNum">    3076 </span>            : 
<span class="lineNum">    3077 </span>            :       /* If the input section defining the symbol has been discarded
<span class="lineNum">    3078 </span>            :          then zero this reloc field.  */
<span class="lineNum">    3079 </span><span class="lineNoCov">          0 :       if (sec != NULL &amp;&amp; discarded_section (sec))</span>
<span class="lineNum">    3080 </span>            :         {
<span class="lineNum">    3081 </span><span class="lineNoCov">          0 :           _bfd_clear_contents (howto, input_bfd, input_section,</span>
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :                                contents + (rel-&gt;r_vaddr - input_section-&gt;vma));</span>
<span class="lineNum">    3083 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    3084 </span>            :         }
<span class="lineNum">    3085 </span>            : 
<span class="lineNum">    3086 </span><span class="lineNoCov">          0 :       if (info-&gt;base_file)</span>
<span class="lineNum">    3087 </span>            :         {
<span class="lineNum">    3088 </span>            :           /* Emit a reloc if the backend thinks it needs it.  */
<span class="lineNum">    3089 </span><span class="lineNoCov">          0 :           if (sym &amp;&amp; pe_data (output_bfd)-&gt;in_reloc_p (output_bfd, howto))</span>
<span class="lineNum">    3090 </span>            :             {
<span class="lineNum">    3091 </span>            :               /* Relocation to a symbol in a section which isn't
<span class="lineNum">    3092 </span>            :                  absolute.  We output the address here to a file.
<span class="lineNum">    3093 </span>            :                  This file is then read by dlltool when generating the
<span class="lineNum">    3094 </span>            :                  reloc section.  Note that the base file is not
<span class="lineNum">    3095 </span>            :                  portable between systems.  We write out a bfd_vma here,
<span class="lineNum">    3096 </span>            :                  and dlltool reads in a bfd_vma.  */
<span class="lineNum">    3097 </span><span class="lineNoCov">          0 :               bfd_vma addr = (rel-&gt;r_vaddr</span>
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :                            - input_section-&gt;vma</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :                            + input_section-&gt;output_offset</span>
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :                            + input_section-&gt;output_section-&gt;vma);</span>
<span class="lineNum">    3101 </span><span class="lineNoCov">          0 :               if (coff_data (output_bfd)-&gt;pe)</span>
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :                 addr -= pe_data(output_bfd)-&gt;pe_opthdr.ImageBase;</span>
<span class="lineNum">    3103 </span><span class="lineNoCov">          0 :               if (fwrite (&amp;addr, 1, sizeof (bfd_vma), (FILE *) info-&gt;base_file)</span>
<span class="lineNum">    3104 </span>            :                   != sizeof (bfd_vma))
<span class="lineNum">    3105 </span>            :                 {
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 :                   bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">    3107 </span><span class="lineNoCov">          0 :                   return FALSE;</span>
<span class="lineNum">    3108 </span>            :                 }
<span class="lineNum">    3109 </span>            :             }
<span class="lineNum">    3110 </span>            :         }
<span class="lineNum">    3111 </span>            : 
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :       rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,</span>
<span class="lineNum">    3113 </span>            :                                         contents,
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :                                         rel-&gt;r_vaddr - input_section-&gt;vma,</span>
<span class="lineNum">    3115 </span>            :                                         val, addend);
<span class="lineNum">    3116 </span>            : 
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 :       switch (rstat)</span>
<span class="lineNum">    3118 </span>            :         {
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :           abort ();</span>
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :         case bfd_reloc_ok:</span>
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :         case bfd_reloc_outofrange:</span>
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 :           _bfd_error_handler</span>
<span class="lineNum">    3125 </span>            :             /* xgettext: c-format */
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :             (_(&quot;%B: bad reloc address 0x%lx in section `%A'&quot;),</span>
<span class="lineNum">    3127 </span><span class="lineNoCov">          0 :              input_bfd, input_section, (unsigned long) rel-&gt;r_vaddr);</span>
<span class="lineNum">    3128 </span><span class="lineNoCov">          0 :           return FALSE;</span>
<span class="lineNum">    3129 </span><span class="lineNoCov">          0 :         case bfd_reloc_overflow:</span>
<span class="lineNum">    3130 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    3131 </span>            :             const char *name;
<span class="lineNum">    3132 </span>            :             char buf[SYMNMLEN + 1];
<span class="lineNum">    3133 </span>            : 
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :             if (symndx == -1)</span>
<span class="lineNum">    3135 </span><span class="lineNoCov">          0 :               name = &quot;*ABS*&quot;;</span>
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :             else if (h != NULL)</span>
<span class="lineNum">    3137 </span><span class="lineNoCov">          0 :               name = NULL;</span>
<span class="lineNum">    3138 </span>            :             else
<span class="lineNum">    3139 </span>            :               {
<span class="lineNum">    3140 </span><span class="lineNoCov">          0 :                 name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);</span>
<span class="lineNum">    3141 </span><span class="lineNoCov">          0 :                 if (name == NULL)</span>
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :                   return FALSE;</span>
<span class="lineNum">    3143 </span>            :               }
<span class="lineNum">    3144 </span>            : 
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :             (*info-&gt;callbacks-&gt;reloc_overflow)</span>
<span class="lineNum">    3146 </span><span class="lineNoCov">          0 :               (info, (h ? &amp;h-&gt;root : NULL), name, howto-&gt;name,</span>
<span class="lineNum">    3147 </span>            :                (bfd_vma) 0, input_bfd, input_section,
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :                rel-&gt;r_vaddr - input_section-&gt;vma);</span>
<span class="lineNum">    3149 </span>            :           }
<span class="lineNum">    3150 </span>            :         }
<span class="lineNum">    3151 </span>            :     }
<span class="lineNum">    3152 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    3153 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
