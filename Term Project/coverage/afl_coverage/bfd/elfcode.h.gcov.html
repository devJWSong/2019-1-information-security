<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - afl_coverage.info - bfd/elfcode.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">bfd</a> - elfcode.h<span style="font-size: 80%;"> (source / <a href="elfcode.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">afl_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">328</td>
            <td class="headerCovTableEntry">816</td>
            <td class="headerCovTableEntryLo">40.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-06-20 14:23:35</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntryLo">23.9 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* ELF executable support for BFD.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1991-2017 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            :    Written by Fred Fish @ Cygnus Support, from information published
<span class="lineNum">       5 </span>            :    in &quot;UNIX System V Release 4, Programmers Guide: ANSI C and
<span class="lineNum">       6 </span>            :    Programming Support Tools&quot;.  Sufficient support for gdb.
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            :    Rewritten by Mark Eichin @ Cygnus Support, from information
<span class="lineNum">       9 </span>            :    published in &quot;System V Application Binary Interface&quot;, chapters 4
<span class="lineNum">      10 </span>            :    and 5, as well as the various &quot;Processor Supplement&quot; documents
<span class="lineNum">      11 </span>            :    derived from it. Added support for assembler and other object file
<span class="lineNum">      12 </span>            :    utilities.  Further work done by Ken Raeburn (Cygnus Support), Michael
<span class="lineNum">      13 </span>            :    Meissner (Open Software Foundation), and Peter Hoogenboom (University
<span class="lineNum">      14 </span>            :    of Utah) to finish and extend this.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :    This file is part of BFD, the Binary File Descriptor library.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            :    This program is free software; you can redistribute it and/or modify
<span class="lineNum">      19 </span>            :    it under the terms of the GNU General Public License as published by
<span class="lineNum">      20 </span>            :    the Free Software Foundation; either version 3 of the License, or
<span class="lineNum">      21 </span>            :    (at your option) any later version.
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            :    This program is distributed in the hope that it will be useful,
<span class="lineNum">      24 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      25 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      26 </span>            :    GNU General Public License for more details.
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            :    You should have received a copy of the GNU General Public License
<span class="lineNum">      29 </span>            :    along with this program; if not, write to the Free Software
<span class="lineNum">      30 </span>            :    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
<span class="lineNum">      31 </span>            :    MA 02110-1301, USA.  */
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : /* Problems and other issues to resolve.
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :    (1)  BFD expects there to be some fixed number of &quot;sections&quot; in
<span class="lineNum">      37 </span>            :         the object file.  I.E. there is a &quot;section_count&quot; variable in the
<span class="lineNum">      38 </span>            :         bfd structure which contains the number of sections.  However, ELF
<span class="lineNum">      39 </span>            :         supports multiple &quot;views&quot; of a file.  In particular, with current
<span class="lineNum">      40 </span>            :         implementations, executable files typically have two tables, a
<span class="lineNum">      41 </span>            :         program header table and a section header table, both of which
<span class="lineNum">      42 </span>            :         partition the executable.
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            :         In ELF-speak, the &quot;linking view&quot; of the file uses the section header
<span class="lineNum">      45 </span>            :         table to access &quot;sections&quot; within the file, and the &quot;execution view&quot;
<span class="lineNum">      46 </span>            :         uses the program header table to access &quot;segments&quot; within the file.
<span class="lineNum">      47 </span>            :         &quot;Segments&quot; typically may contain all the data from one or more
<span class="lineNum">      48 </span>            :         &quot;sections&quot;.
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :         Note that the section header table is optional in ELF executables,
<span class="lineNum">      51 </span>            :         but it is this information that is most useful to gdb.  If the
<span class="lineNum">      52 </span>            :         section header table is missing, then gdb should probably try
<span class="lineNum">      53 </span>            :         to make do with the program header table.  (FIXME)
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :    (2)  The code in this file is compiled twice, once in 32-bit mode and
<span class="lineNum">      56 </span>            :         once in 64-bit mode.  More of it should be made size-independent
<span class="lineNum">      57 </span>            :         and moved into elf.c.
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :    (3)  ELF section symbols are handled rather sloppily now.  This should
<span class="lineNum">      60 </span>            :         be cleaned up, and ELF section symbols reconciled with BFD section
<span class="lineNum">      61 </span>            :         symbols.
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :    (4)  We need a published spec for 64-bit ELF.  We've got some stuff here
<span class="lineNum">      64 </span>            :         that we're using for SPARC V9 64-bit chips, but don't assume that
<span class="lineNum">      65 </span>            :         it's cast in stone.
<span class="lineNum">      66 </span>            :  */
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : #include &quot;sysdep.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;bfd.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;libiberty.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;bfdlink.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;libbfd.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;elf-bfd.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;libiberty.h&quot;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : /* Renaming structures, typedefs, macros and functions to be size-specific.  */
<span class="lineNum">      77 </span>            : #define Elf_External_Ehdr       NAME(Elf,External_Ehdr)
<span class="lineNum">      78 </span>            : #define Elf_External_Sym        NAME(Elf,External_Sym)
<span class="lineNum">      79 </span>            : #define Elf_External_Shdr       NAME(Elf,External_Shdr)
<span class="lineNum">      80 </span>            : #define Elf_External_Phdr       NAME(Elf,External_Phdr)
<span class="lineNum">      81 </span>            : #define Elf_External_Rel        NAME(Elf,External_Rel)
<span class="lineNum">      82 </span>            : #define Elf_External_Rela       NAME(Elf,External_Rela)
<span class="lineNum">      83 </span>            : #define Elf_External_Dyn        NAME(Elf,External_Dyn)
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : #define elf_core_file_failing_command   NAME(bfd_elf,core_file_failing_command)
<span class="lineNum">      86 </span>            : #define elf_core_file_failing_signal    NAME(bfd_elf,core_file_failing_signal)
<span class="lineNum">      87 </span>            : #define elf_core_file_matches_executable_p \
<span class="lineNum">      88 </span>            :   NAME(bfd_elf,core_file_matches_executable_p)
<span class="lineNum">      89 </span>            : #define elf_core_file_pid               NAME(bfd_elf,core_file_pid)
<span class="lineNum">      90 </span>            : #define elf_object_p                    NAME(bfd_elf,object_p)
<span class="lineNum">      91 </span>            : #define elf_core_file_p                 NAME(bfd_elf,core_file_p)
<span class="lineNum">      92 </span>            : #define elf_get_symtab_upper_bound      NAME(bfd_elf,get_symtab_upper_bound)
<span class="lineNum">      93 </span>            : #define elf_get_dynamic_symtab_upper_bound \
<span class="lineNum">      94 </span>            :   NAME(bfd_elf,get_dynamic_symtab_upper_bound)
<span class="lineNum">      95 </span>            : #define elf_swap_reloc_in               NAME(bfd_elf,swap_reloc_in)
<span class="lineNum">      96 </span>            : #define elf_swap_reloca_in              NAME(bfd_elf,swap_reloca_in)
<span class="lineNum">      97 </span>            : #define elf_swap_reloc_out              NAME(bfd_elf,swap_reloc_out)
<span class="lineNum">      98 </span>            : #define elf_swap_reloca_out             NAME(bfd_elf,swap_reloca_out)
<span class="lineNum">      99 </span>            : #define elf_swap_symbol_in              NAME(bfd_elf,swap_symbol_in)
<span class="lineNum">     100 </span>            : #define elf_swap_symbol_out             NAME(bfd_elf,swap_symbol_out)
<span class="lineNum">     101 </span>            : #define elf_swap_phdr_in                NAME(bfd_elf,swap_phdr_in)
<span class="lineNum">     102 </span>            : #define elf_swap_phdr_out               NAME(bfd_elf,swap_phdr_out)
<span class="lineNum">     103 </span>            : #define elf_swap_dyn_in                 NAME(bfd_elf,swap_dyn_in)
<span class="lineNum">     104 </span>            : #define elf_swap_dyn_out                NAME(bfd_elf,swap_dyn_out)
<span class="lineNum">     105 </span>            : #define elf_get_reloc_upper_bound       NAME(bfd_elf,get_reloc_upper_bound)
<span class="lineNum">     106 </span>            : #define elf_canonicalize_reloc          NAME(bfd_elf,canonicalize_reloc)
<span class="lineNum">     107 </span>            : #define elf_slurp_symbol_table          NAME(bfd_elf,slurp_symbol_table)
<span class="lineNum">     108 </span>            : #define elf_canonicalize_symtab         NAME(bfd_elf,canonicalize_symtab)
<span class="lineNum">     109 </span>            : #define elf_canonicalize_dynamic_symtab \
<span class="lineNum">     110 </span>            :   NAME(bfd_elf,canonicalize_dynamic_symtab)
<span class="lineNum">     111 </span>            : #define elf_get_synthetic_symtab \
<span class="lineNum">     112 </span>            :   NAME(bfd_elf,get_synthetic_symtab)
<span class="lineNum">     113 </span>            : #define elf_make_empty_symbol           NAME(bfd_elf,make_empty_symbol)
<span class="lineNum">     114 </span>            : #define elf_get_symbol_info             NAME(bfd_elf,get_symbol_info)
<span class="lineNum">     115 </span>            : #define elf_get_lineno                  NAME(bfd_elf,get_lineno)
<span class="lineNum">     116 </span>            : #define elf_set_arch_mach               NAME(bfd_elf,set_arch_mach)
<span class="lineNum">     117 </span>            : #define elf_find_nearest_line           NAME(bfd_elf,find_nearest_line)
<span class="lineNum">     118 </span>            : #define elf_sizeof_headers              NAME(bfd_elf,sizeof_headers)
<span class="lineNum">     119 </span>            : #define elf_set_section_contents        NAME(bfd_elf,set_section_contents)
<span class="lineNum">     120 </span>            : #define elf_no_info_to_howto            NAME(bfd_elf,no_info_to_howto)
<span class="lineNum">     121 </span>            : #define elf_no_info_to_howto_rel        NAME(bfd_elf,no_info_to_howto_rel)
<span class="lineNum">     122 </span>            : #define elf_find_section                NAME(bfd_elf,find_section)
<span class="lineNum">     123 </span>            : #define elf_write_shdrs_and_ehdr        NAME(bfd_elf,write_shdrs_and_ehdr)
<span class="lineNum">     124 </span>            : #define elf_write_out_phdrs             NAME(bfd_elf,write_out_phdrs)
<span class="lineNum">     125 </span>            : #define elf_checksum_contents           NAME(bfd_elf,checksum_contents)
<span class="lineNum">     126 </span>            : #define elf_write_relocs                NAME(bfd_elf,write_relocs)
<span class="lineNum">     127 </span>            : #define elf_slurp_reloc_table           NAME(bfd_elf,slurp_reloc_table)
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : #if ARCH_SIZE == 64
<span class="lineNum">     130 </span>            : #define ELF_R_INFO(X,Y) ELF64_R_INFO(X,Y)
<span class="lineNum">     131 </span>            : #define ELF_R_SYM(X)    ELF64_R_SYM(X)
<span class="lineNum">     132 </span>            : #define ELF_R_TYPE(X)   ELF64_R_TYPE(X)
<span class="lineNum">     133 </span>            : #define ELFCLASS        ELFCLASS64
<span class="lineNum">     134 </span>            : #define FILE_ALIGN      8
<span class="lineNum">     135 </span>            : #define LOG_FILE_ALIGN  3
<span class="lineNum">     136 </span>            : #endif
<span class="lineNum">     137 </span>            : #if ARCH_SIZE == 32
<span class="lineNum">     138 </span>            : #define ELF_R_INFO(X,Y) ELF32_R_INFO(X,Y)
<span class="lineNum">     139 </span>            : #define ELF_R_SYM(X)    ELF32_R_SYM(X)
<span class="lineNum">     140 </span>            : #define ELF_R_TYPE(X)   ELF32_R_TYPE(X)
<span class="lineNum">     141 </span>            : #define ELFCLASS        ELFCLASS32
<span class="lineNum">     142 </span>            : #define FILE_ALIGN      4
<span class="lineNum">     143 </span>            : #define LOG_FILE_ALIGN  2
<span class="lineNum">     144 </span>            : #endif
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : #if DEBUG &amp; 2
<span class="lineNum">     147 </span>            : static void elf_debug_section (int, Elf_Internal_Shdr *);
<span class="lineNum">     148 </span>            : #endif
<span class="lineNum">     149 </span>            : #if DEBUG &amp; 1
<span class="lineNum">     150 </span>            : static void elf_debug_file (Elf_Internal_Ehdr *);
<span class="lineNum">     151 </span>            : #endif
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : /* Structure swapping routines */
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : /* Should perhaps use put_offset, put_word, etc.  For now, the two versions
<span class="lineNum">     156 </span>            :    can be handled by explicitly specifying 32 bits or &quot;the long type&quot;.  */
<span class="lineNum">     157 </span>            : #if ARCH_SIZE == 64
<span class="lineNum">     158 </span>            : #define H_PUT_WORD              H_PUT_64
<span class="lineNum">     159 </span>            : #define H_PUT_SIGNED_WORD       H_PUT_S64
<span class="lineNum">     160 </span>            : #define H_GET_WORD              H_GET_64
<span class="lineNum">     161 </span>            : #define H_GET_SIGNED_WORD       H_GET_S64
<span class="lineNum">     162 </span>            : #endif
<span class="lineNum">     163 </span>            : #if ARCH_SIZE == 32
<span class="lineNum">     164 </span>            : #define H_PUT_WORD              H_PUT_32
<span class="lineNum">     165 </span>            : #define H_PUT_SIGNED_WORD       H_PUT_S32
<span class="lineNum">     166 </span>            : #define H_GET_WORD              H_GET_32
<span class="lineNum">     167 </span>            : #define H_GET_SIGNED_WORD       H_GET_S32
<span class="lineNum">     168 </span>            : #endif
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : /* Translate an ELF symbol in external format into an ELF symbol in internal
<span class="lineNum">     171 </span>            :    format.  */
<a name="172"><span class="lineNum">     172 </span>            : </a>
<span class="lineNum">     173 </span>            : bfd_boolean
<span class="lineNum">     174 </span><span class="lineCov">       1112 : elf_swap_symbol_in (bfd *abfd,</span>
<span class="lineNum">     175 </span>            :                     const void *psrc,
<span class="lineNum">     176 </span>            :                     const void *pshn,
<span class="lineNum">     177 </span>            :                     Elf_Internal_Sym *dst)
<span class="lineNum">     178 </span>            : {
<span class="lineNum">     179 </span><span class="lineCov">       1112 :   const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;</span>
<span class="lineNum">     180 </span><span class="lineCov">       1112 :   const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;</span>
<span class="lineNum">     181 </span><span class="lineCov">       1112 :   int signed_vma = get_elf_backend_data (abfd)-&gt;sign_extend_vma;</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">       1112 :   dst-&gt;st_name = H_GET_32 (abfd, src-&gt;st_name);</span>
<span class="lineNum">     184 </span><span class="lineCov">       1112 :   if (signed_vma)</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     dst-&gt;st_value = H_GET_SIGNED_WORD (abfd, src-&gt;st_value);</span>
<span class="lineNum">     186 </span>            :   else
<span class="lineNum">     187 </span><span class="lineCov">       1112 :     dst-&gt;st_value = H_GET_WORD (abfd, src-&gt;st_value);</span>
<span class="lineNum">     188 </span><span class="lineCov">       1112 :   dst-&gt;st_size = H_GET_WORD (abfd, src-&gt;st_size);</span>
<span class="lineNum">     189 </span><span class="lineCov">       1112 :   dst-&gt;st_info = H_GET_8 (abfd, src-&gt;st_info);</span>
<span class="lineNum">     190 </span><span class="lineCov">       1112 :   dst-&gt;st_other = H_GET_8 (abfd, src-&gt;st_other);</span>
<span class="lineNum">     191 </span><span class="lineCov">       1112 :   dst-&gt;st_shndx = H_GET_16 (abfd, src-&gt;st_shndx);</span>
<span class="lineNum">     192 </span><span class="lineCov">       1112 :   if (dst-&gt;st_shndx == (SHN_XINDEX &amp; 0xffff))</span>
<span class="lineNum">     193 </span>            :     {
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       if (shndx == NULL)</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :       dst-&gt;st_shndx = H_GET_32 (abfd, shndx-&gt;est_shndx);</span>
<span class="lineNum">     197 </span>            :     }
<span class="lineNum">     198 </span><span class="lineCov">       1112 :   else if (dst-&gt;st_shndx &gt;= (SHN_LORESERVE &amp; 0xffff))</span>
<span class="lineNum">     199 </span><span class="lineCov">         49 :     dst-&gt;st_shndx += SHN_LORESERVE - (SHN_LORESERVE &amp; 0xffff);</span>
<span class="lineNum">     200 </span><span class="lineCov">       1112 :   dst-&gt;st_target_internal = 0;</span>
<span class="lineNum">     201 </span><span class="lineCov">       1112 :   return TRUE;</span>
<span class="lineNum">     202 </span>            : }
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : /* Translate an ELF symbol in internal format into an ELF symbol in external
<span class="lineNum">     205 </span>            :    format.  */
<a name="206"><span class="lineNum">     206 </span>            : </a>
<span class="lineNum">     207 </span>            : void
<span class="lineNum">     208 </span><span class="lineNoCov">          0 : elf_swap_symbol_out (bfd *abfd,</span>
<span class="lineNum">     209 </span>            :                      const Elf_Internal_Sym *src,
<span class="lineNum">     210 </span>            :                      void *cdst,
<span class="lineNum">     211 </span>            :                      void *shndx)
<span class="lineNum">     212 </span>            : {
<span class="lineNum">     213 </span>            :   unsigned int tmp;
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   Elf_External_Sym *dst = (Elf_External_Sym *) cdst;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;st_name, dst-&gt;st_name);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;st_value, dst-&gt;st_value);</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;st_size, dst-&gt;st_size);</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   H_PUT_8 (abfd, src-&gt;st_info, dst-&gt;st_info);</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   H_PUT_8 (abfd, src-&gt;st_other, dst-&gt;st_other);</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   tmp = src-&gt;st_shndx;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   if (tmp &gt;= (SHN_LORESERVE &amp; 0xffff) &amp;&amp; tmp &lt; SHN_LORESERVE)</span>
<span class="lineNum">     222 </span>            :     {
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :       if (shndx == NULL)</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         abort ();</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :       H_PUT_32 (abfd, tmp, shndx);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :       tmp = SHN_XINDEX &amp; 0xffff;</span>
<span class="lineNum">     227 </span>            :     }
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, tmp, dst-&gt;st_shndx);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : /* Translate an ELF file header in external format into an ELF file header in
<span class="lineNum">     232 </span>            :    internal format.  */
<a name="233"><span class="lineNum">     233 </span>            : </a>
<span class="lineNum">     234 </span>            : static void
<span class="lineNum">     235 </span><span class="lineCov">        114 : elf_swap_ehdr_in (bfd *abfd,</span>
<span class="lineNum">     236 </span>            :                   const Elf_External_Ehdr *src,
<span class="lineNum">     237 </span>            :                   Elf_Internal_Ehdr *dst)
<span class="lineNum">     238 </span>            : {
<span class="lineNum">     239 </span><span class="lineCov">        114 :   int signed_vma = get_elf_backend_data (abfd)-&gt;sign_extend_vma;</span>
<span class="lineNum">     240 </span><span class="lineCov">        114 :   memcpy (dst-&gt;e_ident, src-&gt;e_ident, EI_NIDENT);</span>
<span class="lineNum">     241 </span><span class="lineCov">        114 :   dst-&gt;e_type = H_GET_16 (abfd, src-&gt;e_type);</span>
<span class="lineNum">     242 </span><span class="lineCov">        114 :   dst-&gt;e_machine = H_GET_16 (abfd, src-&gt;e_machine);</span>
<span class="lineNum">     243 </span><span class="lineCov">        114 :   dst-&gt;e_version = H_GET_32 (abfd, src-&gt;e_version);</span>
<span class="lineNum">     244 </span><span class="lineCov">        114 :   if (signed_vma)</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     dst-&gt;e_entry = H_GET_SIGNED_WORD (abfd, src-&gt;e_entry);</span>
<span class="lineNum">     246 </span>            :   else
<span class="lineNum">     247 </span><span class="lineCov">        114 :     dst-&gt;e_entry = H_GET_WORD (abfd, src-&gt;e_entry);</span>
<span class="lineNum">     248 </span><span class="lineCov">        114 :   dst-&gt;e_phoff = H_GET_WORD (abfd, src-&gt;e_phoff);</span>
<span class="lineNum">     249 </span><span class="lineCov">        114 :   dst-&gt;e_shoff = H_GET_WORD (abfd, src-&gt;e_shoff);</span>
<span class="lineNum">     250 </span><span class="lineCov">        114 :   dst-&gt;e_flags = H_GET_32 (abfd, src-&gt;e_flags);</span>
<span class="lineNum">     251 </span><span class="lineCov">        114 :   dst-&gt;e_ehsize = H_GET_16 (abfd, src-&gt;e_ehsize);</span>
<span class="lineNum">     252 </span><span class="lineCov">        114 :   dst-&gt;e_phentsize = H_GET_16 (abfd, src-&gt;e_phentsize);</span>
<span class="lineNum">     253 </span><span class="lineCov">        114 :   dst-&gt;e_phnum = H_GET_16 (abfd, src-&gt;e_phnum);</span>
<span class="lineNum">     254 </span><span class="lineCov">        114 :   dst-&gt;e_shentsize = H_GET_16 (abfd, src-&gt;e_shentsize);</span>
<span class="lineNum">     255 </span><span class="lineCov">        114 :   dst-&gt;e_shnum = H_GET_16 (abfd, src-&gt;e_shnum);</span>
<span class="lineNum">     256 </span><span class="lineCov">        114 :   dst-&gt;e_shstrndx = H_GET_16 (abfd, src-&gt;e_shstrndx);</span>
<span class="lineNum">     257 </span><span class="lineCov">        114 : }</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /* Translate an ELF file header in internal format into an ELF file header in
<span class="lineNum">     260 </span>            :    external format.  */
<a name="261"><span class="lineNum">     261 </span>            : </a>
<span class="lineNum">     262 </span>            : static void
<span class="lineNum">     263 </span><span class="lineNoCov">          0 : elf_swap_ehdr_out (bfd *abfd,</span>
<span class="lineNum">     264 </span>            :                    const Elf_Internal_Ehdr *src,
<span class="lineNum">     265 </span>            :                    Elf_External_Ehdr *dst)
<span class="lineNum">     266 </span>            : {
<span class="lineNum">     267 </span>            :   unsigned int tmp;
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   int signed_vma = get_elf_backend_data (abfd)-&gt;sign_extend_vma;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   memcpy (dst-&gt;e_ident, src-&gt;e_ident, EI_NIDENT);</span>
<span class="lineNum">     270 </span>            :   /* note that all elements of dst are *arrays of unsigned char* already...  */
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, src-&gt;e_type, dst-&gt;e_type);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, src-&gt;e_machine, dst-&gt;e_machine);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;e_version, dst-&gt;e_version);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   if (signed_vma)</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     H_PUT_SIGNED_WORD (abfd, src-&gt;e_entry, dst-&gt;e_entry);</span>
<span class="lineNum">     276 </span>            :   else
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     H_PUT_WORD (abfd, src-&gt;e_entry, dst-&gt;e_entry);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;e_phoff, dst-&gt;e_phoff);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;e_shoff, dst-&gt;e_shoff);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;e_flags, dst-&gt;e_flags);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, src-&gt;e_ehsize, dst-&gt;e_ehsize);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, src-&gt;e_phentsize, dst-&gt;e_phentsize);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   tmp = src-&gt;e_phnum;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   if (tmp &gt; PN_XNUM)</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     tmp = PN_XNUM;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, tmp, dst-&gt;e_phnum);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, src-&gt;e_shentsize, dst-&gt;e_shentsize);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   tmp = src-&gt;e_shnum;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   if (tmp &gt;= (SHN_LORESERVE &amp; 0xffff))</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     tmp = SHN_UNDEF;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, tmp, dst-&gt;e_shnum);</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   tmp = src-&gt;e_shstrndx;</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   if (tmp &gt;= (SHN_LORESERVE &amp; 0xffff))</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     tmp = SHN_XINDEX &amp; 0xffff;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   H_PUT_16 (abfd, tmp, dst-&gt;e_shstrndx);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : /* Translate an ELF section header table entry in external format into an
<span class="lineNum">     299 </span>            :    ELF section header table entry in internal format.  */
<a name="300"><span class="lineNum">     300 </span>            : </a>
<span class="lineNum">     301 </span>            : static void
<span class="lineNum">     302 </span><span class="lineCov">       1200 : elf_swap_shdr_in (bfd *abfd,</span>
<span class="lineNum">     303 </span>            :                   const Elf_External_Shdr *src,
<span class="lineNum">     304 </span>            :                   Elf_Internal_Shdr *dst)
<span class="lineNum">     305 </span>            : {
<span class="lineNum">     306 </span><span class="lineCov">       1200 :   int signed_vma = get_elf_backend_data (abfd)-&gt;sign_extend_vma;</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">       1200 :   dst-&gt;sh_name = H_GET_32 (abfd, src-&gt;sh_name);</span>
<span class="lineNum">     309 </span><span class="lineCov">       1200 :   dst-&gt;sh_type = H_GET_32 (abfd, src-&gt;sh_type);</span>
<span class="lineNum">     310 </span><span class="lineCov">       1200 :   dst-&gt;sh_flags = H_GET_WORD (abfd, src-&gt;sh_flags);</span>
<span class="lineNum">     311 </span><span class="lineCov">       1200 :   if (signed_vma)</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     dst-&gt;sh_addr = H_GET_SIGNED_WORD (abfd, src-&gt;sh_addr);</span>
<span class="lineNum">     313 </span>            :   else
<span class="lineNum">     314 </span><span class="lineCov">       1200 :     dst-&gt;sh_addr = H_GET_WORD (abfd, src-&gt;sh_addr);</span>
<span class="lineNum">     315 </span><span class="lineCov">       1200 :   dst-&gt;sh_offset = H_GET_WORD (abfd, src-&gt;sh_offset);</span>
<span class="lineNum">     316 </span><span class="lineCov">       1200 :   dst-&gt;sh_size = H_GET_WORD (abfd, src-&gt;sh_size);</span>
<span class="lineNum">     317 </span><span class="lineCov">       1200 :   dst-&gt;sh_link = H_GET_32 (abfd, src-&gt;sh_link);</span>
<span class="lineNum">     318 </span><span class="lineCov">       1200 :   dst-&gt;sh_info = H_GET_32 (abfd, src-&gt;sh_info);</span>
<span class="lineNum">     319 </span><span class="lineCov">       1200 :   dst-&gt;sh_addralign = H_GET_WORD (abfd, src-&gt;sh_addralign);</span>
<span class="lineNum">     320 </span><span class="lineCov">       1200 :   dst-&gt;sh_entsize = H_GET_WORD (abfd, src-&gt;sh_entsize);</span>
<span class="lineNum">     321 </span><span class="lineCov">       1200 :   dst-&gt;bfd_section = NULL;</span>
<span class="lineNum">     322 </span><span class="lineCov">       1200 :   dst-&gt;contents = NULL;</span>
<span class="lineNum">     323 </span><span class="lineCov">       1200 : }</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : /* Translate an ELF section header table entry in internal format into an
<span class="lineNum">     326 </span>            :    ELF section header table entry in external format.  */
<a name="327"><span class="lineNum">     327 </span>            : </a>
<span class="lineNum">     328 </span>            : static void
<span class="lineNum">     329 </span><span class="lineNoCov">          0 : elf_swap_shdr_out (bfd *abfd,</span>
<span class="lineNum">     330 </span>            :                    const Elf_Internal_Shdr *src,
<span class="lineNum">     331 </span>            :                    Elf_External_Shdr *dst)
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span>            :   /* note that all elements of dst are *arrays of unsigned char* already...  */
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;sh_name, dst-&gt;sh_name);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;sh_type, dst-&gt;sh_type);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;sh_flags, dst-&gt;sh_flags);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;sh_addr, dst-&gt;sh_addr);</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;sh_offset, dst-&gt;sh_offset);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;sh_size, dst-&gt;sh_size);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;sh_link, dst-&gt;sh_link);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;sh_info, dst-&gt;sh_info);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;sh_addralign, dst-&gt;sh_addralign);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;sh_entsize, dst-&gt;sh_entsize);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : /* Translate an ELF program header table entry in external format into an
<span class="lineNum">     347 </span>            :    ELF program header table entry in internal format.  */
<a name="348"><span class="lineNum">     348 </span>            : </a>
<span class="lineNum">     349 </span>            : void
<span class="lineNum">     350 </span><span class="lineCov">          1 : elf_swap_phdr_in (bfd *abfd,</span>
<span class="lineNum">     351 </span>            :                   const Elf_External_Phdr *src,
<span class="lineNum">     352 </span>            :                   Elf_Internal_Phdr *dst)
<span class="lineNum">     353 </span>            : {
<span class="lineNum">     354 </span><span class="lineCov">          1 :   int signed_vma = get_elf_backend_data (abfd)-&gt;sign_extend_vma;</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineCov">          1 :   dst-&gt;p_type = H_GET_32 (abfd, src-&gt;p_type);</span>
<span class="lineNum">     357 </span><span class="lineCov">          1 :   dst-&gt;p_flags = H_GET_32 (abfd, src-&gt;p_flags);</span>
<span class="lineNum">     358 </span><span class="lineCov">          1 :   dst-&gt;p_offset = H_GET_WORD (abfd, src-&gt;p_offset);</span>
<span class="lineNum">     359 </span><span class="lineCov">          1 :   if (signed_vma)</span>
<span class="lineNum">     360 </span>            :     {
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :       dst-&gt;p_vaddr = H_GET_SIGNED_WORD (abfd, src-&gt;p_vaddr);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :       dst-&gt;p_paddr = H_GET_SIGNED_WORD (abfd, src-&gt;p_paddr);</span>
<span class="lineNum">     363 </span>            :     }
<span class="lineNum">     364 </span>            :   else
<span class="lineNum">     365 </span>            :     {
<span class="lineNum">     366 </span><span class="lineCov">          1 :       dst-&gt;p_vaddr = H_GET_WORD (abfd, src-&gt;p_vaddr);</span>
<span class="lineNum">     367 </span><span class="lineCov">          1 :       dst-&gt;p_paddr = H_GET_WORD (abfd, src-&gt;p_paddr);</span>
<span class="lineNum">     368 </span>            :     }
<span class="lineNum">     369 </span><span class="lineCov">          1 :   dst-&gt;p_filesz = H_GET_WORD (abfd, src-&gt;p_filesz);</span>
<span class="lineNum">     370 </span><span class="lineCov">          1 :   dst-&gt;p_memsz = H_GET_WORD (abfd, src-&gt;p_memsz);</span>
<span class="lineNum">     371 </span><span class="lineCov">          1 :   dst-&gt;p_align = H_GET_WORD (abfd, src-&gt;p_align);</span>
<span class="lineNum">     372 </span><span class="lineCov">          1 : }</span>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<span class="lineNum">     374 </span>            : void
<span class="lineNum">     375 </span><span class="lineNoCov">          0 : elf_swap_phdr_out (bfd *abfd,</span>
<span class="lineNum">     376 </span>            :                    const Elf_Internal_Phdr *src,
<span class="lineNum">     377 </span>            :                    Elf_External_Phdr *dst)
<span class="lineNum">     378 </span>            : {
<span class="lineNum">     379 </span>            :   const struct elf_backend_data *bed;
<span class="lineNum">     380 </span>            :   bfd_vma p_paddr;
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   bed = get_elf_backend_data (abfd);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   p_paddr = bed-&gt;want_p_paddr_set_to_zero ? 0 : src-&gt;p_paddr;</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   /* note that all elements of dst are *arrays of unsigned char* already...  */
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;p_type, dst-&gt;p_type);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;p_offset, dst-&gt;p_offset);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;p_vaddr, dst-&gt;p_vaddr);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, p_paddr, dst-&gt;p_paddr);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;p_filesz, dst-&gt;p_filesz);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;p_memsz, dst-&gt;p_memsz);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   H_PUT_32 (abfd, src-&gt;p_flags, dst-&gt;p_flags);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;p_align, dst-&gt;p_align);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     395 </span>            : 
<a name="396"><span class="lineNum">     396 </span>            : /* Translate an ELF reloc from external format to internal format.  */</a>
<span class="lineNum">     397 </span>            : void
<span class="lineNum">     398 </span><span class="lineNoCov">          0 : elf_swap_reloc_in (bfd *abfd,</span>
<span class="lineNum">     399 </span>            :                    const bfd_byte *s,
<span class="lineNum">     400 </span>            :                    Elf_Internal_Rela *dst)
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   const Elf_External_Rel *src = (const Elf_External_Rel *) s;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   dst-&gt;r_offset = H_GET_WORD (abfd, src-&gt;r_offset);</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   dst-&gt;r_info = H_GET_WORD (abfd, src-&gt;r_info);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   dst-&gt;r_addend = 0;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 : }</span>
<a name="407"><span class="lineNum">     407 </span>            : </a>
<span class="lineNum">     408 </span>            : void
<span class="lineNum">     409 </span><span class="lineCov">        408 : elf_swap_reloca_in (bfd *abfd,</span>
<span class="lineNum">     410 </span>            :                     const bfd_byte *s,
<span class="lineNum">     411 </span>            :                     Elf_Internal_Rela *dst)
<span class="lineNum">     412 </span>            : {
<span class="lineNum">     413 </span><span class="lineCov">        408 :   const Elf_External_Rela *src = (const Elf_External_Rela *) s;</span>
<span class="lineNum">     414 </span><span class="lineCov">        408 :   dst-&gt;r_offset = H_GET_WORD (abfd, src-&gt;r_offset);</span>
<span class="lineNum">     415 </span><span class="lineCov">        408 :   dst-&gt;r_info = H_GET_WORD (abfd, src-&gt;r_info);</span>
<span class="lineNum">     416 </span><span class="lineCov">        408 :   dst-&gt;r_addend = H_GET_SIGNED_WORD (abfd, src-&gt;r_addend);</span>
<span class="lineNum">     417 </span><span class="lineCov">        408 : }</span>
<span class="lineNum">     418 </span>            : 
<a name="419"><span class="lineNum">     419 </span>            : /* Translate an ELF reloc from internal format to external format.  */</a>
<span class="lineNum">     420 </span>            : void
<span class="lineNum">     421 </span><span class="lineNoCov">          0 : elf_swap_reloc_out (bfd *abfd,</span>
<span class="lineNum">     422 </span>            :                     const Elf_Internal_Rela *src,
<span class="lineNum">     423 </span>            :                     bfd_byte *d)
<span class="lineNum">     424 </span>            : {
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   Elf_External_Rel *dst = (Elf_External_Rel *) d;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;r_offset, dst-&gt;r_offset);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;r_info, dst-&gt;r_info);</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 : }</span>
<a name="429"><span class="lineNum">     429 </span>            : </a>
<span class="lineNum">     430 </span>            : void
<span class="lineNum">     431 </span><span class="lineNoCov">          0 : elf_swap_reloca_out (bfd *abfd,</span>
<span class="lineNum">     432 </span>            :                      const Elf_Internal_Rela *src,
<span class="lineNum">     433 </span>            :                      bfd_byte *d)
<span class="lineNum">     434 </span>            : {
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   Elf_External_Rela *dst = (Elf_External_Rela *) d;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;r_offset, dst-&gt;r_offset);</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;r_info, dst-&gt;r_info);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   H_PUT_SIGNED_WORD (abfd, src-&gt;r_addend, dst-&gt;r_addend);</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 : }</span>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<span class="lineNum">     441 </span>            : void
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : elf_swap_dyn_in (bfd *abfd,</span>
<span class="lineNum">     443 </span>            :                  const void *p,
<span class="lineNum">     444 </span>            :                  Elf_Internal_Dyn *dst)
<span class="lineNum">     445 </span>            : {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   const Elf_External_Dyn *src = (const Elf_External_Dyn *) p;</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   dst-&gt;d_tag = H_GET_WORD (abfd, src-&gt;d_tag);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   dst-&gt;d_un.d_val = H_GET_WORD (abfd, src-&gt;d_un.d_val);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : }</span>
<a name="451"><span class="lineNum">     451 </span>            : </a>
<span class="lineNum">     452 </span>            : void
<span class="lineNum">     453 </span><span class="lineNoCov">          0 : elf_swap_dyn_out (bfd *abfd,</span>
<span class="lineNum">     454 </span>            :                   const Elf_Internal_Dyn *src,
<span class="lineNum">     455 </span>            :                   void *p)
<span class="lineNum">     456 </span>            : {
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   Elf_External_Dyn *dst = (Elf_External_Dyn *) p;</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;d_tag, dst-&gt;d_tag);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   H_PUT_WORD (abfd, src-&gt;d_un.d_val, dst-&gt;d_un.d_val);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : /* ELF .o/exec file reading */
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /* Begin processing a given object.
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :    First we validate the file by reading in the ELF header and checking
<span class="lineNum">     468 </span>            :    the magic number.  */
<a name="469"><span class="lineNum">     469 </span>            : </a>
<span class="lineNum">     470 </span>            : static inline bfd_boolean
<span class="lineNum">     471 </span><span class="lineCov">        207 : elf_file_p (Elf_External_Ehdr *x_ehdrp)</span>
<span class="lineNum">     472 </span>            : {
<span class="lineNum">     473 </span><span class="lineCov">        207 :   return ((x_ehdrp-&gt;e_ident[EI_MAG0] == ELFMAG0)</span>
<span class="lineNum">     474 </span><span class="lineCov">        207 :           &amp;&amp; (x_ehdrp-&gt;e_ident[EI_MAG1] == ELFMAG1)</span>
<span class="lineNum">     475 </span><span class="lineCov">        207 :           &amp;&amp; (x_ehdrp-&gt;e_ident[EI_MAG2] == ELFMAG2)</span>
<span class="lineNum">     476 </span><span class="lineCov">        414 :           &amp;&amp; (x_ehdrp-&gt;e_ident[EI_MAG3] == ELFMAG3));</span>
<span class="lineNum">     477 </span>            : }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            : /* Check to see if the file associated with ABFD matches the target vector
<span class="lineNum">     480 </span>            :    that ABFD points to.
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :    Note that we may be called several times with the same ABFD, but different
<span class="lineNum">     483 </span>            :    target vectors, most of which will not match.  We have to avoid leaving
<span class="lineNum">     484 </span>            :    any side effects in ABFD, or any data it points to (like tdata), if the
<span class="lineNum">     485 </span>            :    file does not match the target vector.  */
<a name="486"><span class="lineNum">     486 </span>            : </a>
<span class="lineNum">     487 </span>            : const bfd_target *
<span class="lineNum">     488 </span><span class="lineCov">        207 : elf_object_p (bfd *abfd)</span>
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span>            :   Elf_External_Ehdr x_ehdr;     /* Elf file header, external form */
<span class="lineNum">     491 </span>            :   Elf_Internal_Ehdr *i_ehdrp;   /* Elf file header, internal form */
<span class="lineNum">     492 </span>            :   Elf_External_Shdr x_shdr;     /* Section header table entry, external form */
<span class="lineNum">     493 </span>            :   Elf_Internal_Shdr i_shdr;
<span class="lineNum">     494 </span>            :   Elf_Internal_Shdr *i_shdrp;   /* Section header table, internal form */
<span class="lineNum">     495 </span>            :   unsigned int shindex;
<span class="lineNum">     496 </span>            :   const struct elf_backend_data *ebd;
<span class="lineNum">     497 </span>            :   asection *s;
<span class="lineNum">     498 </span>            :   bfd_size_type amt;
<span class="lineNum">     499 </span>            :   const bfd_target *target;
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :   /* Read in the ELF header in external format.  */
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineCov">        207 :   if (bfd_bread (&amp;x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))</span>
<span class="lineNum">     504 </span>            :     {
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :       if (bfd_get_error () != bfd_error_system_call)</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :         goto got_wrong_format_error;</span>
<span class="lineNum">     507 </span>            :       else
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     509 </span>            :     }
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :   /* Now check to see if we have a valid ELF file, and one that BFD can
<span class="lineNum">     512 </span>            :      make use of.  The magic number must match, the address size ('class')
<span class="lineNum">     513 </span>            :      and byte-swapping must match our XVEC entry, and it must have a
<span class="lineNum">     514 </span>            :      section header table (FIXME: See comments re sections at top of this
<span class="lineNum">     515 </span>            :      file).  */
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineCov">        207 :   if (! elf_file_p (&amp;x_ehdr)</span>
<span class="lineNum">     518 </span><span class="lineCov">        207 :       || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT</span>
<span class="lineNum">     519 </span><span class="lineCov">        207 :       || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)</span>
<span class="lineNum">     520 </span>            :     goto got_wrong_format_error;
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :   /* Check that file's byte order matches xvec's */
<span class="lineNum">     523 </span><span class="lineCov">        129 :   switch (x_ehdr.e_ident[EI_DATA])</span>
<span class="lineNum">     524 </span>            :     {
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     case ELFDATA2MSB:           /* Big-endian */</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       if (! bfd_header_big_endian (abfd))</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         goto got_wrong_format_error;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     529 </span><span class="lineCov">        129 :     case ELFDATA2LSB:           /* Little-endian */</span>
<span class="lineNum">     530 </span><span class="lineCov">        129 :       if (! bfd_header_little_endian (abfd))</span>
<span class="lineNum">     531 </span><span class="lineCov">         15 :         goto got_wrong_format_error;</span>
<span class="lineNum">     532 </span><span class="lineCov">        114 :       break;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     case ELFDATANONE:           /* No data encoding specified */</span>
<span class="lineNum">     534 </span>            :     default:                    /* Unknown data encoding specified */
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       goto got_wrong_format_error;</span>
<span class="lineNum">     536 </span>            :     }
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">        114 :   target = abfd-&gt;xvec;</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :   /* Allocate an instance of the elf_obj_tdata structure and hook it up to
<span class="lineNum">     541 </span>            :      the tdata pointer in the bfd.  */
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineCov">        114 :   if (! (*target-&gt;_bfd_set_format[bfd_object]) (abfd))</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     goto got_no_match;</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   /* Now that we know the byte order, swap in the rest of the header */
<span class="lineNum">     547 </span><span class="lineCov">        114 :   i_ehdrp = elf_elfheader (abfd);</span>
<span class="lineNum">     548 </span><span class="lineCov">        114 :   elf_swap_ehdr_in (abfd, &amp;x_ehdr, i_ehdrp);</span>
<span class="lineNum">     549 </span>            : #if DEBUG &amp; 1
<span class="lineNum">     550 </span>            :   elf_debug_file (i_ehdrp);
<span class="lineNum">     551 </span>            : #endif
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :   /* Reject ET_CORE (header indicates core file, not object file) */
<span class="lineNum">     554 </span><span class="lineCov">        114 :   if (i_ehdrp-&gt;e_type == ET_CORE)</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     goto got_wrong_format_error;</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            :   /* If this is a relocatable file and there is no section header
<span class="lineNum">     558 </span>            :      table, then we're hosed.  */
<span class="lineNum">     559 </span><span class="lineCov">        114 :   if (i_ehdrp-&gt;e_shoff == 0 &amp;&amp; i_ehdrp-&gt;e_type == ET_REL)</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     goto got_wrong_format_error;</span>
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :   /* As a simple sanity check, verify that what BFD thinks is the
<span class="lineNum">     563 </span>            :      size of each section header table entry actually matches the size
<span class="lineNum">     564 </span>            :      recorded in the file, but only if there are any sections.  */
<span class="lineNum">     565 </span><span class="lineCov">        114 :   if (i_ehdrp-&gt;e_shentsize != sizeof (x_shdr) &amp;&amp; i_ehdrp-&gt;e_shnum != 0)</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     goto got_wrong_format_error;</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :   /* Further sanity check.  */
<span class="lineNum">     569 </span><span class="lineCov">        114 :   if (i_ehdrp-&gt;e_shoff == 0 &amp;&amp; i_ehdrp-&gt;e_shnum != 0)</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     goto got_wrong_format_error;</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineCov">        114 :   ebd = get_elf_backend_data (abfd);</span>
<span class="lineNum">     573 </span><span class="lineCov">        114 :   if (ebd-&gt;s-&gt;arch_size != ARCH_SIZE)</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     goto got_wrong_format_error;</span>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :   /* Check that the ELF e_machine field matches what this particular
<span class="lineNum">     577 </span>            :      BFD format expects.  */
<span class="lineNum">     578 </span><span class="lineCov">        114 :   if (ebd-&gt;elf_machine_code != i_ehdrp-&gt;e_machine</span>
<span class="lineNum">     579 </span><span class="lineCov">         50 :       &amp;&amp; (ebd-&gt;elf_machine_alt1 == 0</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :           || i_ehdrp-&gt;e_machine != ebd-&gt;elf_machine_alt1)</span>
<span class="lineNum">     581 </span><span class="lineCov">         50 :       &amp;&amp; (ebd-&gt;elf_machine_alt2 == 0</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :           || i_ehdrp-&gt;e_machine != ebd-&gt;elf_machine_alt2)</span>
<span class="lineNum">     583 </span><span class="lineCov">         50 :       &amp;&amp; ebd-&gt;elf_machine_code != EM_NONE)</span>
<span class="lineNum">     584 </span><span class="lineCov">         34 :     goto got_wrong_format_error;</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span><span class="lineCov">         80 :   if (i_ehdrp-&gt;e_type == ET_EXEC)</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     abfd-&gt;flags |= EXEC_P;</span>
<span class="lineNum">     588 </span><span class="lineCov">         80 :   else if (i_ehdrp-&gt;e_type == ET_DYN)</span>
<span class="lineNum">     589 </span><span class="lineCov">         11 :     abfd-&gt;flags |= DYNAMIC;</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineCov">         80 :   if (i_ehdrp-&gt;e_phnum &gt; 0)</span>
<span class="lineNum">     592 </span><span class="lineCov">          1 :     abfd-&gt;flags |= D_PAGED;</span>
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">         80 :   if (! bfd_default_set_arch_mach (abfd, ebd-&gt;arch, 0))</span>
<span class="lineNum">     595 </span>            :     {
<span class="lineNum">     596 </span>            :       /* It's OK if this fails for the generic target.  */
<span class="lineNum">     597 </span><span class="lineCov">         16 :       if (ebd-&gt;elf_machine_code != EM_NONE)</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     599 </span>            :     }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">         80 :   if (ebd-&gt;elf_machine_code != EM_NONE</span>
<span class="lineNum">     602 </span><span class="lineCov">         64 :       &amp;&amp; i_ehdrp-&gt;e_ident[EI_OSABI] != ebd-&gt;elf_osabi</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :       &amp;&amp; ebd-&gt;elf_osabi != ELFOSABI_NONE)</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     goto got_wrong_format_error;</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineCov">         80 :   if (i_ehdrp-&gt;e_shoff != 0)</span>
<span class="lineNum">     607 </span>            :     {
<span class="lineNum">     608 </span><span class="lineCov">         80 :       file_ptr where = (file_ptr) i_ehdrp-&gt;e_shoff;</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            :       /* Seek to the section header table in the file.  */
<span class="lineNum">     611 </span><span class="lineCov">         80 :       if (bfd_seek (abfd, where, SEEK_SET) != 0)</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :       /* Read the first section header at index 0, and convert to internal
<span class="lineNum">     615 </span>            :          form.  */
<span class="lineNum">     616 </span><span class="lineCov">         80 :       if (bfd_bread (&amp;x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     618 </span><span class="lineCov">         80 :       elf_swap_shdr_in (abfd, &amp;x_shdr, &amp;i_shdr);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :       /* If the section count is zero, the actual count is in the first
<span class="lineNum">     621 </span>            :          section header.  */
<span class="lineNum">     622 </span><span class="lineCov">         80 :       if (i_ehdrp-&gt;e_shnum == SHN_UNDEF)</span>
<span class="lineNum">     623 </span>            :         {
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :           i_ehdrp-&gt;e_shnum = i_shdr.sh_size;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :           if (i_ehdrp-&gt;e_shnum &gt;= SHN_LORESERVE</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :               || i_ehdrp-&gt;e_shnum != i_shdr.sh_size</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :               || i_ehdrp-&gt;e_shnum  == 0)</span>
<span class="lineNum">     628 </span>            :             goto got_wrong_format_error;
<span class="lineNum">     629 </span>            :         }
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :       /* And similarly for the string table index.  */
<span class="lineNum">     632 </span><span class="lineCov">         80 :       if (i_ehdrp-&gt;e_shstrndx == (SHN_XINDEX &amp; 0xffff))</span>
<span class="lineNum">     633 </span>            :         {
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :           i_ehdrp-&gt;e_shstrndx = i_shdr.sh_link;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :           if (i_ehdrp-&gt;e_shstrndx != i_shdr.sh_link)</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :             goto got_wrong_format_error;</span>
<span class="lineNum">     637 </span>            :         }
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :       /* And program headers.  */
<span class="lineNum">     640 </span><span class="lineCov">         80 :       if (i_ehdrp-&gt;e_phnum == PN_XNUM &amp;&amp; i_shdr.sh_info != 0)</span>
<span class="lineNum">     641 </span>            :         {
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :           i_ehdrp-&gt;e_phnum = i_shdr.sh_info;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :           if (i_ehdrp-&gt;e_phnum != i_shdr.sh_info)</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :             goto got_wrong_format_error;</span>
<span class="lineNum">     645 </span>            :         }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            :       /* Sanity check that we can read all of the section headers.
<span class="lineNum">     648 </span>            :          It ought to be good enough to just read the last one.  */
<span class="lineNum">     649 </span><span class="lineCov">         80 :       if (i_ehdrp-&gt;e_shnum != 1)</span>
<span class="lineNum">     650 </span>            :         {
<span class="lineNum">     651 </span>            :           /* Check that we don't have a totally silly number of sections.  */
<span class="lineNum">     652 </span><span class="lineCov">         80 :           if (i_ehdrp-&gt;e_shnum &gt; (unsigned int) -1 / sizeof (x_shdr)</span>
<span class="lineNum">     653 </span><span class="lineCov">         80 :               || i_ehdrp-&gt;e_shnum &gt; (unsigned int) -1 / sizeof (i_shdr))</span>
<span class="lineNum">     654 </span>            :             goto got_wrong_format_error;
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span><span class="lineCov">         80 :           where += (i_ehdrp-&gt;e_shnum - 1) * sizeof (x_shdr);</span>
<span class="lineNum">     657 </span><span class="lineCov">         80 :           if ((bfd_size_type) where &lt;= i_ehdrp-&gt;e_shoff)</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :             goto got_wrong_format_error;</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineCov">         80 :           if (bfd_seek (abfd, where, SEEK_SET) != 0)</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :             goto got_no_match;</span>
<span class="lineNum">     662 </span><span class="lineCov">         80 :           if (bfd_bread (&amp;x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :             goto got_no_match;</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            :           /* Back to where we were.  */
<span class="lineNum">     666 </span><span class="lineCov">         80 :           where = i_ehdrp-&gt;e_shoff + sizeof (x_shdr);</span>
<span class="lineNum">     667 </span><span class="lineCov">         80 :           if (bfd_seek (abfd, where, SEEK_SET) != 0)</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :             goto got_no_match;</span>
<span class="lineNum">     669 </span>            :         }
<span class="lineNum">     670 </span>            :     }
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :   /* Allocate space for a copy of the section header table in
<span class="lineNum">     673 </span>            :      internal form.  */
<span class="lineNum">     674 </span><span class="lineCov">         80 :   if (i_ehdrp-&gt;e_shnum != 0)</span>
<span class="lineNum">     675 </span>            :     {
<span class="lineNum">     676 </span>            :       Elf_Internal_Shdr *shdrp;
<span class="lineNum">     677 </span>            :       unsigned int num_sec;
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : #ifndef BFD64
<span class="lineNum">     680 </span>            :       if (i_ehdrp-&gt;e_shnum &gt; ((bfd_size_type) -1) / sizeof (*i_shdrp))
<span class="lineNum">     681 </span>            :         goto got_wrong_format_error;
<span class="lineNum">     682 </span>            : #endif
<span class="lineNum">     683 </span><span class="lineCov">         80 :       amt = sizeof (*i_shdrp) * i_ehdrp-&gt;e_shnum;</span>
<span class="lineNum">     684 </span><span class="lineCov">         80 :       i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);</span>
<span class="lineNum">     685 </span><span class="lineCov">         80 :       if (!i_shdrp)</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     687 </span><span class="lineCov">         80 :       num_sec = i_ehdrp-&gt;e_shnum;</span>
<span class="lineNum">     688 </span><span class="lineCov">         80 :       elf_numsections (abfd) = num_sec;</span>
<span class="lineNum">     689 </span><span class="lineCov">         80 :       amt = sizeof (i_shdrp) * num_sec;</span>
<span class="lineNum">     690 </span><span class="lineCov">         80 :       elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);</span>
<span class="lineNum">     691 </span><span class="lineCov">         80 :       if (!elf_elfsections (abfd))</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineCov">         80 :       memcpy (i_shdrp, &amp;i_shdr, sizeof (*i_shdrp));</span>
<span class="lineNum">     695 </span><span class="lineCov">       1280 :       for (shdrp = i_shdrp, shindex = 0; shindex &lt; num_sec; shindex++)</span>
<span class="lineNum">     696 </span><span class="lineCov">       1200 :         elf_elfsections (abfd)[shindex] = shdrp++;</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :       /* Read in the rest of the section header table and convert it
<span class="lineNum">     699 </span>            :          to internal form.  */
<span class="lineNum">     700 </span><span class="lineCov">       1200 :       for (shindex = 1; shindex &lt; i_ehdrp-&gt;e_shnum; shindex++)</span>
<span class="lineNum">     701 </span>            :         {
<span class="lineNum">     702 </span><span class="lineCov">       1120 :           if (bfd_bread (&amp;x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :             goto got_no_match;</span>
<span class="lineNum">     704 </span><span class="lineCov">       1120 :           elf_swap_shdr_in (abfd, &amp;x_shdr, i_shdrp + shindex);</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :           /* Sanity check sh_link and sh_info.  */
<span class="lineNum">     707 </span><span class="lineCov">       1120 :           if (i_shdrp[shindex].sh_link &gt;= num_sec)</span>
<span class="lineNum">     708 </span>            :             {
<span class="lineNum">     709 </span>            :               /* PR 10478: Accept Solaris binaries with a sh_link
<span class="lineNum">     710 </span>            :                  field set to SHN_BEFORE or SHN_AFTER.  */
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :               switch (ebd-&gt;elf_machine_code)</span>
<span class="lineNum">     712 </span>            :                 {
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :                 case EM_386:</span>
<span class="lineNum">     714 </span>            :                 case EM_IAMCU:
<span class="lineNum">     715 </span>            :                 case EM_X86_64:
<span class="lineNum">     716 </span>            :                 case EM_OLD_SPARCV9:
<span class="lineNum">     717 </span>            :                 case EM_SPARC32PLUS:
<span class="lineNum">     718 </span>            :                 case EM_SPARCV9:
<span class="lineNum">     719 </span>            :                 case EM_SPARC:
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :                   if (i_shdrp[shindex].sh_link == (SHN_LORESERVE &amp; 0xffff) /* SHN_BEFORE */</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :                       || i_shdrp[shindex].sh_link == ((SHN_LORESERVE + 1) &amp; 0xffff) /* SHN_AFTER */)</span>
<span class="lineNum">     722 </span>            :                     break;
<span class="lineNum">     723 </span>            :                   /* Otherwise fall through.  */
<span class="lineNum">     724 </span>            :                 default:
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :                   goto got_wrong_format_error;</span>
<span class="lineNum">     726 </span>            :                 }
<span class="lineNum">     727 </span><span class="lineCov">       1120 :             }</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineCov">       1120 :           if (((i_shdrp[shindex].sh_flags &amp; SHF_INFO_LINK)</span>
<span class="lineNum">     730 </span><span class="lineCov">        882 :                || i_shdrp[shindex].sh_type == SHT_RELA</span>
<span class="lineNum">     731 </span><span class="lineCov">        874 :                || i_shdrp[shindex].sh_type == SHT_REL)</span>
<span class="lineNum">     732 </span><span class="lineCov">        246 :               &amp;&amp; i_shdrp[shindex].sh_info &gt;= num_sec)</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :             goto got_wrong_format_error;</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :           /* If the section is loaded, but not page aligned, clear
<span class="lineNum">     736 </span>            :              D_PAGED.  */
<span class="lineNum">     737 </span><span class="lineCov">       1120 :           if (i_shdrp[shindex].sh_size != 0</span>
<span class="lineNum">     738 </span><span class="lineCov">        953 :               &amp;&amp; (i_shdrp[shindex].sh_flags &amp; SHF_ALLOC) != 0</span>
<span class="lineNum">     739 </span><span class="lineCov">        399 :               &amp;&amp; i_shdrp[shindex].sh_type != SHT_NOBITS</span>
<span class="lineNum">     740 </span><span class="lineCov">        652 :               &amp;&amp; (((i_shdrp[shindex].sh_addr - i_shdrp[shindex].sh_offset)</span>
<span class="lineNum">     741 </span><span class="lineCov">        326 :                    % ebd-&gt;minpagesize)</span>
<span class="lineNum">     742 </span>            :                   != 0))
<span class="lineNum">     743 </span><span class="lineCov">        261 :             abfd-&gt;flags &amp;= ~D_PAGED;</span>
<span class="lineNum">     744 </span>            :         }
<span class="lineNum">     745 </span>            :     }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :   /* A further sanity check.  */
<span class="lineNum">     748 </span><span class="lineCov">         80 :   if (i_ehdrp-&gt;e_shnum != 0)</span>
<span class="lineNum">     749 </span>            :     {
<span class="lineNum">     750 </span><span class="lineCov">         80 :       if (i_ehdrp-&gt;e_shstrndx &gt;= elf_numsections (abfd))</span>
<span class="lineNum">     751 </span>            :         {
<span class="lineNum">     752 </span>            :           /* PR 2257:
<span class="lineNum">     753 </span>            :              We used to just goto got_wrong_format_error here
<span class="lineNum">     754 </span>            :              but there are binaries in existance for which this test
<span class="lineNum">     755 </span>            :              will prevent the binutils from working with them at all.
<span class="lineNum">     756 </span>            :              So we are kind, and reset the string index value to 0
<span class="lineNum">     757 </span>            :              so that at least some processing can be done.  */
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :           i_ehdrp-&gt;e_shstrndx = SHN_UNDEF;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :           _bfd_error_handler (_(&quot;warning: %s has a corrupt string table index - ignoring&quot;),</span>
<span class="lineNum">     760 </span>            :                               abfd-&gt;filename);
<span class="lineNum">     761 </span>            :         }
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   else if (i_ehdrp-&gt;e_shstrndx != SHN_UNDEF)</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     goto got_wrong_format_error;</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :   /* Read in the program headers.  */
<span class="lineNum">     767 </span><span class="lineCov">         80 :   if (i_ehdrp-&gt;e_phnum == 0)</span>
<span class="lineNum">     768 </span><span class="lineCov">         79 :     elf_tdata (abfd)-&gt;phdr = NULL;</span>
<span class="lineNum">     769 </span>            :   else
<span class="lineNum">     770 </span>            :     {
<span class="lineNum">     771 </span>            :       Elf_Internal_Phdr *i_phdr;
<span class="lineNum">     772 </span>            :       unsigned int i;
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : #ifndef BFD64
<span class="lineNum">     775 </span>            :       if (i_ehdrp-&gt;e_phnum &gt; ((bfd_size_type) -1) / sizeof (*i_phdr))
<span class="lineNum">     776 </span>            :         goto got_wrong_format_error;
<span class="lineNum">     777 </span>            : #endif
<span class="lineNum">     778 </span><span class="lineCov">          1 :       amt = i_ehdrp-&gt;e_phnum * sizeof (*i_phdr);</span>
<span class="lineNum">     779 </span><span class="lineCov">          1 :       elf_tdata (abfd)-&gt;phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);</span>
<span class="lineNum">     780 </span><span class="lineCov">          1 :       if (elf_tdata (abfd)-&gt;phdr == NULL)</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     782 </span><span class="lineCov">          1 :       if (bfd_seek (abfd, (file_ptr) i_ehdrp-&gt;e_phoff, SEEK_SET) != 0)</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :         goto got_no_match;</span>
<span class="lineNum">     784 </span><span class="lineCov">          1 :       i_phdr = elf_tdata (abfd)-&gt;phdr;</span>
<span class="lineNum">     785 </span><span class="lineCov">          2 :       for (i = 0; i &lt; i_ehdrp-&gt;e_phnum; i++, i_phdr++)</span>
<span class="lineNum">     786 </span>            :         {
<span class="lineNum">     787 </span>            :           Elf_External_Phdr x_phdr;
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineCov">          1 :           if (bfd_bread (&amp;x_phdr, sizeof x_phdr, abfd) != sizeof x_phdr)</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :             goto got_no_match;</span>
<span class="lineNum">     791 </span><span class="lineCov">          1 :           elf_swap_phdr_in (abfd, &amp;x_phdr, i_phdr);</span>
<span class="lineNum">     792 </span>            :         }
<span class="lineNum">     793 </span>            :     }
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineCov">         80 :   if (i_ehdrp-&gt;e_shstrndx != 0 &amp;&amp; i_ehdrp-&gt;e_shoff != 0)</span>
<span class="lineNum">     796 </span>            :     {
<span class="lineNum">     797 </span>            :       unsigned int num_sec;
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :       /* Once all of the section headers have been read and converted, we
<span class="lineNum">     800 </span>            :          can start processing them.  Note that the first section header is
<span class="lineNum">     801 </span>            :          a dummy placeholder entry, so we ignore it.  */
<span class="lineNum">     802 </span><span class="lineCov">         80 :       num_sec = elf_numsections (abfd);</span>
<span class="lineNum">     803 </span><span class="lineCov">        944 :       for (shindex = 1; shindex &lt; num_sec; shindex++)</span>
<span class="lineNum">     804 </span><span class="lineCov">        887 :         if (!bfd_section_from_shdr (abfd, shindex))</span>
<span class="lineNum">     805 </span><span class="lineCov">         23 :           goto got_no_match;</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :       /* Set up ELF sections for SHF_GROUP and SHF_LINK_ORDER.  */
<span class="lineNum">     808 </span><span class="lineCov">         57 :       if (! _bfd_elf_setup_sections (abfd))</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         goto got_wrong_format_error;</span>
<span class="lineNum">     810 </span>            :     }
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :   /* Let the backend double check the format and override global
<span class="lineNum">     813 </span>            :      information.  */
<span class="lineNum">     814 </span><span class="lineCov">         57 :   if (ebd-&gt;elf_backend_object_p)</span>
<span class="lineNum">     815 </span>            :     {
<span class="lineNum">     816 </span><span class="lineCov">         42 :       if (! (*ebd-&gt;elf_backend_object_p) (abfd))</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         goto got_wrong_format_error;</span>
<span class="lineNum">     818 </span>            :     }
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :   /* Remember the entry point specified in the ELF file header.  */
<span class="lineNum">     821 </span><span class="lineCov">         57 :   bfd_set_start_address (abfd, i_ehdrp-&gt;e_entry);</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :   /* If we have created any reloc sections that are associated with
<span class="lineNum">     824 </span>            :      debugging sections, mark the reloc sections as debugging as well.  */
<span class="lineNum">     825 </span><span class="lineCov">        536 :   for (s = abfd-&gt;sections; s != NULL; s = s-&gt;next)</span>
<span class="lineNum">     826 </span>            :     {
<span class="lineNum">     827 </span><span class="lineCov">        479 :       if ((elf_section_data (s)-&gt;this_hdr.sh_type == SHT_REL</span>
<span class="lineNum">     828 </span><span class="lineCov">        479 :            || elf_section_data (s)-&gt;this_hdr.sh_type == SHT_RELA)</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :           &amp;&amp; elf_section_data (s)-&gt;this_hdr.sh_info &gt; 0)</span>
<span class="lineNum">     830 </span>            :         {
<span class="lineNum">     831 </span>            :           unsigned long targ_index;
<span class="lineNum">     832 </span>            :           asection *targ_sec;
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :           targ_index = elf_section_data (s)-&gt;this_hdr.sh_info;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :           targ_sec = bfd_section_from_elf_index (abfd, targ_index);</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :           if (targ_sec != NULL</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :               &amp;&amp; (targ_sec-&gt;flags &amp; SEC_DEBUGGING) != 0)</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :             s-&gt;flags |= SEC_DEBUGGING;</span>
<span class="lineNum">     839 </span>            :         }
<span class="lineNum">     840 </span>            :     }
<span class="lineNum">     841 </span><span class="lineCov">         57 :   return target;</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span><span class="lineCov">         78 :  got_wrong_format_error:</span>
<span class="lineNum">     844 </span><span class="lineCov">        127 :   bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineCov">        150 :  got_no_match:</span>
<span class="lineNum">     847 </span><span class="lineCov">        150 :   return NULL;</span>
<span class="lineNum">     848 </span>            : }
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            : /* ELF .o/exec file writing */
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            : /* Write out the relocs.  */
<a name="853"><span class="lineNum">     853 </span>            : </a>
<span class="lineNum">     854 </span>            : void
<span class="lineNum">     855 </span><span class="lineNoCov">          0 : elf_write_relocs (bfd *abfd, asection *sec, void *data)</span>
<span class="lineNum">     856 </span>            : {
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   bfd_boolean *failedp = (bfd_boolean *) data;</span>
<span class="lineNum">     858 </span>            :   Elf_Internal_Shdr *rela_hdr;
<span class="lineNum">     859 </span>            :   bfd_vma addr_offset;
<span class="lineNum">     860 </span>            :   void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
<span class="lineNum">     861 </span>            :   size_t extsize;
<span class="lineNum">     862 </span>            :   bfd_byte *dst_rela;
<span class="lineNum">     863 </span>            :   unsigned int idx;
<span class="lineNum">     864 </span>            :   asymbol *last_sym;
<span class="lineNum">     865 </span>            :   int last_sym_idx;
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :   /* If we have already failed, don't do anything.  */
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   if (*failedp)</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   if ((sec-&gt;flags &amp; SEC_RELOC) == 0)</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :   /* The linker backend writes the relocs out itself, and sets the
<span class="lineNum">     875 </span>            :      reloc_count field to zero to inhibit writing them here.  Also,
<span class="lineNum">     876 </span>            :      sometimes the SEC_RELOC flag gets set even when there aren't any
<span class="lineNum">     877 </span>            :      relocs.  */
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :   if (sec-&gt;reloc_count == 0)</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :   /* If we have opened an existing file for update, reloc_count may be
<span class="lineNum">     882 </span>            :      set even though we are not linking.  In that case we have nothing
<span class="lineNum">     883 </span>            :      to do.  */
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :   if (sec-&gt;orelocation == NULL)</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :   rela_hdr = elf_section_data (sec)-&gt;rela.hdr;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   if (rela_hdr == NULL)</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     rela_hdr = elf_section_data (sec)-&gt;rel.hdr;</span>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :   rela_hdr-&gt;sh_size = rela_hdr-&gt;sh_entsize * sec-&gt;reloc_count;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   rela_hdr-&gt;contents = (unsigned char *) bfd_alloc (abfd, rela_hdr-&gt;sh_size);</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   if (rela_hdr-&gt;contents == NULL)</span>
<span class="lineNum">     894 </span>            :     {
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :       *failedp = TRUE;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     897 </span>            :     }
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :   /* Figure out whether the relocations are RELA or REL relocations.  */
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   if (rela_hdr-&gt;sh_type == SHT_RELA)</span>
<span class="lineNum">     901 </span>            :     {
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :       swap_out = elf_swap_reloca_out;</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       extsize = sizeof (Elf_External_Rela);</span>
<span class="lineNum">     904 </span>            :     }
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   else if (rela_hdr-&gt;sh_type == SHT_REL)</span>
<span class="lineNum">     906 </span>            :     {
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :       swap_out = elf_swap_reloc_out;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :       extsize = sizeof (Elf_External_Rel);</span>
<span class="lineNum">     909 </span>            :     }
<span class="lineNum">     910 </span>            :   else
<span class="lineNum">     911 </span>            :     /* Every relocation section should be either an SHT_RELA or an
<span class="lineNum">     912 </span>            :        SHT_REL section.  */
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     abort ();</span>
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            :   /* The address of an ELF reloc is section relative for an object
<span class="lineNum">     916 </span>            :      file, and absolute for an executable file or shared library.
<span class="lineNum">     917 </span>            :      The address of a BFD reloc is always section relative.  */
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   addr_offset = 0;</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   if ((abfd-&gt;flags &amp; (EXEC_P | DYNAMIC)) != 0)</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :     addr_offset = sec-&gt;vma;</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :   /* orelocation has the data, reloc_count has the count...  */
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   last_sym = 0;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   last_sym_idx = 0;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   dst_rela = rela_hdr-&gt;contents;</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :   for (idx = 0; idx &lt; sec-&gt;reloc_count; idx++, dst_rela += extsize)</span>
<span class="lineNum">     928 </span>            :     {
<span class="lineNum">     929 </span>            :       Elf_Internal_Rela src_rela;
<span class="lineNum">     930 </span>            :       arelent *ptr;
<span class="lineNum">     931 </span>            :       asymbol *sym;
<span class="lineNum">     932 </span>            :       int n;
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :       ptr = sec-&gt;orelocation[idx];</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :       sym = *ptr-&gt;sym_ptr_ptr;</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :       if (sym == last_sym)</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         n = last_sym_idx;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       else if (bfd_is_abs_section (sym-&gt;section) &amp;&amp; sym-&gt;value == 0)</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         n = STN_UNDEF;</span>
<span class="lineNum">     940 </span>            :       else
<span class="lineNum">     941 </span>            :         {
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :           last_sym = sym;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :           n = _bfd_elf_symbol_from_bfd_symbol (abfd, &amp;sym);</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :           if (n &lt; 0)</span>
<span class="lineNum">     945 </span>            :             {
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :               *failedp = TRUE;</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">     948 </span>            :             }
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :           last_sym_idx = n;</span>
<span class="lineNum">     950 </span>            :         }
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       if ((*ptr-&gt;sym_ptr_ptr)-&gt;the_bfd != NULL</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :           &amp;&amp; (*ptr-&gt;sym_ptr_ptr)-&gt;the_bfd-&gt;xvec != abfd-&gt;xvec</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :           &amp;&amp; ! _bfd_elf_validate_reloc (abfd, ptr))</span>
<span class="lineNum">     955 </span>            :         {
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :           *failedp = TRUE;</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">     958 </span>            :         }
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       src_rela.r_offset = ptr-&gt;address + addr_offset;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :       src_rela.r_info = ELF_R_INFO (n, ptr-&gt;howto-&gt;type);</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :       src_rela.r_addend = ptr-&gt;addend;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :       (*swap_out) (abfd, &amp;src_rela, dst_rela);</span>
<span class="lineNum">     964 </span>            :     }
<span class="lineNum">     965 </span>            : }
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            : /* Write out the program headers.  */
<a name="968"><span class="lineNum">     968 </span>            : </a>
<span class="lineNum">     969 </span>            : int
<span class="lineNum">     970 </span><span class="lineNoCov">          0 : elf_write_out_phdrs (bfd *abfd,</span>
<span class="lineNum">     971 </span>            :                      const Elf_Internal_Phdr *phdr,
<span class="lineNum">     972 </span>            :                      unsigned int count)
<span class="lineNum">     973 </span>            : {
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   while (count--)</span>
<span class="lineNum">     975 </span>            :     {
<span class="lineNum">     976 </span>            :       Elf_External_Phdr extphdr;
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       elf_swap_phdr_out (abfd, phdr, &amp;extphdr);</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :       if (bfd_bwrite (&amp;extphdr, sizeof (Elf_External_Phdr), abfd)</span>
<span class="lineNum">     980 </span>            :           != sizeof (Elf_External_Phdr))
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :       phdr++;</span>
<span class="lineNum">     983 </span>            :     }
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     985 </span>            : }
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            : /* Write out the section headers and the ELF file header.  */
<a name="988"><span class="lineNum">     988 </span>            : </a>
<span class="lineNum">     989 </span>            : bfd_boolean
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : elf_write_shdrs_and_ehdr (bfd *abfd)</span>
<span class="lineNum">     991 </span>            : {
<span class="lineNum">     992 </span>            :   Elf_External_Ehdr x_ehdr;     /* Elf file header, external form */
<span class="lineNum">     993 </span>            :   Elf_Internal_Ehdr *i_ehdrp;   /* Elf file header, internal form */
<span class="lineNum">     994 </span>            :   Elf_External_Shdr *x_shdrp;   /* Section header table, external form */
<span class="lineNum">     995 </span>            :   Elf_Internal_Shdr **i_shdrp;  /* Section header table, internal form */
<span class="lineNum">     996 </span>            :   unsigned int count;
<span class="lineNum">     997 </span>            :   bfd_size_type amt;
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   i_ehdrp = elf_elfheader (abfd);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   i_shdrp = elf_elfsections (abfd);</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :   /* swap the header before spitting it out...  */
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            : #if DEBUG &amp; 1
<span class="lineNum">    1005 </span>            :   elf_debug_file (i_ehdrp);
<span class="lineNum">    1006 </span>            : #endif
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   elf_swap_ehdr_out (abfd, i_ehdrp, &amp;x_ehdr);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   amt = sizeof (x_ehdr);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       || bfd_bwrite (&amp;x_ehdr, amt, abfd) != amt)</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            :   /* Some fields in the first section header handle overflow of ehdr
<span class="lineNum">    1014 </span>            :      fields.  */
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   if (i_ehdrp-&gt;e_phnum &gt;= PN_XNUM)</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     i_shdrp[0]-&gt;sh_info = i_ehdrp-&gt;e_phnum;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   if (i_ehdrp-&gt;e_shnum &gt;= (SHN_LORESERVE &amp; 0xffff))</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     i_shdrp[0]-&gt;sh_size = i_ehdrp-&gt;e_shnum;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   if (i_ehdrp-&gt;e_shstrndx &gt;= (SHN_LORESERVE &amp; 0xffff))</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     i_shdrp[0]-&gt;sh_link = i_ehdrp-&gt;e_shstrndx;</span>
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span>            :   /* at this point we've concocted all the ELF sections...  */
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :   amt = i_ehdrp-&gt;e_shnum;</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   amt *= sizeof (*x_shdrp);</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :   x_shdrp = (Elf_External_Shdr *) bfd_alloc (abfd, amt);</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   if (!x_shdrp)</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   for (count = 0; count &lt; i_ehdrp-&gt;e_shnum; i_shdrp++, count++)</span>
<span class="lineNum">    1030 </span>            :     {
<span class="lineNum">    1031 </span>            : #if DEBUG &amp; 2
<span class="lineNum">    1032 </span>            :       elf_debug_section (count, *i_shdrp);
<span class="lineNum">    1033 </span>            : #endif
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :       elf_swap_shdr_out (abfd, *i_shdrp, x_shdrp + count);</span>
<span class="lineNum">    1035 </span>            :     }
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   if (bfd_seek (abfd, (file_ptr) i_ehdrp-&gt;e_shoff, SEEK_SET) != 0</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :       || bfd_bwrite (x_shdrp, amt, abfd) != amt)</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :   /* need to dump the string table too...  */
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    1043 </span>            : }
<a name="1044"><span class="lineNum">    1044 </span>            : </a>
<span class="lineNum">    1045 </span>            : bfd_boolean
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 : elf_checksum_contents (bfd *abfd,</span>
<span class="lineNum">    1047 </span>            :                        void (*process) (const void *, size_t, void *),
<span class="lineNum">    1048 </span>            :                        void *arg)
<span class="lineNum">    1049 </span>            : {
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   Elf_Internal_Phdr *i_phdrp = elf_tdata (abfd)-&gt;phdr;</span>
<span class="lineNum">    1053 </span>            :   unsigned int count, num;
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span>            :   {
<span class="lineNum">    1056 </span>            :     Elf_External_Ehdr x_ehdr;
<span class="lineNum">    1057 </span>            :     Elf_Internal_Ehdr i_ehdr;
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     i_ehdr = *i_ehdrp;</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :     i_ehdr.e_phoff = i_ehdr.e_shoff = 0;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     elf_swap_ehdr_out (abfd, &amp;i_ehdr, &amp;x_ehdr);</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     (*process) (&amp;x_ehdr, sizeof x_ehdr, arg);</span>
<span class="lineNum">    1063 </span>            :   }
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   num = i_ehdrp-&gt;e_phnum;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   for (count = 0; count &lt; num; count++)</span>
<span class="lineNum">    1067 </span>            :     {
<span class="lineNum">    1068 </span>            :       Elf_External_Phdr x_phdr;
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :       elf_swap_phdr_out (abfd, &amp;i_phdrp[count], &amp;x_phdr);</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :       (*process) (&amp;x_phdr, sizeof x_phdr, arg);</span>
<span class="lineNum">    1071 </span>            :     }
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   num = elf_numsections (abfd);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   for (count = 0; count &lt; num; count++)</span>
<span class="lineNum">    1075 </span>            :     {
<span class="lineNum">    1076 </span>            :       Elf_Internal_Shdr i_shdr;
<span class="lineNum">    1077 </span>            :       Elf_External_Shdr x_shdr;
<span class="lineNum">    1078 </span>            :       bfd_byte *contents, *free_contents;
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :       i_shdr = *i_shdrp[count];</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :       i_shdr.sh_offset = 0;</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :       elf_swap_shdr_out (abfd, &amp;i_shdr, &amp;x_shdr);</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       (*process) (&amp;x_shdr, sizeof x_shdr, arg);</span>
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :       /* Process the section's contents, if it has some.
<span class="lineNum">    1087 </span>            :          PR ld/12451: Read them in if necessary.  */
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :       if (i_shdr.sh_type == SHT_NOBITS)</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       free_contents = NULL;</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :       contents = i_shdr.contents;</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :       if (contents == NULL)</span>
<span class="lineNum">    1093 </span>            :         {
<span class="lineNum">    1094 </span>            :           asection *sec;
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :           sec = bfd_section_from_elf_index (abfd, count);</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :           if (sec != NULL)</span>
<span class="lineNum">    1098 </span>            :             {
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :               contents = sec-&gt;contents;</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :               if (contents == NULL)</span>
<span class="lineNum">    1101 </span>            :                 {
<span class="lineNum">    1102 </span>            :                   /* Force rereading from file.  */
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :                   sec-&gt;flags &amp;= ~SEC_IN_MEMORY;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                   if (!bfd_malloc_and_get_section (abfd, sec, &amp;free_contents))</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                   contents = free_contents;</span>
<span class="lineNum">    1107 </span>            :                 }
<span class="lineNum">    1108 </span>            :             }
<span class="lineNum">    1109 </span>            :         }
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :       if (contents != NULL)</span>
<span class="lineNum">    1111 </span>            :         {
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :           (*process) (contents, i_shdr.sh_size, arg);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :           if (free_contents != NULL)</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :             free (free_contents);</span>
<span class="lineNum">    1115 </span>            :         }
<span class="lineNum">    1116 </span>            :     }
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    1119 </span>            : }
<a name="1120"><span class="lineNum">    1120 </span>            : </a>
<span class="lineNum">    1121 </span>            : long
<span class="lineNum">    1122 </span><span class="lineCov">         50 : elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)</span>
<span class="lineNum">    1123 </span>            : {
<span class="lineNum">    1124 </span>            :   Elf_Internal_Shdr *hdr;
<span class="lineNum">    1125 </span>            :   Elf_Internal_Shdr *verhdr;
<span class="lineNum">    1126 </span>            :   unsigned long symcount;       /* Number of external ELF symbols */
<span class="lineNum">    1127 </span>            :   elf_symbol_type *sym;         /* Pointer to current bfd symbol */
<span class="lineNum">    1128 </span>            :   elf_symbol_type *symbase;     /* Buffer for generated bfd symbols */
<span class="lineNum">    1129 </span>            :   Elf_Internal_Sym *isym;
<span class="lineNum">    1130 </span>            :   Elf_Internal_Sym *isymend;
<span class="lineNum">    1131 </span><span class="lineCov">         50 :   Elf_Internal_Sym *isymbuf = NULL;</span>
<span class="lineNum">    1132 </span>            :   Elf_External_Versym *xver;
<span class="lineNum">    1133 </span><span class="lineCov">         50 :   Elf_External_Versym *xverbuf = NULL;</span>
<span class="lineNum">    1134 </span>            :   const struct elf_backend_data *ebd;
<span class="lineNum">    1135 </span>            :   bfd_size_type amt;
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :   /* Read each raw ELF symbol, converting from external ELF form to
<span class="lineNum">    1138 </span>            :      internal ELF form, and then using the information to create a
<span class="lineNum">    1139 </span>            :      canonical bfd symbol table entry.
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            :      Note that we allocate the initial bfd canonical symbol buffer
<span class="lineNum">    1142 </span>            :      based on a one-to-one mapping of the ELF symbols to canonical
<span class="lineNum">    1143 </span>            :      symbols.  We actually use all the ELF symbols, so there will be no
<span class="lineNum">    1144 </span>            :      space left over at the end.  When we have all the symbols, we
<span class="lineNum">    1145 </span>            :      build the caller's pointer vector.  */
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineCov">         50 :   if (! dynamic)</span>
<span class="lineNum">    1148 </span>            :     {
<span class="lineNum">    1149 </span><span class="lineCov">         50 :       hdr = &amp;elf_tdata (abfd)-&gt;symtab_hdr;</span>
<span class="lineNum">    1150 </span><span class="lineCov">         50 :       verhdr = NULL;</span>
<span class="lineNum">    1151 </span>            :     }
<span class="lineNum">    1152 </span>            :   else
<span class="lineNum">    1153 </span>            :     {
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :       hdr = &amp;elf_tdata (abfd)-&gt;dynsymtab_hdr;</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :       if (elf_dynversym (abfd) == 0)</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         verhdr = NULL;</span>
<span class="lineNum">    1157 </span>            :       else
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         verhdr = &amp;elf_tdata (abfd)-&gt;dynversym_hdr;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :       if ((elf_dynverdef (abfd) != 0</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :            &amp;&amp; elf_tdata (abfd)-&gt;verdef == NULL)</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :           || (elf_dynverref (abfd) != 0</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :               &amp;&amp; elf_tdata (abfd)-&gt;verref == NULL))</span>
<span class="lineNum">    1163 </span>            :         {
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :           if (!_bfd_elf_slurp_version_tables (abfd, FALSE))</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">    1166 </span>            :         }
<span class="lineNum">    1167 </span>            :     }
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineCov">         50 :   ebd = get_elf_backend_data (abfd);</span>
<span class="lineNum">    1170 </span><span class="lineCov">         50 :   symcount = hdr-&gt;sh_size / sizeof (Elf_External_Sym);</span>
<span class="lineNum">    1171 </span><span class="lineCov">         50 :   if (symcount == 0)</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     sym = symbase = NULL;</span>
<span class="lineNum">    1173 </span>            :   else
<span class="lineNum">    1174 </span>            :     {
<span class="lineNum">    1175 </span><span class="lineCov">         50 :       isymbuf = bfd_elf_get_elf_syms (abfd, hdr, symcount, 0,</span>
<span class="lineNum">    1176 </span>            :                                       NULL, NULL, NULL);
<span class="lineNum">    1177 </span><span class="lineCov">         50 :       if (isymbuf == NULL)</span>
<span class="lineNum">    1178 </span><span class="lineCov">          1 :         return -1;</span>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span><span class="lineCov">         49 :       amt = symcount;</span>
<span class="lineNum">    1181 </span><span class="lineCov">         49 :       amt *= sizeof (elf_symbol_type);</span>
<span class="lineNum">    1182 </span><span class="lineCov">         49 :       symbase = (elf_symbol_type *) bfd_zalloc (abfd, amt);</span>
<span class="lineNum">    1183 </span><span class="lineCov">         49 :       if (symbase == (elf_symbol_type *) NULL)</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :         goto error_return;</span>
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            :       /* Read the raw ELF version symbol information.  */
<span class="lineNum">    1187 </span><span class="lineCov">         49 :       if (verhdr != NULL</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :           &amp;&amp; verhdr-&gt;sh_size / sizeof (Elf_External_Versym) != symcount)</span>
<span class="lineNum">    1189 </span>            :         {
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :           _bfd_error_handler</span>
<span class="lineNum">    1191 </span>            :             /* xgettext:c-format */
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :             (_(&quot;%s: version count (%ld) does not match symbol count (%ld)&quot;),</span>
<span class="lineNum">    1193 </span>            :              abfd-&gt;filename,
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :              (long) (verhdr-&gt;sh_size / sizeof (Elf_External_Versym)),</span>
<span class="lineNum">    1195 </span>            :              symcount);
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            :           /* Slurp in the symbols without the version information,
<span class="lineNum">    1198 </span>            :              since that is more helpful than just quitting.  */
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :           verhdr = NULL;</span>
<span class="lineNum">    1200 </span>            :         }
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineCov">         49 :       if (verhdr != NULL)</span>
<span class="lineNum">    1203 </span>            :         {
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :           if (bfd_seek (abfd, verhdr-&gt;sh_offset, SEEK_SET) != 0)</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :             goto error_return;</span>
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :           xverbuf = (Elf_External_Versym *) bfd_malloc (verhdr-&gt;sh_size);</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :           if (xverbuf == NULL &amp;&amp; verhdr-&gt;sh_size != 0)</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :             goto error_return;</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :           if (bfd_bread (xverbuf, verhdr-&gt;sh_size, abfd) != verhdr-&gt;sh_size)</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :             goto error_return;</span>
<span class="lineNum">    1213 </span>            :         }
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            :       /* Skip first symbol, which is a null dummy.  */
<span class="lineNum">    1216 </span><span class="lineCov">         49 :       xver = xverbuf;</span>
<span class="lineNum">    1217 </span><span class="lineCov">         49 :       if (xver != NULL)</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :         ++xver;</span>
<span class="lineNum">    1219 </span><span class="lineCov">         49 :       isymend = isymbuf + symcount;</span>
<span class="lineNum">    1220 </span><span class="lineCov">       1112 :       for (isym = isymbuf + 1, sym = symbase; isym &lt; isymend; isym++, sym++)</span>
<span class="lineNum">    1221 </span>            :         {
<span class="lineNum">    1222 </span><span class="lineCov">       1063 :           memcpy (&amp;sym-&gt;internal_elf_sym, isym, sizeof (Elf_Internal_Sym));</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span><span class="lineCov">       1063 :           sym-&gt;symbol.the_bfd = abfd;</span>
<span class="lineNum">    1225 </span><span class="lineCov">       1063 :           sym-&gt;symbol.name = bfd_elf_sym_name (abfd, hdr, isym, NULL);</span>
<span class="lineNum">    1226 </span><span class="lineCov">       1063 :           sym-&gt;symbol.value = isym-&gt;st_value;</span>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineCov">       1063 :           if (isym-&gt;st_shndx == SHN_UNDEF)</span>
<span class="lineNum">    1229 </span>            :             {
<span class="lineNum">    1230 </span><span class="lineCov">        371 :               sym-&gt;symbol.section = bfd_und_section_ptr;</span>
<span class="lineNum">    1231 </span>            :             }
<span class="lineNum">    1232 </span><span class="lineCov">        692 :           else if (isym-&gt;st_shndx == SHN_ABS)</span>
<span class="lineNum">    1233 </span>            :             {
<span class="lineNum">    1234 </span><span class="lineCov">         48 :               sym-&gt;symbol.section = bfd_abs_section_ptr;</span>
<span class="lineNum">    1235 </span>            :             }
<span class="lineNum">    1236 </span><span class="lineCov">        644 :           else if (isym-&gt;st_shndx == SHN_COMMON)</span>
<span class="lineNum">    1237 </span>            :             {
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :               sym-&gt;symbol.section = bfd_com_section_ptr;</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :               if ((abfd-&gt;flags &amp; BFD_PLUGIN) != 0)</span>
<span class="lineNum">    1240 </span>            :                 {
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                   asection *xc = bfd_get_section_by_name (abfd, &quot;COMMON&quot;);</span>
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                   if (xc == NULL)</span>
<span class="lineNum">    1244 </span>            :                     {
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                       flagword flags = (SEC_ALLOC | SEC_IS_COMMON | SEC_KEEP</span>
<span class="lineNum">    1246 </span>            :                                         | SEC_EXCLUDE);
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :                       xc = bfd_make_section_with_flags (abfd, &quot;COMMON&quot;, flags);</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :                       if (xc == NULL)</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :                         goto error_return;</span>
<span class="lineNum">    1250 </span>            :                     }
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :                   sym-&gt;symbol.section = xc;</span>
<span class="lineNum">    1252 </span>            :                 }
<span class="lineNum">    1253 </span>            :               /* Elf puts the alignment into the `value' field, and
<span class="lineNum">    1254 </span>            :                  the size into the `size' field.  BFD wants to see the
<span class="lineNum">    1255 </span>            :                  size in the value field, and doesn't care (at the
<span class="lineNum">    1256 </span>            :                  moment) about the alignment.  */
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :               sym-&gt;symbol.value = isym-&gt;st_size;</span>
<span class="lineNum">    1258 </span>            :             }
<span class="lineNum">    1259 </span>            :           else
<span class="lineNum">    1260 </span>            :             {
<span class="lineNum">    1261 </span>            :               sym-&gt;symbol.section
<span class="lineNum">    1262 </span><span class="lineCov">        644 :                 = bfd_section_from_elf_index (abfd, isym-&gt;st_shndx);</span>
<span class="lineNum">    1263 </span><span class="lineCov">        644 :               if (sym-&gt;symbol.section == NULL)</span>
<span class="lineNum">    1264 </span>            :                 {
<span class="lineNum">    1265 </span>            :                   /* This symbol is in a section for which we did not
<span class="lineNum">    1266 </span>            :                      create a BFD section.  Just use bfd_abs_section,
<span class="lineNum">    1267 </span>            :                      although it is wrong.  FIXME.  */
<span class="lineNum">    1268 </span><span class="lineCov">         48 :                   sym-&gt;symbol.section = bfd_abs_section_ptr;</span>
<span class="lineNum">    1269 </span>            :                 }
<span class="lineNum">    1270 </span>            :             }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            :           /* If this is a relocatable file, then the symbol value is
<span class="lineNum">    1273 </span>            :              already section relative.  */
<span class="lineNum">    1274 </span><span class="lineCov">       1063 :           if ((abfd-&gt;flags &amp; (EXEC_P | DYNAMIC)) != 0)</span>
<span class="lineNum">    1275 </span><span class="lineCov">        207 :             sym-&gt;symbol.value -= sym-&gt;symbol.section-&gt;vma;</span>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span><span class="lineCov">       1063 :           switch (ELF_ST_BIND (isym-&gt;st_info))</span>
<span class="lineNum">    1278 </span>            :             {
<span class="lineNum">    1279 </span><span class="lineCov">        631 :             case STB_LOCAL:</span>
<span class="lineNum">    1280 </span><span class="lineCov">        631 :               sym-&gt;symbol.flags |= BSF_LOCAL;</span>
<span class="lineNum">    1281 </span><span class="lineCov">        631 :               break;</span>
<span class="lineNum">    1282 </span><span class="lineCov">        414 :             case STB_GLOBAL:</span>
<span class="lineNum">    1283 </span><span class="lineCov">        414 :               if (isym-&gt;st_shndx != SHN_UNDEF &amp;&amp; isym-&gt;st_shndx != SHN_COMMON)</span>
<span class="lineNum">    1284 </span><span class="lineCov">         64 :                 sym-&gt;symbol.flags |= BSF_GLOBAL;</span>
<span class="lineNum">    1285 </span><span class="lineCov">        414 :               break;</span>
<span class="lineNum">    1286 </span><span class="lineCov">          1 :             case STB_WEAK:</span>
<span class="lineNum">    1287 </span><span class="lineCov">          1 :               sym-&gt;symbol.flags |= BSF_WEAK;</span>
<span class="lineNum">    1288 </span><span class="lineCov">          1 :               break;</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :             case STB_GNU_UNIQUE:</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :               sym-&gt;symbol.flags |= BSF_GNU_UNIQUE;</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1292 </span>            :             }
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">       1063 :           switch (ELF_ST_TYPE (isym-&gt;st_info))</span>
<span class="lineNum">    1295 </span>            :             {
<span class="lineNum">    1296 </span><span class="lineCov">        381 :             case STT_SECTION:</span>
<span class="lineNum">    1297 </span><span class="lineCov">        381 :               sym-&gt;symbol.flags |= BSF_SECTION_SYM | BSF_DEBUGGING;</span>
<span class="lineNum">    1298 </span><span class="lineCov">        381 :               break;</span>
<span class="lineNum">    1299 </span><span class="lineCov">         50 :             case STT_FILE:</span>
<span class="lineNum">    1300 </span><span class="lineCov">         50 :               sym-&gt;symbol.flags |= BSF_FILE | BSF_DEBUGGING;</span>
<span class="lineNum">    1301 </span><span class="lineCov">         50 :               break;</span>
<span class="lineNum">    1302 </span><span class="lineCov">        145 :             case STT_FUNC:</span>
<span class="lineNum">    1303 </span><span class="lineCov">        145 :               sym-&gt;symbol.flags |= BSF_FUNCTION;</span>
<span class="lineNum">    1304 </span><span class="lineCov">        145 :               break;</span>
<span class="lineNum">    1305 </span><span class="lineCov">          1 :             case STT_COMMON:</span>
<span class="lineNum">    1306 </span>            :               /* FIXME: Do we have to put the size field into the value field
<span class="lineNum">    1307 </span>            :                  as we do with symbols in SHN_COMMON sections (see above) ?  */
<span class="lineNum">    1308 </span><span class="lineCov">          1 :               sym-&gt;symbol.flags |= BSF_ELF_COMMON;</span>
<span class="lineNum">    1309 </span>            :               /* Fall through.  */
<span class="lineNum">    1310 </span><span class="lineCov">        102 :             case STT_OBJECT:</span>
<span class="lineNum">    1311 </span><span class="lineCov">        102 :               sym-&gt;symbol.flags |= BSF_OBJECT;</span>
<span class="lineNum">    1312 </span><span class="lineCov">        102 :               break;</span>
<span class="lineNum">    1313 </span><span class="lineCov">          1 :             case STT_TLS:</span>
<span class="lineNum">    1314 </span><span class="lineCov">          1 :               sym-&gt;symbol.flags |= BSF_THREAD_LOCAL;</span>
<span class="lineNum">    1315 </span><span class="lineCov">          1 :               break;</span>
<span class="lineNum">    1316 </span><span class="lineCov">          1 :             case STT_RELC:</span>
<span class="lineNum">    1317 </span><span class="lineCov">          1 :               sym-&gt;symbol.flags |= BSF_RELC;</span>
<span class="lineNum">    1318 </span><span class="lineCov">          1 :               break;</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :             case STT_SRELC:</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :               sym-&gt;symbol.flags |= BSF_SRELC;</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :             case STT_GNU_IFUNC:</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :               sym-&gt;symbol.flags |= BSF_GNU_INDIRECT_FUNCTION;</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1325 </span>            :             }
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineCov">       1063 :           if (dynamic)</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :             sym-&gt;symbol.flags |= BSF_DYNAMIC;</span>
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span><span class="lineCov">       1063 :           if (xver != NULL)</span>
<span class="lineNum">    1331 </span>            :             {
<span class="lineNum">    1332 </span>            :               Elf_Internal_Versym iversym;
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :               _bfd_elf_swap_versym_in (abfd, xver, &amp;iversym);</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :               sym-&gt;version = iversym.vs_vers;</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :               xver++;</span>
<span class="lineNum">    1337 </span>            :             }
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            :           /* Do some backend-specific processing on this symbol.  */
<span class="lineNum">    1340 </span><span class="lineCov">       1063 :           if (ebd-&gt;elf_backend_symbol_processing)</span>
<span class="lineNum">    1341 </span><span class="lineCov">        842 :             (*ebd-&gt;elf_backend_symbol_processing) (abfd, &amp;sym-&gt;symbol);</span>
<span class="lineNum">    1342 </span>            :         }
<span class="lineNum">    1343 </span>            :     }
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            :   /* Do some backend-specific processing on this symbol table.  */
<span class="lineNum">    1346 </span><span class="lineCov">         49 :   if (ebd-&gt;elf_backend_symbol_table_processing)</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :     (*ebd-&gt;elf_backend_symbol_table_processing) (abfd, symbase, symcount);</span>
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            :   /* We rely on the zalloc to clear out the final symbol entry.  */
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span><span class="lineCov">         49 :   symcount = sym - symbase;</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :   /* Fill in the user's symbol pointer vector if needed.  */
<span class="lineNum">    1354 </span><span class="lineCov">         49 :   if (symptrs)</span>
<span class="lineNum">    1355 </span>            :     {
<span class="lineNum">    1356 </span><span class="lineCov">         49 :       long l = symcount;</span>
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span><span class="lineCov">         49 :       sym = symbase;</span>
<span class="lineNum">    1359 </span><span class="lineCov">       1161 :       while (l-- &gt; 0)</span>
<span class="lineNum">    1360 </span>            :         {
<span class="lineNum">    1361 </span><span class="lineCov">       1063 :           *symptrs++ = &amp;sym-&gt;symbol;</span>
<span class="lineNum">    1362 </span><span class="lineCov">       1063 :           sym++;</span>
<span class="lineNum">    1363 </span>            :         }
<span class="lineNum">    1364 </span><span class="lineCov">         49 :       *symptrs = 0;             /* Final null pointer */</span>
<span class="lineNum">    1365 </span>            :     }
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span><span class="lineCov">         49 :   if (xverbuf != NULL)</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     free (xverbuf);</span>
<span class="lineNum">    1369 </span><span class="lineCov">         49 :   if (isymbuf != NULL &amp;&amp; hdr-&gt;contents != (unsigned char *) isymbuf)</span>
<span class="lineNum">    1370 </span><span class="lineCov">         49 :     free (isymbuf);</span>
<span class="lineNum">    1371 </span><span class="lineCov">         49 :   return symcount;</span>
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 : error_return:</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   if (xverbuf != NULL)</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :     free (xverbuf);</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :   if (isymbuf != NULL &amp;&amp; hdr-&gt;contents != (unsigned char *) isymbuf)</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     free (isymbuf);</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">    1379 </span>            : }
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            : /* Read relocations for ASECT from REL_HDR.  There are RELOC_COUNT of
<span class="lineNum">    1382 </span>            :    them.  */
<a name="1383"><span class="lineNum">    1383 </span>            : </a>
<span class="lineNum">    1384 </span>            : static bfd_boolean
<span class="lineNum">    1385 </span><span class="lineCov">         62 : elf_slurp_reloc_table_from_section (bfd *abfd,</span>
<span class="lineNum">    1386 </span>            :                                     asection *asect,
<span class="lineNum">    1387 </span>            :                                     Elf_Internal_Shdr *rel_hdr,
<span class="lineNum">    1388 </span>            :                                     bfd_size_type reloc_count,
<span class="lineNum">    1389 </span>            :                                     arelent *relents,
<span class="lineNum">    1390 </span>            :                                     asymbol **symbols,
<span class="lineNum">    1391 </span>            :                                     bfd_boolean dynamic)
<span class="lineNum">    1392 </span>            : {
<span class="lineNum">    1393 </span><span class="lineCov">         62 :   const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);</span>
<span class="lineNum">    1394 </span><span class="lineCov">         62 :   void *allocated = NULL;</span>
<span class="lineNum">    1395 </span>            :   bfd_byte *native_relocs;
<span class="lineNum">    1396 </span>            :   arelent *relent;
<span class="lineNum">    1397 </span>            :   unsigned int i;
<span class="lineNum">    1398 </span>            :   int entsize;
<span class="lineNum">    1399 </span>            :   unsigned int symcount;
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineCov">         62 :   allocated = bfd_malloc (rel_hdr-&gt;sh_size);</span>
<span class="lineNum">    1402 </span><span class="lineCov">         62 :   if (allocated == NULL)</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :     goto error_return;</span>
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span><span class="lineCov">         62 :   if (bfd_seek (abfd, rel_hdr-&gt;sh_offset, SEEK_SET) != 0</span>
<span class="lineNum">    1406 </span><span class="lineCov">        124 :       || (bfd_bread (allocated, rel_hdr-&gt;sh_size, abfd)</span>
<span class="lineNum">    1407 </span><span class="lineCov">         62 :           != rel_hdr-&gt;sh_size))</span>
<span class="lineNum">    1408 </span>            :     goto error_return;
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineCov">         61 :   native_relocs = (bfd_byte *) allocated;</span>
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span><span class="lineCov">         61 :   entsize = rel_hdr-&gt;sh_entsize;</span>
<span class="lineNum">    1413 </span><span class="lineCov">         61 :   BFD_ASSERT (entsize == sizeof (Elf_External_Rel)</span>
<span class="lineNum">    1414 </span>            :               || entsize == sizeof (Elf_External_Rela));
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineCov">         61 :   if (dynamic)</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     symcount = bfd_get_dynamic_symcount (abfd);</span>
<span class="lineNum">    1418 </span>            :   else
<span class="lineNum">    1419 </span><span class="lineCov">         61 :     symcount = bfd_get_symcount (abfd);</span>
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineCov">        530 :   for (i = 0, relent = relents;</span>
<span class="lineNum">    1422 </span><span class="lineCov">        469 :        i &lt; reloc_count;</span>
<span class="lineNum">    1423 </span><span class="lineCov">        408 :        i++, relent++, native_relocs += entsize)</span>
<span class="lineNum">    1424 </span>            :     {
<span class="lineNum">    1425 </span>            :       Elf_Internal_Rela rela;
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span><span class="lineCov">        408 :       if (entsize == sizeof (Elf_External_Rela))</span>
<span class="lineNum">    1428 </span><span class="lineCov">        408 :         elf_swap_reloca_in (abfd, native_relocs, &amp;rela);</span>
<span class="lineNum">    1429 </span>            :       else
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :         elf_swap_reloc_in (abfd, native_relocs, &amp;rela);</span>
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            :       /* The address of an ELF reloc is section relative for an object
<span class="lineNum">    1433 </span>            :          file, and absolute for an executable file or shared library.
<span class="lineNum">    1434 </span>            :          The address of a normal BFD reloc is always section relative,
<span class="lineNum">    1435 </span>            :          and the address of a dynamic reloc is absolute..  */
<span class="lineNum">    1436 </span><span class="lineCov">        408 :       if ((abfd-&gt;flags &amp; (EXEC_P | DYNAMIC)) == 0 || dynamic)</span>
<span class="lineNum">    1437 </span><span class="lineCov">        312 :         relent-&gt;address = rela.r_offset;</span>
<span class="lineNum">    1438 </span>            :       else
<span class="lineNum">    1439 </span><span class="lineCov">         96 :         relent-&gt;address = rela.r_offset - asect-&gt;vma;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span><span class="lineCov">        408 :       if (ELF_R_SYM (rela.r_info) == STN_UNDEF)</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :         relent-&gt;sym_ptr_ptr = bfd_abs_section_ptr-&gt;symbol_ptr_ptr;</span>
<span class="lineNum">    1443 </span><span class="lineCov">        408 :       else if (ELF_R_SYM (rela.r_info) &gt; symcount)</span>
<span class="lineNum">    1444 </span>            :         {
<span class="lineNum">    1445 </span><span class="lineCov">        126 :           _bfd_error_handler</span>
<span class="lineNum">    1446 </span>            :             /* xgettext:c-format */
<span class="lineNum">    1447 </span><span class="lineCov">         63 :             (_(&quot;%s(%s): relocation %d has invalid symbol index %ld&quot;),</span>
<span class="lineNum">    1448 </span><span class="lineCov">         63 :              abfd-&gt;filename, asect-&gt;name, i, ELF_R_SYM (rela.r_info));</span>
<span class="lineNum">    1449 </span><span class="lineCov">         63 :           relent-&gt;sym_ptr_ptr = bfd_abs_section_ptr-&gt;symbol_ptr_ptr;</span>
<span class="lineNum">    1450 </span>            :         }
<span class="lineNum">    1451 </span>            :       else
<span class="lineNum">    1452 </span>            :         {
<span class="lineNum">    1453 </span>            :           asymbol **ps;
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineCov">        345 :           ps = symbols + ELF_R_SYM (rela.r_info) - 1;</span>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineCov">        345 :           relent-&gt;sym_ptr_ptr = ps;</span>
<span class="lineNum">    1458 </span>            :         }
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineCov">        408 :       relent-&gt;addend = rela.r_addend;</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineCov">        408 :       if ((entsize == sizeof (Elf_External_Rela)</span>
<span class="lineNum">    1463 </span><span class="lineCov">        408 :            &amp;&amp; ebd-&gt;elf_info_to_howto != NULL)</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :           || ebd-&gt;elf_info_to_howto_rel == NULL)</span>
<span class="lineNum">    1465 </span><span class="lineCov">        408 :         (*ebd-&gt;elf_info_to_howto) (abfd, relent, &amp;rela);</span>
<span class="lineNum">    1466 </span>            :       else
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :         (*ebd-&gt;elf_info_to_howto_rel) (abfd, relent, &amp;rela);</span>
<span class="lineNum">    1468 </span>            :     }
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span><span class="lineCov">         61 :   if (allocated != NULL)</span>
<span class="lineNum">    1471 </span><span class="lineCov">         61 :     free (allocated);</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineCov">         61 :   return TRUE;</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineCov">          1 :  error_return:</span>
<span class="lineNum">    1476 </span><span class="lineCov">          1 :   if (allocated != NULL)</span>
<span class="lineNum">    1477 </span><span class="lineCov">          1 :     free (allocated);</span>
<span class="lineNum">    1478 </span><span class="lineCov">          1 :   return FALSE;</span>
<span class="lineNum">    1479 </span>            : }
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            : /* Read in and swap the external relocs.  */
<a name="1482"><span class="lineNum">    1482 </span>            : </a>
<span class="lineNum">    1483 </span>            : bfd_boolean
<span class="lineNum">    1484 </span><span class="lineCov">         79 : elf_slurp_reloc_table (bfd *abfd,</span>
<span class="lineNum">    1485 </span>            :                        asection *asect,
<span class="lineNum">    1486 </span>            :                        asymbol **symbols,
<span class="lineNum">    1487 </span>            :                        bfd_boolean dynamic)
<span class="lineNum">    1488 </span>            : {
<span class="lineNum">    1489 </span><span class="lineCov">         79 :   struct bfd_elf_section_data * const d = elf_section_data (asect);</span>
<span class="lineNum">    1490 </span>            :   Elf_Internal_Shdr *rel_hdr;
<span class="lineNum">    1491 </span>            :   Elf_Internal_Shdr *rel_hdr2;
<span class="lineNum">    1492 </span>            :   bfd_size_type reloc_count;
<span class="lineNum">    1493 </span>            :   bfd_size_type reloc_count2;
<span class="lineNum">    1494 </span>            :   arelent *relents;
<span class="lineNum">    1495 </span>            :   bfd_size_type amt;
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineCov">         79 :   if (asect-&gt;relocation != NULL)</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span><span class="lineCov">         79 :   if (! dynamic)</span>
<span class="lineNum">    1501 </span>            :     {
<span class="lineNum">    1502 </span><span class="lineCov">         79 :       if ((asect-&gt;flags &amp; SEC_RELOC) == 0</span>
<span class="lineNum">    1503 </span><span class="lineCov">         79 :           || asect-&gt;reloc_count == 0)</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span><span class="lineCov">         79 :       rel_hdr = d-&gt;rel.hdr;</span>
<span class="lineNum">    1507 </span><span class="lineCov">         79 :       reloc_count = rel_hdr ? NUM_SHDR_ENTRIES (rel_hdr) : 0;</span>
<span class="lineNum">    1508 </span><span class="lineCov">         79 :       rel_hdr2 = d-&gt;rela.hdr;</span>
<span class="lineNum">    1509 </span><span class="lineCov">         79 :       reloc_count2 = rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0;</span>
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span>            :       /* PR 17512: file: 0b4f81b7.  */
<span class="lineNum">    1512 </span><span class="lineCov">         79 :       if (asect-&gt;reloc_count != reloc_count + reloc_count2)</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1514 </span><span class="lineCov">         79 :       BFD_ASSERT ((rel_hdr &amp;&amp; asect-&gt;rel_filepos == rel_hdr-&gt;sh_offset)</span>
<span class="lineNum">    1515 </span>            :                   || (rel_hdr2 &amp;&amp; asect-&gt;rel_filepos == rel_hdr2-&gt;sh_offset));
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            :     }
<span class="lineNum">    1518 </span>            :   else
<span class="lineNum">    1519 </span>            :     {
<span class="lineNum">    1520 </span>            :       /* Note that ASECT-&gt;RELOC_COUNT tends not to be accurate in this
<span class="lineNum">    1521 </span>            :          case because relocations against this section may use the
<span class="lineNum">    1522 </span>            :          dynamic symbol table, and in that case bfd_section_from_shdr
<span class="lineNum">    1523 </span>            :          in elf.c does not update the RELOC_COUNT.  */
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :       if (asect-&gt;size == 0)</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :       rel_hdr = &amp;d-&gt;this_hdr;</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :       reloc_count = NUM_SHDR_ENTRIES (rel_hdr);</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :       rel_hdr2 = NULL;</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :       reloc_count2 = 0;</span>
<span class="lineNum">    1531 </span>            :     }
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span><span class="lineCov">         79 :   amt = (reloc_count + reloc_count2) * sizeof (arelent);</span>
<span class="lineNum">    1534 </span><span class="lineCov">         79 :   relents = (arelent *) bfd_alloc (abfd, amt);</span>
<span class="lineNum">    1535 </span><span class="lineCov">         79 :   if (relents == NULL)</span>
<span class="lineNum">    1536 </span><span class="lineCov">         17 :     return FALSE;</span>
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span><span class="lineCov">         62 :   if (rel_hdr</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :       &amp;&amp; !elf_slurp_reloc_table_from_section (abfd, asect,</span>
<span class="lineNum">    1540 </span>            :                                               rel_hdr, reloc_count,
<span class="lineNum">    1541 </span>            :                                               relents,
<span class="lineNum">    1542 </span>            :                                               symbols, dynamic))
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span><span class="lineCov">         62 :   if (rel_hdr2</span>
<span class="lineNum">    1546 </span><span class="lineCov">         62 :       &amp;&amp; !elf_slurp_reloc_table_from_section (abfd, asect,</span>
<span class="lineNum">    1547 </span>            :                                               rel_hdr2, reloc_count2,
<span class="lineNum">    1548 </span><span class="lineCov">         62 :                                               relents + reloc_count,</span>
<span class="lineNum">    1549 </span>            :                                               symbols, dynamic))
<span class="lineNum">    1550 </span><span class="lineCov">          1 :     return FALSE;</span>
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span><span class="lineCov">         61 :   asect-&gt;relocation = relents;</span>
<span class="lineNum">    1553 </span><span class="lineCov">         61 :   return TRUE;</span>
<span class="lineNum">    1554 </span>            : }
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            : #if DEBUG &amp; 2
<span class="lineNum">    1557 </span>            : static void
<span class="lineNum">    1558 </span>            : elf_debug_section (int num, Elf_Internal_Shdr *hdr)
<span class="lineNum">    1559 </span>            : {
<span class="lineNum">    1560 </span>            :   fprintf (stderr, &quot;\nSection#%d '%s' 0x%.8lx\n&quot;, num,
<span class="lineNum">    1561 </span>            :            hdr-&gt;bfd_section != NULL ? hdr-&gt;bfd_section-&gt;name : &quot;&quot;,
<span class="lineNum">    1562 </span>            :            (long) hdr);
<span class="lineNum">    1563 </span>            :   fprintf (stderr,
<span class="lineNum">    1564 </span>            :            &quot;sh_name      = %ld\tsh_type      = %ld\tsh_flags     = %ld\n&quot;,
<span class="lineNum">    1565 </span>            :            (long) hdr-&gt;sh_name,
<span class="lineNum">    1566 </span>            :            (long) hdr-&gt;sh_type,
<span class="lineNum">    1567 </span>            :            (long) hdr-&gt;sh_flags);
<span class="lineNum">    1568 </span>            :   fprintf (stderr,
<span class="lineNum">    1569 </span>            :            &quot;sh_addr      = %ld\tsh_offset    = %ld\tsh_size      = %ld\n&quot;,
<span class="lineNum">    1570 </span>            :            (long) hdr-&gt;sh_addr,
<span class="lineNum">    1571 </span>            :            (long) hdr-&gt;sh_offset,
<span class="lineNum">    1572 </span>            :            (long) hdr-&gt;sh_size);
<span class="lineNum">    1573 </span>            :   fprintf (stderr,
<span class="lineNum">    1574 </span>            :            &quot;sh_link      = %ld\tsh_info      = %ld\tsh_addralign = %ld\n&quot;,
<span class="lineNum">    1575 </span>            :            (long) hdr-&gt;sh_link,
<span class="lineNum">    1576 </span>            :            (long) hdr-&gt;sh_info,
<span class="lineNum">    1577 </span>            :            (long) hdr-&gt;sh_addralign);
<span class="lineNum">    1578 </span>            :   fprintf (stderr, &quot;sh_entsize   = %ld\n&quot;,
<span class="lineNum">    1579 </span>            :            (long) hdr-&gt;sh_entsize);
<span class="lineNum">    1580 </span>            :   fflush (stderr);
<span class="lineNum">    1581 </span>            : }
<span class="lineNum">    1582 </span>            : #endif
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span>            : #if DEBUG &amp; 1
<span class="lineNum">    1585 </span>            : static void
<span class="lineNum">    1586 </span>            : elf_debug_file (Elf_Internal_Ehdr *ehdrp)
<span class="lineNum">    1587 </span>            : {
<span class="lineNum">    1588 </span>            :   fprintf (stderr, &quot;e_entry      = 0x%.8lx\n&quot;, (long) ehdrp-&gt;e_entry);
<span class="lineNum">    1589 </span>            :   fprintf (stderr, &quot;e_phoff      = %ld\n&quot;, (long) ehdrp-&gt;e_phoff);
<span class="lineNum">    1590 </span>            :   fprintf (stderr, &quot;e_phnum      = %ld\n&quot;, (long) ehdrp-&gt;e_phnum);
<span class="lineNum">    1591 </span>            :   fprintf (stderr, &quot;e_phentsize  = %ld\n&quot;, (long) ehdrp-&gt;e_phentsize);
<span class="lineNum">    1592 </span>            :   fprintf (stderr, &quot;e_shoff      = %ld\n&quot;, (long) ehdrp-&gt;e_shoff);
<span class="lineNum">    1593 </span>            :   fprintf (stderr, &quot;e_shnum      = %ld\n&quot;, (long) ehdrp-&gt;e_shnum);
<span class="lineNum">    1594 </span>            :   fprintf (stderr, &quot;e_shentsize  = %ld\n&quot;, (long) ehdrp-&gt;e_shentsize);
<span class="lineNum">    1595 </span>            : }
<span class="lineNum">    1596 </span>            : #endif
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span>            : /* Create a new BFD as if by bfd_openr.  Rather than opening a file,
<span class="lineNum">    1599 </span>            :    reconstruct an ELF file by reading the segments out of remote
<span class="lineNum">    1600 </span>            :    memory based on the ELF file header at EHDR_VMA and the ELF program
<span class="lineNum">    1601 </span>            :    headers it points to.  If non-zero, SIZE is the known extent of the
<span class="lineNum">    1602 </span>            :    object.  If not null, *LOADBASEP is filled in with the difference
<span class="lineNum">    1603 </span>            :    between the VMAs from which the segments were read, and the VMAs
<span class="lineNum">    1604 </span>            :    the file headers (and hence BFD's idea of each section's VMA) put
<span class="lineNum">    1605 </span>            :    them at.
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span>            :    The function TARGET_READ_MEMORY is called to copy LEN bytes from
<span class="lineNum">    1608 </span>            :    the remote memory at target address VMA into the local buffer at
<span class="lineNum">    1609 </span>            :    MYADDR; it should return zero on success or an `errno' code on
<span class="lineNum">    1610 </span>            :    failure.  TEMPL must be a BFD for a target with the word size and
<span class="lineNum">    1611 </span>            :    byte order found in the remote memory.  */
<a name="1612"><span class="lineNum">    1612 </span>            : </a>
<span class="lineNum">    1613 </span>            : bfd *
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 : NAME(_bfd_elf,bfd_from_remote_memory)</span>
<span class="lineNum">    1615 </span>            :   (bfd *templ,
<span class="lineNum">    1616 </span>            :    bfd_vma ehdr_vma,
<span class="lineNum">    1617 </span>            :    bfd_size_type size,
<span class="lineNum">    1618 </span>            :    bfd_vma *loadbasep,
<span class="lineNum">    1619 </span>            :    int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type))
<span class="lineNum">    1620 </span>            : {
<span class="lineNum">    1621 </span>            :   Elf_External_Ehdr x_ehdr;     /* Elf file header, external form */
<span class="lineNum">    1622 </span>            :   Elf_Internal_Ehdr i_ehdr;     /* Elf file header, internal form */
<span class="lineNum">    1623 </span>            :   Elf_External_Phdr *x_phdrs;
<span class="lineNum">    1624 </span>            :   Elf_Internal_Phdr *i_phdrs, *last_phdr, *first_phdr;
<span class="lineNum">    1625 </span>            :   bfd *nbfd;
<span class="lineNum">    1626 </span>            :   struct bfd_in_memory *bim;
<span class="lineNum">    1627 </span>            :   bfd_byte *contents;
<span class="lineNum">    1628 </span>            :   int err;
<span class="lineNum">    1629 </span>            :   unsigned int i;
<span class="lineNum">    1630 </span>            :   bfd_vma high_offset;
<span class="lineNum">    1631 </span>            :   bfd_vma shdr_end;
<span class="lineNum">    1632 </span>            :   bfd_vma loadbase;
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            :   /* Read in the ELF header in external format.  */
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   err = target_read_memory (ehdr_vma, (bfd_byte *) &amp;x_ehdr, sizeof x_ehdr);</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1637 </span>            :     {
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :       errno = err;</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1641 </span>            :     }
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            :   /* Now check to see if we have a valid ELF file, and one that BFD can
<span class="lineNum">    1644 </span>            :      make use of.  The magic number must match, the address size ('class')
<span class="lineNum">    1645 </span>            :      and byte-swapping must match our XVEC entry.  */
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   if (! elf_file_p (&amp;x_ehdr)</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :       || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :       || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)</span>
<span class="lineNum">    1650 </span>            :     {
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1653 </span>            :     }
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span>            :   /* Check that file's byte order matches xvec's */
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :   switch (x_ehdr.e_ident[EI_DATA])</span>
<span class="lineNum">    1657 </span>            :     {
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :     case ELFDATA2MSB:           /* Big-endian */</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :       if (! bfd_header_big_endian (templ))</span>
<span class="lineNum">    1660 </span>            :         {
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :           bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :           return NULL;</span>
<span class="lineNum">    1663 </span>            :         }
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :     case ELFDATA2LSB:           /* Little-endian */</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :       if (! bfd_header_little_endian (templ))</span>
<span class="lineNum">    1667 </span>            :         {
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :           bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :           return NULL;</span>
<span class="lineNum">    1670 </span>            :         }
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :     case ELFDATANONE:           /* No data encoding specified */</span>
<span class="lineNum">    1673 </span>            :     default:                    /* Unknown data encoding specified */
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1676 </span>            :     }
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :   elf_swap_ehdr_in (templ, &amp;x_ehdr, &amp;i_ehdr);</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            :   /* The file header tells where to find the program headers.
<span class="lineNum">    1681 </span>            :      These are what we use to actually choose what to read.  */
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :   if (i_ehdr.e_phentsize != sizeof (Elf_External_Phdr) || i_ehdr.e_phnum == 0)</span>
<span class="lineNum">    1684 </span>            :     {
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1687 </span>            :     }
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :   x_phdrs = (Elf_External_Phdr *)</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :       bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :   if (x_phdrs == NULL)</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :   err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (bfd_byte *) x_phdrs,</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :                             i_ehdr.e_phnum * sizeof x_phdrs[0]);</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1696 </span>            :     {
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :       free (x_phdrs);</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :       errno = err;</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1701 </span>            :     }
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :   i_phdrs = (Elf_Internal_Phdr *) &amp;x_phdrs[i_ehdr.e_phnum];</span>
<span class="lineNum">    1703 </span>            : 
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :   high_offset = 0;</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :   loadbase = 0;</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :   first_phdr = NULL;</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :   last_phdr = NULL;</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; i_ehdr.e_phnum; ++i)</span>
<span class="lineNum">    1709 </span>            :     {
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :       elf_swap_phdr_in (templ, &amp;x_phdrs[i], &amp;i_phdrs[i]);</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :       if (i_phdrs[i].p_type == PT_LOAD)</span>
<span class="lineNum">    1712 </span>            :         {
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :           bfd_vma segment_end = i_phdrs[i].p_offset + i_phdrs[i].p_filesz;</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :           if (segment_end &gt; high_offset)</span>
<span class="lineNum">    1716 </span>            :             {
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :               high_offset = segment_end;</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :               last_phdr = &amp;i_phdrs[i];</span>
<span class="lineNum">    1719 </span>            :             }
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :           /* If this program header covers offset zero, where the file
<span class="lineNum">    1722 </span>            :              header sits, then we can figure out the loadbase.  */
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :           if (first_phdr == NULL)</span>
<span class="lineNum">    1724 </span>            :             {
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :               bfd_vma p_offset = i_phdrs[i].p_offset;</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :               bfd_vma p_vaddr = i_phdrs[i].p_vaddr;</span>
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :               if (i_phdrs[i].p_align &gt; 1)</span>
<span class="lineNum">    1729 </span>            :                 {
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :                   p_offset &amp;= -i_phdrs[i].p_align;</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :                   p_vaddr &amp;= -i_phdrs[i].p_align;</span>
<span class="lineNum">    1732 </span>            :                 }
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :               if (p_offset == 0)</span>
<span class="lineNum">    1734 </span>            :                 {
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :                   loadbase = ehdr_vma - p_vaddr;</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :                   first_phdr = &amp;i_phdrs[i];</span>
<span class="lineNum">    1737 </span>            :                 }
<span class="lineNum">    1738 </span>            :             }
<span class="lineNum">    1739 </span>            :         }
<span class="lineNum">    1740 </span>            :     }
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :   if (high_offset == 0)</span>
<span class="lineNum">    1742 </span>            :     {
<span class="lineNum">    1743 </span>            :       /* There were no PT_LOAD segments, so we don't have anything to read.  */
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :       free (x_phdrs);</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_wrong_format);</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1747 </span>            :     }
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :   shdr_end = 0;</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :   if (i_ehdr.e_shoff != 0 &amp;&amp; i_ehdr.e_shnum != 0 &amp;&amp; i_ehdr.e_shentsize != 0)</span>
<span class="lineNum">    1751 </span>            :     {
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :       shdr_end = i_ehdr.e_shoff + i_ehdr.e_shnum * i_ehdr.e_shentsize;</span>
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :       if (last_phdr-&gt;p_filesz != last_phdr-&gt;p_memsz)</span>
<span class="lineNum">    1755 </span>            :         {
<span class="lineNum">    1756 </span>            :           /* If the last PT_LOAD header has a bss area then ld.so will
<span class="lineNum">    1757 </span>            :              have cleared anything past p_filesz, zapping the section
<span class="lineNum">    1758 </span>            :              headers.  */
<span class="lineNum">    1759 </span>            :         }
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :       else if (size &gt;= shdr_end)</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :         high_offset = size;</span>
<span class="lineNum">    1762 </span>            :       else
<span class="lineNum">    1763 </span>            :         {
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :           bfd_vma page_size = get_elf_backend_data (templ)-&gt;minpagesize;</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :           bfd_vma segment_end = last_phdr-&gt;p_offset + last_phdr-&gt;p_filesz;</span>
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span>            :           /* Assume we loaded full pages, allowing us to sometimes see
<span class="lineNum">    1768 </span>            :              section headers.  */
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :           if (page_size &gt; 1 &amp;&amp; shdr_end &gt; segment_end)</span>
<span class="lineNum">    1770 </span>            :             {
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :               bfd_vma page_end = (segment_end + page_size - 1) &amp; -page_size;</span>
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :               if (page_end &gt;= shdr_end)</span>
<span class="lineNum">    1774 </span>            :                 /* Whee, section headers covered.  */
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :                 high_offset = shdr_end;</span>
<span class="lineNum">    1776 </span>            :             }
<span class="lineNum">    1777 </span>            :         }
<span class="lineNum">    1778 </span>            :     }
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            :   /* Now we know the size of the whole image we want read in.  */
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :   contents = (bfd_byte *) bfd_zmalloc (high_offset);</span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :   if (contents == NULL)</span>
<span class="lineNum">    1783 </span>            :     {
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :       free (x_phdrs);</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1786 </span>            :     }
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; i_ehdr.e_phnum; ++i)</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :     if (i_phdrs[i].p_type == PT_LOAD)</span>
<span class="lineNum">    1790 </span>            :       {
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :         bfd_vma start = i_phdrs[i].p_offset;</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :         bfd_vma end = start + i_phdrs[i].p_filesz;</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :         bfd_vma vaddr = i_phdrs[i].p_vaddr;</span>
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            :         /* Extend the beginning of the first pt_load to cover file
<span class="lineNum">    1796 </span>            :            header and program headers, if we proved earlier that its
<span class="lineNum">    1797 </span>            :            aligned offset is 0.  */
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :         if (first_phdr == &amp;i_phdrs[i])</span>
<span class="lineNum">    1799 </span>            :           {
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :             vaddr -= start;</span>
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :             start = 0;</span>
<span class="lineNum">    1802 </span>            :           }
<span class="lineNum">    1803 </span>            :         /* Extend the end of the last pt_load to cover section headers.  */
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :         if (last_phdr == &amp;i_phdrs[i])</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :           end = high_offset;</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :         err = target_read_memory (loadbase + vaddr,</span>
<span class="lineNum">    1807 </span>            :                                   contents + start, end - start);
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :         if (err)</span>
<span class="lineNum">    1809 </span>            :           {
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :             free (x_phdrs);</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :             free (contents);</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :             bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :             errno = err;</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">    1815 </span>            :           }
<span class="lineNum">    1816 </span>            :       }
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :   free (x_phdrs);</span>
<span class="lineNum">    1818 </span>            : 
<span class="lineNum">    1819 </span>            :   /* If the segments visible in memory didn't include the section headers,
<span class="lineNum">    1820 </span>            :      then clear them from the file header.  */
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :   if (high_offset &lt; shdr_end)</span>
<span class="lineNum">    1822 </span>            :     {
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :       memset (&amp;x_ehdr.e_shoff, 0, sizeof x_ehdr.e_shoff);</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :       memset (&amp;x_ehdr.e_shnum, 0, sizeof x_ehdr.e_shnum);</span>
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :       memset (&amp;x_ehdr.e_shstrndx, 0, sizeof x_ehdr.e_shstrndx);</span>
<span class="lineNum">    1826 </span>            :     }
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span>            :   /* This will normally have been in the first PT_LOAD segment.  But it
<span class="lineNum">    1829 </span>            :      conceivably could be missing, and we might have just changed it.  */
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :   memcpy (contents, &amp;x_ehdr, sizeof x_ehdr);</span>
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span>            :   /* Now we have a memory image of the ELF file contents.  Make a BFD.  */
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :   bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));</span>
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :   if (bim == NULL)</span>
<span class="lineNum">    1835 </span>            :     {
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :       free (contents);</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1838 </span>            :     }
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :   nbfd = _bfd_new_bfd ();</span>
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :   if (nbfd == NULL)</span>
<span class="lineNum">    1841 </span>            :     {
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :       free (bim);</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :       free (contents);</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1845 </span>            :     }
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :   nbfd-&gt;filename = xstrdup (&quot;&lt;in-memory&gt;&quot;);</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :   nbfd-&gt;xvec = templ-&gt;xvec;</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :   bim-&gt;size = high_offset;</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :   bim-&gt;buffer = contents;</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :   nbfd-&gt;iostream = bim;</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :   nbfd-&gt;flags = BFD_IN_MEMORY;</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :   nbfd-&gt;iovec = &amp;_bfd_memory_iovec;</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :   nbfd-&gt;origin = 0;</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :   nbfd-&gt;direction = read_direction;</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :   nbfd-&gt;mtime = time (NULL);</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :   nbfd-&gt;mtime_set = TRUE;</span>
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :   if (loadbasep)</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :     *loadbasep = loadbase;</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :   return nbfd;</span>
<span class="lineNum">    1861 </span>            : }
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            : /* Function for ELF_R_INFO.  */
<a name="1864"><span class="lineNum">    1864 </span>            : </a>
<span class="lineNum">    1865 </span>            : bfd_vma
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 : NAME(elf,r_info) (bfd_vma sym, bfd_vma type)</span>
<span class="lineNum">    1867 </span>            : {
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :   return ELF_R_INFO (sym, type);</span>
<span class="lineNum">    1869 </span>            : }
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span>            : /* Function for ELF_R_SYM.  */
<a name="1872"><span class="lineNum">    1872 </span>            : </a>
<span class="lineNum">    1873 </span>            : bfd_vma
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 : NAME(elf,r_sym) (bfd_vma r_info)</span>
<span class="lineNum">    1875 </span>            : {
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :   return ELF_R_SYM (r_info);</span>
<span class="lineNum">    1877 </span>            : }
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            : #include &quot;elfcore.h&quot;
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            : /* Size-dependent data and functions.  */
<span class="lineNum">    1882 </span>            : const struct elf_size_info NAME(_bfd_elf,size_info) = {
<span class="lineNum">    1883 </span>            :   sizeof (Elf_External_Ehdr),
<span class="lineNum">    1884 </span>            :   sizeof (Elf_External_Phdr),
<span class="lineNum">    1885 </span>            :   sizeof (Elf_External_Shdr),
<span class="lineNum">    1886 </span>            :   sizeof (Elf_External_Rel),
<span class="lineNum">    1887 </span>            :   sizeof (Elf_External_Rela),
<span class="lineNum">    1888 </span>            :   sizeof (Elf_External_Sym),
<span class="lineNum">    1889 </span>            :   sizeof (Elf_External_Dyn),
<span class="lineNum">    1890 </span>            :   sizeof (Elf_External_Note),
<span class="lineNum">    1891 </span>            :   4,
<span class="lineNum">    1892 </span>            :   1,
<span class="lineNum">    1893 </span>            :   ARCH_SIZE, LOG_FILE_ALIGN,
<span class="lineNum">    1894 </span>            :   ELFCLASS, EV_CURRENT,
<span class="lineNum">    1895 </span>            :   elf_write_out_phdrs,
<span class="lineNum">    1896 </span>            :   elf_write_shdrs_and_ehdr,
<span class="lineNum">    1897 </span>            :   elf_checksum_contents,
<span class="lineNum">    1898 </span>            :   elf_write_relocs,
<span class="lineNum">    1899 </span>            :   elf_swap_symbol_in,
<span class="lineNum">    1900 </span>            :   elf_swap_symbol_out,
<span class="lineNum">    1901 </span>            :   elf_slurp_reloc_table,
<span class="lineNum">    1902 </span>            :   elf_slurp_symbol_table,
<span class="lineNum">    1903 </span>            :   elf_swap_dyn_in,
<span class="lineNum">    1904 </span>            :   elf_swap_dyn_out,
<span class="lineNum">    1905 </span>            :   elf_swap_reloc_in,
<span class="lineNum">    1906 </span>            :   elf_swap_reloc_out,
<span class="lineNum">    1907 </span>            :   elf_swap_reloca_in,
<span class="lineNum">    1908 </span>            :   elf_swap_reloca_out
<span class="lineNum">    1909 </span>            : };
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
