<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - fuzzer_coverage.info - bfd/opncls.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">bfd</a> - opncls.c<span style="font-size: 80%;"> (source / <a href="opncls.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">fuzzer_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">66</td>
            <td class="headerCovTableEntry">575</td>
            <td class="headerCovTableEntryLo">11.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-06-21 09:00:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">44</td>
            <td class="headerCovTableEntryLo">20.5 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* opncls.c -- open and close a BFD.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1990-2017 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            :    Written by Cygnus Support.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :    This file is part of BFD, the Binary File Descriptor library.
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            :    This program is free software; you can redistribute it and/or modify
<span class="lineNum">       9 </span>            :    it under the terms of the GNU General Public License as published by
<span class="lineNum">      10 </span>            :    the Free Software Foundation; either version 3 of the License, or
<span class="lineNum">      11 </span>            :    (at your option) any later version.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :    This program is distributed in the hope that it will be useful,
<span class="lineNum">      14 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      15 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      16 </span>            :    GNU General Public License for more details.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            :    You should have received a copy of the GNU General Public License
<span class="lineNum">      19 </span>            :    along with this program; if not, write to the Free Software
<span class="lineNum">      20 </span>            :    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
<span class="lineNum">      21 </span>            :    MA 02110-1301, USA.  */
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &quot;sysdep.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;bfd.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;objalloc.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;libbfd.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;libiberty.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;elf-bfd.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #ifndef S_IXUSR
<span class="lineNum">      31 </span>            : #define S_IXUSR 0100    /* Execute by owner.  */
<span class="lineNum">      32 </span>            : #endif
<span class="lineNum">      33 </span>            : #ifndef S_IXGRP
<span class="lineNum">      34 </span>            : #define S_IXGRP 0010    /* Execute by group.  */
<span class="lineNum">      35 </span>            : #endif
<span class="lineNum">      36 </span>            : #ifndef S_IXOTH
<span class="lineNum">      37 </span>            : #define S_IXOTH 0001    /* Execute by others.  */
<span class="lineNum">      38 </span>            : #endif
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : /* Counters used to initialize the bfd identifier.  */
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : static unsigned int bfd_id_counter = 0;
<span class="lineNum">      43 </span>            : static unsigned int bfd_reserved_id_counter = 0;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /*
<span class="lineNum">      46 </span>            : CODE_FRAGMENT
<span class="lineNum">      47 </span>            : .{* Set to N to open the next N BFDs using an alternate id space.  *}
<span class="lineNum">      48 </span>            : .extern unsigned int bfd_use_reserved_id;
<span class="lineNum">      49 </span>            : */
<span class="lineNum">      50 </span>            : unsigned int bfd_use_reserved_id = 0;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : /* fdopen is a loser -- we should use stdio exclusively.  Unfortunately
<span class="lineNum">      53 </span>            :    if we do that we can't use fcntl.  */
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : /* Return a new BFD.  All BFD's are allocated through this routine.  */
<a name="56"><span class="lineNum">      56 </span>            : </a>
<span class="lineNum">      57 </span>            : bfd *
<span class="lineNum">      58 </span><span class="lineCov">        295 : _bfd_new_bfd (void)</span>
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span>            :   bfd *nbfd;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span><span class="lineCov">        295 :   nbfd = (bfd *) bfd_zmalloc (sizeof (bfd));</span>
<span class="lineNum">      63 </span><span class="lineCov">        295 :   if (nbfd == NULL)</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineCov">        295 :   if (bfd_use_reserved_id)</span>
<span class="lineNum">      67 </span>            :     {
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :       nbfd-&gt;id = --bfd_reserved_id_counter;</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :       --bfd_use_reserved_id;</span>
<span class="lineNum">      70 </span>            :     }
<span class="lineNum">      71 </span>            :   else
<span class="lineNum">      72 </span><span class="lineCov">        295 :     nbfd-&gt;id = bfd_id_counter++;</span>
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span><span class="lineCov">        295 :   nbfd-&gt;memory = objalloc_create ();</span>
<span class="lineNum">      75 </span><span class="lineCov">        295 :   if (nbfd-&gt;memory == NULL)</span>
<span class="lineNum">      76 </span>            :     {
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_memory);</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :       free (nbfd);</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">      80 </span>            :     }
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineCov">        295 :   nbfd-&gt;arch_info = &amp;bfd_default_arch_struct;</span>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span><span class="lineCov">        295 :   if (!bfd_hash_table_init_n (&amp; nbfd-&gt;section_htab, bfd_section_hash_newfunc,</span>
<span class="lineNum">      85 </span>            :                               sizeof (struct section_hash_entry), 13))
<span class="lineNum">      86 </span>            :     {
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :       free (nbfd);</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">      89 </span>            :     }
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span><span class="lineCov">        295 :   return nbfd;</span>
<span class="lineNum">      92 </span>            : }
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : static const struct bfd_iovec opncls_iovec;
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : /* Allocate a new BFD as a member of archive OBFD.  */
<a name="97"><span class="lineNum">      97 </span>            : </a>
<span class="lineNum">      98 </span>            : bfd *
<span class="lineNum">      99 </span><span class="lineNoCov">          0 : _bfd_new_bfd_contained_in (bfd *obfd)</span>
<span class="lineNum">     100 </span>            : {
<span class="lineNum">     101 </span>            :   bfd *nbfd;
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   nbfd = _bfd_new_bfd ();</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   if (nbfd == NULL)</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   nbfd-&gt;xvec = obfd-&gt;xvec;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   nbfd-&gt;iovec = obfd-&gt;iovec;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   if (obfd-&gt;iovec == &amp;opncls_iovec)</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     nbfd-&gt;iostream = obfd-&gt;iostream;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   nbfd-&gt;my_archive = obfd;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   nbfd-&gt;direction = read_direction;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   nbfd-&gt;target_defaulted = obfd-&gt;target_defaulted;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   nbfd-&gt;lto_output = obfd-&gt;lto_output;</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   nbfd-&gt;no_export = obfd-&gt;no_export;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   return nbfd;</span>
<span class="lineNum">     116 </span>            : }
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : /* Delete a BFD.  */
<a name="119"><span class="lineNum">     119 </span>            : </a>
<span class="lineNum">     120 </span>            : static void
<span class="lineNum">     121 </span><span class="lineCov">         11 : _bfd_delete_bfd (bfd *abfd)</span>
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span><span class="lineCov">         11 :   if (abfd-&gt;memory)</span>
<span class="lineNum">     124 </span>            :     {
<span class="lineNum">     125 </span><span class="lineCov">         11 :       bfd_hash_table_free (&amp;abfd-&gt;section_htab);</span>
<span class="lineNum">     126 </span><span class="lineCov">         11 :       objalloc_free ((struct objalloc *) abfd-&gt;memory);</span>
<span class="lineNum">     127 </span>            :     }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineCov">         11 :   if (abfd-&gt;filename)</span>
<span class="lineNum">     130 </span><span class="lineCov">         11 :     free ((char *) abfd-&gt;filename);</span>
<span class="lineNum">     131 </span><span class="lineCov">         11 :   free (abfd-&gt;arelt_data);</span>
<span class="lineNum">     132 </span><span class="lineCov">         11 :   free (abfd);</span>
<span class="lineNum">     133 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /* Free objalloc memory.  */
<a name="136"><span class="lineNum">     136 </span>            : </a>
<span class="lineNum">     137 </span>            : bfd_boolean
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : _bfd_free_cached_info (bfd *abfd)</span>
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   if (abfd-&gt;memory)</span>
<span class="lineNum">     141 </span>            :     {
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :       bfd_hash_table_free (&amp;abfd-&gt;section_htab);</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :       objalloc_free ((struct objalloc *) abfd-&gt;memory);</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       abfd-&gt;sections = NULL;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :       abfd-&gt;section_last = NULL;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :       abfd-&gt;outsymbols = NULL;</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :       abfd-&gt;tdata.any = NULL;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       abfd-&gt;usrdata = NULL;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       abfd-&gt;memory = NULL;</span>
<span class="lineNum">     151 </span>            :     }
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">     154 </span>            : }
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : /*
<span class="lineNum">     157 </span>            : SECTION
<span class="lineNum">     158 </span>            :         Opening and closing BFDs
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            : SUBSECTION
<span class="lineNum">     161 </span>            :         Functions for opening and closing
<span class="lineNum">     162 </span>            : */
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /*
<span class="lineNum">     165 </span>            : FUNCTION
<span class="lineNum">     166 </span>            :         bfd_fopen
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : SYNOPSIS
<span class="lineNum">     169 </span>            :         bfd *bfd_fopen (const char *filename, const char *target,
<span class="lineNum">     170 </span>            :                         const char *mode, int fd);
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : DESCRIPTION
<span class="lineNum">     173 </span>            :         Open the file @var{filename} with the target @var{target}.
<span class="lineNum">     174 </span>            :         Return a pointer to the created BFD.  If @var{fd} is not -1,
<span class="lineNum">     175 </span>            :         then &lt;&lt;fdopen&gt;&gt; is used to open the file; otherwise, &lt;&lt;fopen&gt;&gt;
<span class="lineNum">     176 </span>            :         is used.  @var{mode} is passed directly to &lt;&lt;fopen&gt;&gt; or
<span class="lineNum">     177 </span>            :         &lt;&lt;fdopen&gt;&gt;.
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :         Calls &lt;&lt;bfd_find_target&gt;&gt;, so @var{target} is interpreted as by
<span class="lineNum">     180 </span>            :         that function.
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :         The new BFD is marked as cacheable iff @var{fd} is -1.
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :         If &lt;&lt;NULL&gt;&gt; is returned then an error has occured.   Possible errors
<span class="lineNum">     185 </span>            :         are &lt;&lt;bfd_error_no_memory&gt;&gt;, &lt;&lt;bfd_error_invalid_target&gt;&gt; or
<span class="lineNum">     186 </span>            :         &lt;&lt;system_call&gt;&gt; error.
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            :         On error, @var{fd} is always closed.
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :         A copy of the @var{filename} argument is stored in the newly created
<span class="lineNum">     191 </span>            :         BFD.  It can be accessed via the bfd_get_filename() macro.
<span class="lineNum">     192 </span>            : */
<a name="193"><span class="lineNum">     193 </span>            : </a>
<span class="lineNum">     194 </span>            : bfd *
<span class="lineNum">     195 </span><span class="lineCov">        295 : bfd_fopen (const char *filename, const char *target, const char *mode, int fd)</span>
<span class="lineNum">     196 </span>            : {
<span class="lineNum">     197 </span>            :   bfd *nbfd;
<span class="lineNum">     198 </span>            :   const bfd_target *target_vec;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineCov">        295 :   nbfd = _bfd_new_bfd ();</span>
<span class="lineNum">     201 </span><span class="lineCov">        295 :   if (nbfd == NULL)</span>
<span class="lineNum">     202 </span>            :     {
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       if (fd != -1)</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         close (fd);</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     206 </span>            :     }
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineCov">        295 :   target_vec = bfd_find_target (target, nbfd);</span>
<span class="lineNum">     209 </span><span class="lineCov">        295 :   if (target_vec == NULL)</span>
<span class="lineNum">     210 </span>            :     {
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :       if (fd != -1)</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         close (fd);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     215 </span>            :     }
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : #ifdef HAVE_FDOPEN
<span class="lineNum">     218 </span><span class="lineCov">        295 :   if (fd != -1)</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     nbfd-&gt;iostream = fdopen (fd, mode);</span>
<span class="lineNum">     220 </span>            :   else
<span class="lineNum">     221 </span>            : #endif
<span class="lineNum">     222 </span><span class="lineCov">        295 :     nbfd-&gt;iostream = real_fopen (filename, mode);</span>
<span class="lineNum">     223 </span><span class="lineCov">        295 :   if (nbfd-&gt;iostream == NULL)</span>
<span class="lineNum">     224 </span>            :     {
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     228 </span>            :     }
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :   /* OK, put everything where it belongs.  */
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   /* PR 11983: Do not cache the original filename, but
<span class="lineNum">     233 </span>            :      rather make a copy - the original might go away.  */
<span class="lineNum">     234 </span><span class="lineCov">        295 :   nbfd-&gt;filename = xstrdup (filename);</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   /* Figure out whether the user is opening the file for reading,
<span class="lineNum">     237 </span>            :      writing, or both, by looking at the MODE argument.  */
<span class="lineNum">     238 </span><span class="lineCov">        295 :   if ((mode[0] == 'r' || mode[0] == 'w' || mode[0] == 'a')</span>
<span class="lineNum">     239 </span><span class="lineCov">        295 :       &amp;&amp; mode[1] == '+')</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     nbfd-&gt;direction = both_direction;</span>
<span class="lineNum">     241 </span><span class="lineCov">        295 :   else if (mode[0] == 'r')</span>
<span class="lineNum">     242 </span><span class="lineCov">        295 :     nbfd-&gt;direction = read_direction;</span>
<span class="lineNum">     243 </span>            :   else
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     nbfd-&gt;direction = write_direction;</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineCov">        295 :   if (! bfd_cache_init (nbfd))</span>
<span class="lineNum">     247 </span>            :     {
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     250 </span>            :     }
<span class="lineNum">     251 </span><span class="lineCov">        295 :   nbfd-&gt;opened_once = TRUE;</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :   /* If we opened the file by name, mark it cacheable; we can close it
<span class="lineNum">     254 </span>            :      and reopen it later.  However, if a file descriptor was provided,
<span class="lineNum">     255 </span>            :      then it may have been opened with special flags that make it
<span class="lineNum">     256 </span>            :      unsafe to close and reopen the file.  */
<span class="lineNum">     257 </span><span class="lineCov">        295 :   if (fd == -1)</span>
<span class="lineNum">     258 </span><span class="lineCov">        295 :     (void) bfd_set_cacheable (nbfd, TRUE);</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineCov">        295 :   return nbfd;</span>
<span class="lineNum">     261 </span>            : }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : /*
<span class="lineNum">     264 </span>            : FUNCTION
<span class="lineNum">     265 </span>            :         bfd_openr
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : SYNOPSIS
<span class="lineNum">     268 </span>            :         bfd *bfd_openr (const char *filename, const char *target);
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : DESCRIPTION
<span class="lineNum">     271 </span>            :         Open the file @var{filename} (using &lt;&lt;fopen&gt;&gt;) with the target
<span class="lineNum">     272 </span>            :         @var{target}.  Return a pointer to the created BFD.
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :         Calls &lt;&lt;bfd_find_target&gt;&gt;, so @var{target} is interpreted as by
<span class="lineNum">     275 </span>            :         that function.
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :         If &lt;&lt;NULL&gt;&gt; is returned then an error has occured.   Possible errors
<span class="lineNum">     278 </span>            :         are &lt;&lt;bfd_error_no_memory&gt;&gt;, &lt;&lt;bfd_error_invalid_target&gt;&gt; or
<span class="lineNum">     279 </span>            :         &lt;&lt;system_call&gt;&gt; error.
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :         A copy of the @var{filename} argument is stored in the newly created
<span class="lineNum">     282 </span>            :         BFD.  It can be accessed via the bfd_get_filename() macro.
<span class="lineNum">     283 </span>            : */
<a name="284"><span class="lineNum">     284 </span>            : </a>
<span class="lineNum">     285 </span>            : bfd *
<span class="lineNum">     286 </span><span class="lineCov">        295 : bfd_openr (const char *filename, const char *target)</span>
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span><span class="lineCov">        295 :   return bfd_fopen (filename, target, FOPEN_RB, -1);</span>
<span class="lineNum">     289 </span>            : }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* Don't try to `optimize' this function:
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :    o - We lock using stack space so that interrupting the locking
<span class="lineNum">     294 </span>            :        won't cause a storage leak.
<span class="lineNum">     295 </span>            :    o - We open the file stream last, since we don't want to have to
<span class="lineNum">     296 </span>            :        close it if anything goes wrong.  Closing the stream means closing
<span class="lineNum">     297 </span>            :        the file descriptor too, even though we didn't open it.  */
<span class="lineNum">     298 </span>            : /*
<span class="lineNum">     299 </span>            : FUNCTION
<span class="lineNum">     300 </span>            :         bfd_fdopenr
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : SYNOPSIS
<span class="lineNum">     303 </span>            :         bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : DESCRIPTION
<span class="lineNum">     306 </span>            :         &lt;&lt;bfd_fdopenr&gt;&gt; is to &lt;&lt;bfd_fopenr&gt;&gt; much like &lt;&lt;fdopen&gt;&gt; is to
<span class="lineNum">     307 </span>            :         &lt;&lt;fopen&gt;&gt;.  It opens a BFD on a file already described by the
<span class="lineNum">     308 </span>            :         @var{fd} supplied.
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :         When the file is later &lt;&lt;bfd_close&gt;&gt;d, the file descriptor will
<span class="lineNum">     311 </span>            :         be closed.  If the caller desires that this file descriptor be
<span class="lineNum">     312 </span>            :         cached by BFD (opened as needed, closed as needed to free
<span class="lineNum">     313 </span>            :         descriptors for other opens), with the supplied @var{fd} used as
<span class="lineNum">     314 </span>            :         an initial file descriptor (but subject to closure at any time),
<span class="lineNum">     315 </span>            :         call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default
<span class="lineNum">     316 </span>            :         is to assume no caching; the file descriptor will remain open
<span class="lineNum">     317 </span>            :         until &lt;&lt;bfd_close&gt;&gt;, and will not be affected by BFD operations
<span class="lineNum">     318 </span>            :         on other files.
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :         Possible errors are &lt;&lt;bfd_error_no_memory&gt;&gt;,
<span class="lineNum">     321 </span>            :         &lt;&lt;bfd_error_invalid_target&gt;&gt; and &lt;&lt;bfd_error_system_call&gt;&gt;.
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :         On error, @var{fd} is closed.
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :         A copy of the @var{filename} argument is stored in the newly created
<span class="lineNum">     326 </span>            :         BFD.  It can be accessed via the bfd_get_filename() macro.
<span class="lineNum">     327 </span>            : */
<a name="328"><span class="lineNum">     328 </span>            : </a>
<span class="lineNum">     329 </span>            : bfd *
<span class="lineNum">     330 </span><span class="lineNoCov">          0 : bfd_fdopenr (const char *filename, const char *target, int fd)</span>
<span class="lineNum">     331 </span>            : {
<span class="lineNum">     332 </span>            :   const char *mode;
<span class="lineNum">     333 </span>            : #if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
<span class="lineNum">     334 </span>            :   int fdflags;
<span class="lineNum">     335 </span>            : #endif
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : #if ! defined(HAVE_FCNTL) || ! defined(F_GETFL)
<span class="lineNum">     338 </span>            :   mode = FOPEN_RUB; /* Assume full access.  */
<span class="lineNum">     339 </span>            : #else
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   fdflags = fcntl (fd, F_GETFL, NULL);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   if (fdflags == -1)</span>
<span class="lineNum">     342 </span>            :     {
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       int save = errno;</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :       close (fd);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       errno = save;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     349 </span>            :     }
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :   /* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   switch (fdflags &amp; (O_ACCMODE))</span>
<span class="lineNum">     353 </span>            :     {
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     case O_RDONLY: mode = FOPEN_RB; break;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     case O_WRONLY: mode = FOPEN_RUB; break;</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     case O_RDWR:   mode = FOPEN_RUB; break;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     default: abort ();</span>
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span>            : #endif
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   return bfd_fopen (filename, target, mode, fd);</span>
<span class="lineNum">     362 </span>            : }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : /*
<span class="lineNum">     365 </span>            : FUNCTION
<span class="lineNum">     366 </span>            :         bfd_openstreamr
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : SYNOPSIS
<span class="lineNum">     369 </span>            :         bfd *bfd_openstreamr (const char * filename, const char * target, void * stream);
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : DESCRIPTION
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :         Open a BFD for read access on an existing stdio stream.  When
<span class="lineNum">     374 </span>            :         the BFD is passed to &lt;&lt;bfd_close&gt;&gt;, the stream will be closed.
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :         A copy of the @var{filename} argument is stored in the newly created
<span class="lineNum">     377 </span>            :         BFD.  It can be accessed via the bfd_get_filename() macro.
<span class="lineNum">     378 </span>            : */
<a name="379"><span class="lineNum">     379 </span>            : </a>
<span class="lineNum">     380 </span>            : bfd *
<span class="lineNum">     381 </span><span class="lineNoCov">          0 : bfd_openstreamr (const char *filename, const char *target, void *streamarg)</span>
<span class="lineNum">     382 </span>            : {
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   FILE *stream = (FILE *) streamarg;</span>
<span class="lineNum">     384 </span>            :   bfd *nbfd;
<span class="lineNum">     385 </span>            :   const bfd_target *target_vec;
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   nbfd = _bfd_new_bfd ();</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   if (nbfd == NULL)</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   target_vec = bfd_find_target (target, nbfd);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   if (target_vec == NULL)</span>
<span class="lineNum">     393 </span>            :     {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     396 </span>            :     }
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   nbfd-&gt;iostream = stream;</span>
<span class="lineNum">     399 </span>            :   /* PR 11983: Do not cache the original filename, but
<span class="lineNum">     400 </span>            :      rather make a copy - the original might go away.  */
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   nbfd-&gt;filename = xstrdup (filename);</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   nbfd-&gt;direction = read_direction;</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   if (! bfd_cache_init (nbfd))</span>
<span class="lineNum">     405 </span>            :     {
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     408 </span>            :     }
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   return nbfd;</span>
<span class="lineNum">     411 </span>            : }
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : /*
<span class="lineNum">     414 </span>            : FUNCTION
<span class="lineNum">     415 </span>            :         bfd_openr_iovec
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            : SYNOPSIS
<span class="lineNum">     418 </span>            :         bfd *bfd_openr_iovec (const char *filename, const char *target,
<span class="lineNum">     419 </span>            :                               void *(*open_func) (struct bfd *nbfd,
<span class="lineNum">     420 </span>            :                                                   void *open_closure),
<span class="lineNum">     421 </span>            :                               void *open_closure,
<span class="lineNum">     422 </span>            :                               file_ptr (*pread_func) (struct bfd *nbfd,
<span class="lineNum">     423 </span>            :                                                       void *stream,
<span class="lineNum">     424 </span>            :                                                       void *buf,
<span class="lineNum">     425 </span>            :                                                       file_ptr nbytes,
<span class="lineNum">     426 </span>            :                                                       file_ptr offset),
<span class="lineNum">     427 </span>            :                               int (*close_func) (struct bfd *nbfd,
<span class="lineNum">     428 </span>            :                                                  void *stream),
<span class="lineNum">     429 </span>            :                               int (*stat_func) (struct bfd *abfd,
<span class="lineNum">     430 </span>            :                                                 void *stream,
<span class="lineNum">     431 </span>            :                                                 struct stat *sb));
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : DESCRIPTION
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            :         Create and return a BFD backed by a read-only @var{stream}.
<span class="lineNum">     436 </span>            :         The @var{stream} is created using @var{open_func}, accessed using
<span class="lineNum">     437 </span>            :         @var{pread_func} and destroyed using @var{close_func}.
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :         Calls &lt;&lt;bfd_find_target&gt;&gt;, so @var{target} is interpreted as by
<span class="lineNum">     440 </span>            :         that function.
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :         Calls @var{open_func} (which can call &lt;&lt;bfd_zalloc&gt;&gt; and
<span class="lineNum">     443 </span>            :         &lt;&lt;bfd_get_filename&gt;&gt;) to obtain the read-only stream backing
<span class="lineNum">     444 </span>            :         the BFD.  @var{open_func} either succeeds returning the
<span class="lineNum">     445 </span>            :         non-&lt;&lt;NULL&gt;&gt; @var{stream}, or fails returning &lt;&lt;NULL&gt;&gt;
<span class="lineNum">     446 </span>            :         (setting &lt;&lt;bfd_error&gt;&gt;).
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :         Calls @var{pread_func} to request @var{nbytes} of data from
<span class="lineNum">     449 </span>            :         @var{stream} starting at @var{offset} (e.g., via a call to
<span class="lineNum">     450 </span>            :         &lt;&lt;bfd_read&gt;&gt;).  @var{pread_func} either succeeds returning the
<span class="lineNum">     451 </span>            :         number of bytes read (which can be less than @var{nbytes} when
<span class="lineNum">     452 </span>            :         end-of-file), or fails returning -1 (setting &lt;&lt;bfd_error&gt;&gt;).
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :         Calls @var{close_func} when the BFD is later closed using
<span class="lineNum">     455 </span>            :         &lt;&lt;bfd_close&gt;&gt;.  @var{close_func} either succeeds returning 0, or
<span class="lineNum">     456 </span>            :         fails returning -1 (setting &lt;&lt;bfd_error&gt;&gt;).
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :         Calls @var{stat_func} to fill in a stat structure for bfd_stat,
<span class="lineNum">     459 </span>            :         bfd_get_size, and bfd_get_mtime calls.  @var{stat_func} returns 0
<span class="lineNum">     460 </span>            :         on success, or returns -1 on failure (setting &lt;&lt;bfd_error&gt;&gt;).
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :         If &lt;&lt;bfd_openr_iovec&gt;&gt; returns &lt;&lt;NULL&gt;&gt; then an error has
<span class="lineNum">     463 </span>            :         occurred.  Possible errors are &lt;&lt;bfd_error_no_memory&gt;&gt;,
<span class="lineNum">     464 </span>            :         &lt;&lt;bfd_error_invalid_target&gt;&gt; and &lt;&lt;bfd_error_system_call&gt;&gt;.
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :         A copy of the @var{filename} argument is stored in the newly created
<span class="lineNum">     467 </span>            :         BFD.  It can be accessed via the bfd_get_filename() macro.
<span class="lineNum">     468 </span>            : */
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : struct opncls
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span>            :   void *stream;
<span class="lineNum">     473 </span>            :   file_ptr (*pread) (struct bfd *abfd, void *stream, void *buf,
<span class="lineNum">     474 </span>            :                      file_ptr nbytes, file_ptr offset);
<span class="lineNum">     475 </span>            :   int (*close) (struct bfd *abfd, void *stream);
<span class="lineNum">     476 </span>            :   int (*stat) (struct bfd *abfd, void *stream, struct stat *sb);
<span class="lineNum">     477 </span>            :   file_ptr where;
<span class="lineNum">     478 </span>            : };
<a name="479"><span class="lineNum">     479 </span>            : </a>
<span class="lineNum">     480 </span>            : static file_ptr
<span class="lineNum">     481 </span><span class="lineNoCov">          0 : opncls_btell (struct bfd *abfd)</span>
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   struct opncls *vec = (struct opncls *) abfd-&gt;iostream;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   return vec-&gt;where;</span>
<span class="lineNum">     485 </span>            : }
<a name="486"><span class="lineNum">     486 </span>            : </a>
<span class="lineNum">     487 </span>            : static int
<span class="lineNum">     488 </span><span class="lineNoCov">          0 : opncls_bseek (struct bfd *abfd, file_ptr offset, int whence)</span>
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   struct opncls *vec = (struct opncls *) abfd-&gt;iostream;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   switch (whence)</span>
<span class="lineNum">     492 </span>            :     {
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     case SEEK_SET: vec-&gt;where = offset; break;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     case SEEK_CUR: vec-&gt;where += offset; break;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     case SEEK_END: return -1;</span>
<span class="lineNum">     496 </span>            :     }
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     498 </span>            : }
<a name="499"><span class="lineNum">     499 </span>            : </a>
<span class="lineNum">     500 </span>            : static file_ptr
<span class="lineNum">     501 </span><span class="lineNoCov">          0 : opncls_bread (struct bfd *abfd, void *buf, file_ptr nbytes)</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   struct opncls *vec = (struct opncls *) abfd-&gt;iostream;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   file_ptr nread = (vec-&gt;pread) (abfd, vec-&gt;stream, buf, nbytes, vec-&gt;where);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   if (nread &lt; 0)</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     return nread;</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   vec-&gt;where += nread;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   return nread;</span>
<span class="lineNum">     509 </span>            : }
<a name="510"><span class="lineNum">     510 </span>            : </a>
<span class="lineNum">     511 </span>            : static file_ptr
<span class="lineNum">     512 </span><span class="lineNoCov">          0 : opncls_bwrite (struct bfd *abfd ATTRIBUTE_UNUSED,</span>
<span class="lineNum">     513 </span>            :               const void *where ATTRIBUTE_UNUSED,
<span class="lineNum">     514 </span>            :               file_ptr nbytes ATTRIBUTE_UNUSED)
<span class="lineNum">     515 </span>            : {
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">     517 </span>            : }
<a name="518"><span class="lineNum">     518 </span>            : </a>
<span class="lineNum">     519 </span>            : static int
<span class="lineNum">     520 </span><span class="lineNoCov">          0 : opncls_bclose (struct bfd *abfd)</span>
<span class="lineNum">     521 </span>            : {
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   struct opncls *vec = (struct opncls *) abfd-&gt;iostream;</span>
<span class="lineNum">     523 </span>            :   /* Since the VEC's memory is bound to the bfd deleting the bfd will
<span class="lineNum">     524 </span>            :      free it.  */
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   int status = 0;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   if (vec-&gt;close != NULL)</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     status = (vec-&gt;close) (abfd, vec-&gt;stream);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   abfd-&gt;iostream = NULL;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   return status;</span>
<span class="lineNum">     530 </span>            : }
<a name="531"><span class="lineNum">     531 </span>            : </a>
<span class="lineNum">     532 </span>            : static int
<span class="lineNum">     533 </span><span class="lineNoCov">          0 : opncls_bflush (struct bfd *abfd ATTRIBUTE_UNUSED)</span>
<span class="lineNum">     534 </span>            : {
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     536 </span>            : }
<a name="537"><span class="lineNum">     537 </span>            : </a>
<span class="lineNum">     538 </span>            : static int
<span class="lineNum">     539 </span><span class="lineNoCov">          0 : opncls_bstat (struct bfd *abfd, struct stat *sb)</span>
<span class="lineNum">     540 </span>            : {
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   struct opncls *vec = (struct opncls *) abfd-&gt;iostream;</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   memset (sb, 0, sizeof (*sb));</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   if (vec-&gt;stat == NULL)</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   return (vec-&gt;stat) (abfd, vec-&gt;stream, sb);</span>
<span class="lineNum">     548 </span>            : }
<a name="549"><span class="lineNum">     549 </span>            : </a>
<span class="lineNum">     550 </span>            : static void *
<span class="lineNum">     551 </span><span class="lineNoCov">          0 : opncls_bmmap (struct bfd *abfd ATTRIBUTE_UNUSED,</span>
<span class="lineNum">     552 </span>            :               void *addr ATTRIBUTE_UNUSED,
<span class="lineNum">     553 </span>            :               bfd_size_type len ATTRIBUTE_UNUSED,
<span class="lineNum">     554 </span>            :               int prot ATTRIBUTE_UNUSED,
<span class="lineNum">     555 </span>            :               int flags ATTRIBUTE_UNUSED,
<span class="lineNum">     556 </span>            :               file_ptr offset ATTRIBUTE_UNUSED,
<span class="lineNum">     557 </span>            :               void **map_addr ATTRIBUTE_UNUSED,
<span class="lineNum">     558 </span>            :               bfd_size_type *map_len ATTRIBUTE_UNUSED)
<span class="lineNum">     559 </span>            : {
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   return (void *) -1;</span>
<span class="lineNum">     561 </span>            : }
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : static const struct bfd_iovec opncls_iovec = {
<span class="lineNum">     564 </span>            :   &amp;opncls_bread, &amp;opncls_bwrite, &amp;opncls_btell, &amp;opncls_bseek,
<span class="lineNum">     565 </span>            :   &amp;opncls_bclose, &amp;opncls_bflush, &amp;opncls_bstat, &amp;opncls_bmmap
<span class="lineNum">     566 </span>            : };
<a name="567"><span class="lineNum">     567 </span>            : </a>
<span class="lineNum">     568 </span>            : bfd *
<span class="lineNum">     569 </span><span class="lineNoCov">          0 : bfd_openr_iovec (const char *filename, const char *target,</span>
<span class="lineNum">     570 </span>            :                  void *(*open_p) (struct bfd *, void *),
<span class="lineNum">     571 </span>            :                  void *open_closure,
<span class="lineNum">     572 </span>            :                  file_ptr (*pread_p) (struct bfd *, void *, void *,
<span class="lineNum">     573 </span>            :                                       file_ptr, file_ptr),
<span class="lineNum">     574 </span>            :                  int (*close_p) (struct bfd *, void *),
<span class="lineNum">     575 </span>            :                  int (*stat_p) (struct bfd *, void *, struct stat *))
<span class="lineNum">     576 </span>            : {
<span class="lineNum">     577 </span>            :   bfd *nbfd;
<span class="lineNum">     578 </span>            :   const bfd_target *target_vec;
<span class="lineNum">     579 </span>            :   struct opncls *vec;
<span class="lineNum">     580 </span>            :   void *stream;
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   nbfd = _bfd_new_bfd ();</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   if (nbfd == NULL)</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   target_vec = bfd_find_target (target, nbfd);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   if (target_vec == NULL)</span>
<span class="lineNum">     588 </span>            :     {
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     591 </span>            :     }
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :   /* PR 11983: Do not cache the original filename, but
<span class="lineNum">     594 </span>            :      rather make a copy - the original might go away.  */
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   nbfd-&gt;filename = xstrdup (filename);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   nbfd-&gt;direction = read_direction;</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :   /* `open_p (...)' would get expanded by an the open(2) syscall macro.  */
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :   stream = (*open_p) (nbfd, open_closure);</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   if (stream == NULL)</span>
<span class="lineNum">     601 </span>            :     {
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     604 </span>            :     }
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   vec = (struct opncls *) bfd_zalloc (nbfd, sizeof (struct opncls));</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   vec-&gt;stream = stream;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   vec-&gt;pread = pread_p;</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   vec-&gt;close = close_p;</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   vec-&gt;stat = stat_p;</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   nbfd-&gt;iovec = &amp;opncls_iovec;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   nbfd-&gt;iostream = vec;</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   return nbfd;</span>
<span class="lineNum">     616 </span>            : }
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            : /* bfd_openw -- open for writing.
<span class="lineNum">     619 </span>            :    Returns a pointer to a freshly-allocated BFD on success, or NULL.
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :    See comment by bfd_fdopenr before you try to modify this function.  */
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            : /*
<span class="lineNum">     624 </span>            : FUNCTION
<span class="lineNum">     625 </span>            :         bfd_openw
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : SYNOPSIS
<span class="lineNum">     628 </span>            :         bfd *bfd_openw (const char *filename, const char *target);
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : DESCRIPTION
<span class="lineNum">     631 </span>            :         Create a BFD, associated with file @var{filename}, using the
<span class="lineNum">     632 </span>            :         file format @var{target}, and return a pointer to it.
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :         Possible errors are &lt;&lt;bfd_error_system_call&gt;&gt;, &lt;&lt;bfd_error_no_memory&gt;&gt;,
<span class="lineNum">     635 </span>            :         &lt;&lt;bfd_error_invalid_target&gt;&gt;.
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :         A copy of the @var{filename} argument is stored in the newly created
<span class="lineNum">     638 </span>            :         BFD.  It can be accessed via the bfd_get_filename() macro.
<span class="lineNum">     639 </span>            : */
<a name="640"><span class="lineNum">     640 </span>            : </a>
<span class="lineNum">     641 </span>            : bfd *
<span class="lineNum">     642 </span><span class="lineNoCov">          0 : bfd_openw (const char *filename, const char *target)</span>
<span class="lineNum">     643 </span>            : {
<span class="lineNum">     644 </span>            :   bfd *nbfd;
<span class="lineNum">     645 </span>            :   const bfd_target *target_vec;
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            :   /* nbfd has to point to head of malloc'ed block so that bfd_close may
<span class="lineNum">     648 </span>            :      reclaim it correctly.  */
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   nbfd = _bfd_new_bfd ();</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :   if (nbfd == NULL)</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   target_vec = bfd_find_target (target, nbfd);</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   if (target_vec == NULL)</span>
<span class="lineNum">     655 </span>            :     {
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     658 </span>            :     }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :   /* PR 11983: Do not cache the original filename, but
<span class="lineNum">     661 </span>            :      rather make a copy - the original might go away.  */
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   nbfd-&gt;filename = xstrdup (filename);</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :   nbfd-&gt;direction = write_direction;</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   if (bfd_open_file (nbfd) == NULL)</span>
<span class="lineNum">     666 </span>            :     {
<span class="lineNum">     667 </span>            :       /* File not writeable, etc.  */
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :       _bfd_delete_bfd (nbfd);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     671 </span>            :   }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   return nbfd;</span>
<span class="lineNum">     674 </span>            : }
<a name="675"><span class="lineNum">     675 </span>            : </a>
<span class="lineNum">     676 </span>            : static inline void
<span class="lineNum">     677 </span><span class="lineCov">         11 : _maybe_make_executable (bfd * abfd)</span>
<span class="lineNum">     678 </span>            : {
<span class="lineNum">     679 </span>            :   /* If the file was open for writing and is now executable,
<span class="lineNum">     680 </span>            :      make it so.  */
<span class="lineNum">     681 </span><span class="lineCov">         11 :   if (abfd-&gt;direction == write_direction</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :       &amp;&amp; (abfd-&gt;flags &amp; (EXEC_P | DYNAMIC)) != 0)</span>
<span class="lineNum">     683 </span>            :     {
<span class="lineNum">     684 </span>            :       struct stat buf;
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :       if (stat (abfd-&gt;filename, &amp;buf) == 0</span>
<span class="lineNum">     687 </span>            :           /* Do not attempt to change non-regular files.  This is
<span class="lineNum">     688 </span>            :              here especially for configure scripts and kernel builds
<span class="lineNum">     689 </span>            :              which run tests with &quot;ld [...] -o /dev/null&quot;.  */
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :           &amp;&amp; S_ISREG(buf.st_mode))</span>
<span class="lineNum">     691 </span>            :         {
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :           unsigned int mask = umask (0);</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :           umask (mask);</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :           chmod (abfd-&gt;filename,</span>
<span class="lineNum">     696 </span>            :                  (0777
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                   &amp; (buf.st_mode | ((S_IXUSR | S_IXGRP | S_IXOTH) &amp;~ mask))));</span>
<span class="lineNum">     698 </span>            :         }
<span class="lineNum">     699 </span>            :     }
<span class="lineNum">     700 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : /*
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : FUNCTION
<span class="lineNum">     705 </span>            :         bfd_close
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            : SYNOPSIS
<span class="lineNum">     708 </span>            :         bfd_boolean bfd_close (bfd *abfd);
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            : DESCRIPTION
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :         Close a BFD. If the BFD was open for writing, then pending
<span class="lineNum">     713 </span>            :         operations are completed and the file written out and closed.
<span class="lineNum">     714 </span>            :         If the created file is executable, then &lt;&lt;chmod&gt;&gt; is called
<span class="lineNum">     715 </span>            :         to mark it as such.
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :         All memory attached to the BFD is released.
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :         The file descriptor associated with the BFD is closed (even
<span class="lineNum">     720 </span>            :         if it was passed in to BFD by &lt;&lt;bfd_fdopenr&gt;&gt;).
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            : RETURNS
<span class="lineNum">     723 </span>            :         &lt;&lt;TRUE&gt;&gt; is returned if all is ok, otherwise &lt;&lt;FALSE&gt;&gt;.
<span class="lineNum">     724 </span>            : */
<span class="lineNum">     725 </span>            : 
<a name="726"><span class="lineNum">     726 </span>            : </a>
<span class="lineNum">     727 </span>            : bfd_boolean
<span class="lineNum">     728 </span><span class="lineCov">         11 : bfd_close (bfd *abfd)</span>
<span class="lineNum">     729 </span>            : {
<span class="lineNum">     730 </span>            :   bfd_boolean ret;
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineCov">         11 :   if (bfd_write_p (abfd))</span>
<span class="lineNum">     733 </span>            :     {
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :       if (! BFD_SEND_FMT (abfd, _bfd_write_contents, (abfd)))</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     736 </span>            :     }
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineCov">         11 :   if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineCov">         11 :   ret = abfd-&gt;iovec-&gt;bclose (abfd) == 0;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineCov">         11 :   if (ret)</span>
<span class="lineNum">     744 </span><span class="lineCov">         11 :     _maybe_make_executable (abfd);</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineCov">         11 :   _bfd_delete_bfd (abfd);</span>
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span><span class="lineCov">         11 :   return ret;</span>
<span class="lineNum">     749 </span>            : }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            : /*
<span class="lineNum">     752 </span>            : FUNCTION
<span class="lineNum">     753 </span>            :         bfd_close_all_done
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : SYNOPSIS
<span class="lineNum">     756 </span>            :         bfd_boolean bfd_close_all_done (bfd *);
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            : DESCRIPTION
<span class="lineNum">     759 </span>            :         Close a BFD.  Differs from &lt;&lt;bfd_close&gt;&gt; since it does not
<span class="lineNum">     760 </span>            :         complete any pending operations.  This routine would be used
<span class="lineNum">     761 </span>            :         if the application had just used BFD for swapping and didn't
<span class="lineNum">     762 </span>            :         want to use any of the writing code.
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :         If the created file is executable, then &lt;&lt;chmod&gt;&gt; is called
<span class="lineNum">     765 </span>            :         to mark it as such.
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            :         All memory attached to the BFD is released.
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : RETURNS
<span class="lineNum">     770 </span>            :         &lt;&lt;TRUE&gt;&gt; is returned if all is ok, otherwise &lt;&lt;FALSE&gt;&gt;.
<span class="lineNum">     771 </span>            : */
<a name="772"><span class="lineNum">     772 </span>            : </a>
<span class="lineNum">     773 </span>            : bfd_boolean
<span class="lineNum">     774 </span><span class="lineNoCov">          0 : bfd_close_all_done (bfd *abfd)</span>
<span class="lineNum">     775 </span>            : {
<span class="lineNum">     776 </span>            :   bfd_boolean ret;
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   ret = bfd_cache_close (abfd);</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   if (ret)</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     _maybe_make_executable (abfd);</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   _bfd_delete_bfd (abfd);</span>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   return ret;</span>
<span class="lineNum">     786 </span>            : }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            : /*
<span class="lineNum">     789 </span>            : FUNCTION
<span class="lineNum">     790 </span>            :         bfd_create
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : SYNOPSIS
<span class="lineNum">     793 </span>            :         bfd *bfd_create (const char *filename, bfd *templ);
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            : DESCRIPTION
<span class="lineNum">     796 </span>            :         Create a new BFD in the manner of &lt;&lt;bfd_openw&gt;&gt;, but without
<span class="lineNum">     797 </span>            :         opening a file. The new BFD takes the target from the target
<span class="lineNum">     798 </span>            :         used by @var{templ}. The format is always set to &lt;&lt;bfd_object&gt;&gt;.
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :         A copy of the @var{filename} argument is stored in the newly created
<span class="lineNum">     801 </span>            :         BFD.  It can be accessed via the bfd_get_filename() macro.
<span class="lineNum">     802 </span>            : */
<a name="803"><span class="lineNum">     803 </span>            : </a>
<span class="lineNum">     804 </span>            : bfd *
<span class="lineNum">     805 </span><span class="lineNoCov">          0 : bfd_create (const char *filename, bfd *templ)</span>
<span class="lineNum">     806 </span>            : {
<span class="lineNum">     807 </span>            :   bfd *nbfd;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   nbfd = _bfd_new_bfd ();</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   if (nbfd == NULL)</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     812 </span>            :   /* PR 11983: Do not cache the original filename, but
<span class="lineNum">     813 </span>            :      rather make a copy - the original might go away.  */
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   nbfd-&gt;filename = xstrdup (filename);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   if (templ)</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     nbfd-&gt;xvec = templ-&gt;xvec;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :   nbfd-&gt;direction = no_direction;</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :   bfd_set_format (nbfd, bfd_object);</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   return nbfd;</span>
<span class="lineNum">     821 </span>            : }
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            : /*
<span class="lineNum">     824 </span>            : FUNCTION
<span class="lineNum">     825 </span>            :         bfd_make_writable
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : SYNOPSIS
<span class="lineNum">     828 </span>            :         bfd_boolean bfd_make_writable (bfd *abfd);
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : DESCRIPTION
<span class="lineNum">     831 </span>            :         Takes a BFD as created by &lt;&lt;bfd_create&gt;&gt; and converts it
<span class="lineNum">     832 </span>            :         into one like as returned by &lt;&lt;bfd_openw&gt;&gt;.  It does this
<span class="lineNum">     833 </span>            :         by converting the BFD to BFD_IN_MEMORY.  It's assumed that
<span class="lineNum">     834 </span>            :         you will call &lt;&lt;bfd_make_readable&gt;&gt; on this bfd later.
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            : RETURNS
<span class="lineNum">     837 </span>            :         &lt;&lt;TRUE&gt;&gt; is returned if all is ok, otherwise &lt;&lt;FALSE&gt;&gt;.
<span class="lineNum">     838 </span>            : */
<a name="839"><span class="lineNum">     839 </span>            : </a>
<span class="lineNum">     840 </span>            : bfd_boolean
<span class="lineNum">     841 </span><span class="lineNoCov">          0 : bfd_make_writable (bfd *abfd)</span>
<span class="lineNum">     842 </span>            : {
<span class="lineNum">     843 </span>            :   struct bfd_in_memory *bim;
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   if (abfd-&gt;direction != no_direction)</span>
<span class="lineNum">     846 </span>            :     {
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">     849 </span>            :     }
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   if (bim == NULL)</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     return FALSE;       /* bfd_error already set.  */</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :   abfd-&gt;iostream = bim;</span>
<span class="lineNum">     855 </span>            :   /* bfd_bwrite will grow these as needed.  */
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   bim-&gt;size = 0;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   bim-&gt;buffer = 0;</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   abfd-&gt;flags |= BFD_IN_MEMORY;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   abfd-&gt;iovec = &amp;_bfd_memory_iovec;</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   abfd-&gt;origin = 0;</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   abfd-&gt;direction = write_direction;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   abfd-&gt;where = 0;</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">     866 </span>            : }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : /*
<span class="lineNum">     869 </span>            : FUNCTION
<span class="lineNum">     870 </span>            :         bfd_make_readable
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            : SYNOPSIS
<span class="lineNum">     873 </span>            :         bfd_boolean bfd_make_readable (bfd *abfd);
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            : DESCRIPTION
<span class="lineNum">     876 </span>            :         Takes a BFD as created by &lt;&lt;bfd_create&gt;&gt; and
<span class="lineNum">     877 </span>            :         &lt;&lt;bfd_make_writable&gt;&gt; and converts it into one like as
<span class="lineNum">     878 </span>            :         returned by &lt;&lt;bfd_openr&gt;&gt;.  It does this by writing the
<span class="lineNum">     879 </span>            :         contents out to the memory buffer, then reversing the
<span class="lineNum">     880 </span>            :         direction.
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            : RETURNS
<span class="lineNum">     883 </span>            :         &lt;&lt;TRUE&gt;&gt; is returned if all is ok, otherwise &lt;&lt;FALSE&gt;&gt;.  */
<a name="884"><span class="lineNum">     884 </span>            : </a>
<span class="lineNum">     885 </span>            : bfd_boolean
<span class="lineNum">     886 </span><span class="lineNoCov">          0 : bfd_make_readable (bfd *abfd)</span>
<span class="lineNum">     887 </span>            : {
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   if (abfd-&gt;direction != write_direction || !(abfd-&gt;flags &amp; BFD_IN_MEMORY))</span>
<span class="lineNum">     889 </span>            :     {
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">     892 </span>            :     }
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   if (! BFD_SEND_FMT (abfd, _bfd_write_contents, (abfd)))</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   abfd-&gt;arch_info = &amp;bfd_default_arch_struct;</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   abfd-&gt;where = 0;</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :   abfd-&gt;format = bfd_unknown;</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   abfd-&gt;my_archive = NULL;</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   abfd-&gt;origin = 0;</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :   abfd-&gt;opened_once = FALSE;</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   abfd-&gt;output_has_begun = FALSE;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   abfd-&gt;section_count = 0;</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   abfd-&gt;usrdata = NULL;</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   abfd-&gt;cacheable = FALSE;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   abfd-&gt;flags |= BFD_IN_MEMORY;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   abfd-&gt;mtime_set = FALSE;</span>
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   abfd-&gt;target_defaulted = TRUE;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   abfd-&gt;direction = read_direction;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :   abfd-&gt;sections = 0;</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :   abfd-&gt;symcount = 0;</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   abfd-&gt;outsymbols = 0;</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   abfd-&gt;tdata.any = 0;</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   bfd_section_list_clear (abfd);</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   bfd_check_format (abfd, bfd_object);</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">     925 </span>            : }
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            : /*
<span class="lineNum">     928 </span>            : FUNCTION
<span class="lineNum">     929 </span>            :         bfd_alloc
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            : SYNOPSIS
<span class="lineNum">     932 </span>            :         void *bfd_alloc (bfd *abfd, bfd_size_type wanted);
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : DESCRIPTION
<span class="lineNum">     935 </span>            :         Allocate a block of @var{wanted} bytes of memory attached to
<span class="lineNum">     936 </span>            :         &lt;&lt;abfd&gt;&gt; and return a pointer to it.
<span class="lineNum">     937 </span>            : */
<a name="938"><span class="lineNum">     938 </span>            : </a>
<span class="lineNum">     939 </span>            : void *
<span class="lineNum">     940 </span><span class="lineCov">      10213 : bfd_alloc (bfd *abfd, bfd_size_type size)</span>
<span class="lineNum">     941 </span>            : {
<span class="lineNum">     942 </span>            :   void *ret;
<span class="lineNum">     943 </span><span class="lineCov">      10213 :   unsigned long ul_size = (unsigned long) size;</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineCov">      10213 :   if (size != ul_size</span>
<span class="lineNum">     946 </span>            :       /* Note - although objalloc_alloc takes an unsigned long as its
<span class="lineNum">     947 </span>            :          argument, internally the size is treated as a signed long.  This can
<span class="lineNum">     948 </span>            :          lead to problems where, for example, a request to allocate -1 bytes
<span class="lineNum">     949 </span>            :          can result in just 1 byte being allocated, rather than
<span class="lineNum">     950 </span>            :          ((unsigned long) -1) bytes.  Also memory checkers will often
<span class="lineNum">     951 </span>            :          complain about attempts to allocate a negative amount of memory.
<span class="lineNum">     952 </span>            :          So to stop these problems we fail if the size is negative.  */
<span class="lineNum">     953 </span><span class="lineCov">      10213 :       || ((signed long) ul_size) &lt; 0)</span>
<span class="lineNum">     954 </span>            :     {
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_memory);</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     957 </span>            :     }
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span><span class="lineCov">      10213 :   ret = objalloc_alloc ((struct objalloc *) abfd-&gt;memory, ul_size);</span>
<span class="lineNum">     960 </span><span class="lineCov">      10213 :   if (ret == NULL)</span>
<span class="lineNum">     961 </span><span class="lineCov">        143 :     bfd_set_error (bfd_error_no_memory);</span>
<span class="lineNum">     962 </span><span class="lineCov">      10213 :   return ret;</span>
<span class="lineNum">     963 </span>            : }
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            : /*
<span class="lineNum">     966 </span>            : INTERNAL_FUNCTION
<span class="lineNum">     967 </span>            :         bfd_alloc2
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            : SYNOPSIS
<span class="lineNum">     970 </span>            :         void *bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            : DESCRIPTION
<span class="lineNum">     973 </span>            :         Allocate a block of @var{nmemb} elements of @var{size} bytes each
<span class="lineNum">     974 </span>            :         of memory attached to &lt;&lt;abfd&gt;&gt; and return a pointer to it.
<span class="lineNum">     975 </span>            : */
<a name="976"><span class="lineNum">     976 </span>            : </a>
<span class="lineNum">     977 </span>            : void *
<span class="lineNum">     978 </span><span class="lineNoCov">          0 : bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size)</span>
<span class="lineNum">     979 </span>            : {
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   if ((nmemb | size) &gt;= HALF_BFD_SIZE_TYPE</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :       &amp;&amp; size != 0</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :       &amp;&amp; nmemb &gt; ~(bfd_size_type) 0 / size)</span>
<span class="lineNum">     983 </span>            :     {
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_memory);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     986 </span>            :     }
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :   return bfd_alloc (abfd, size * nmemb);</span>
<span class="lineNum">     989 </span>            : }
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            : /*
<span class="lineNum">     992 </span>            : FUNCTION
<span class="lineNum">     993 </span>            :         bfd_zalloc
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : SYNOPSIS
<span class="lineNum">     996 </span>            :         void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : DESCRIPTION
<span class="lineNum">     999 </span>            :         Allocate a block of @var{wanted} bytes of zeroed memory
<span class="lineNum">    1000 </span>            :         attached to &lt;&lt;abfd&gt;&gt; and return a pointer to it.
<span class="lineNum">    1001 </span>            : */
<a name="1002"><span class="lineNum">    1002 </span>            : </a>
<span class="lineNum">    1003 </span>            : void *
<span class="lineNum">    1004 </span><span class="lineCov">       6998 : bfd_zalloc (bfd *abfd, bfd_size_type size)</span>
<span class="lineNum">    1005 </span>            : {
<span class="lineNum">    1006 </span>            :   void *res;
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span><span class="lineCov">       6998 :   res = bfd_alloc (abfd, size);</span>
<span class="lineNum">    1009 </span><span class="lineCov">       6998 :   if (res)</span>
<span class="lineNum">    1010 </span><span class="lineCov">       6998 :     memset (res, 0, (size_t) size);</span>
<span class="lineNum">    1011 </span><span class="lineCov">       6998 :   return res;</span>
<span class="lineNum">    1012 </span>            : }
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            : /*
<span class="lineNum">    1015 </span>            : INTERNAL_FUNCTION
<span class="lineNum">    1016 </span>            :         bfd_zalloc2
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            : SYNOPSIS
<span class="lineNum">    1019 </span>            :         void *bfd_zalloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span>            : DESCRIPTION
<span class="lineNum">    1022 </span>            :         Allocate a block of @var{nmemb} elements of @var{size} bytes each
<span class="lineNum">    1023 </span>            :         of zeroed memory attached to &lt;&lt;abfd&gt;&gt; and return a pointer to it.
<span class="lineNum">    1024 </span>            : */
<a name="1025"><span class="lineNum">    1025 </span>            : </a>
<span class="lineNum">    1026 </span>            : void *
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 : bfd_zalloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size)</span>
<span class="lineNum">    1028 </span>            : {
<span class="lineNum">    1029 </span>            :   void *res;
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   if ((nmemb | size) &gt;= HALF_BFD_SIZE_TYPE</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :       &amp;&amp; size != 0</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :       &amp;&amp; nmemb &gt; ~(bfd_size_type) 0 / size)</span>
<span class="lineNum">    1034 </span>            :     {
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_memory);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1037 </span>            :     }
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   size *= nmemb;</span>
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   res = bfd_alloc (abfd, size);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   if (res)</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     memset (res, 0, (size_t) size);</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   return res;</span>
<span class="lineNum">    1045 </span>            : }
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span>            : /* Free a block allocated for a BFD.
<span class="lineNum">    1048 </span>            :    Note:  Also frees all more recently allocated blocks!  */
<a name="1049"><span class="lineNum">    1049 </span>            : </a>
<span class="lineNum">    1050 </span>            : void
<span class="lineNum">    1051 </span><span class="lineCov">        194 : bfd_release (bfd *abfd, void *block)</span>
<span class="lineNum">    1052 </span>            : {
<span class="lineNum">    1053 </span><span class="lineCov">        194 :   objalloc_free_block ((struct objalloc *) abfd-&gt;memory, block);</span>
<span class="lineNum">    1054 </span><span class="lineCov">        194 : }</span>
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : /*
<span class="lineNum">    1058 </span>            :    GNU Extension: separate debug-info files
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :    The idea here is that a special section called .gnu_debuglink might be
<span class="lineNum">    1061 </span>            :    embedded in a binary file, which indicates that some *other* file
<span class="lineNum">    1062 </span>            :    contains the real debugging information. This special section contains a
<span class="lineNum">    1063 </span>            :    filename and CRC32 checksum, which we read and resolve to another file,
<span class="lineNum">    1064 </span>            :    if it exists.
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :    This facilitates &quot;optional&quot; provision of debugging information, without
<span class="lineNum">    1067 </span>            :    having to provide two complete copies of every binary object (with and
<span class="lineNum">    1068 </span>            :    without debug symbols).  */
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            : #define GNU_DEBUGLINK           &quot;.gnu_debuglink&quot;
<span class="lineNum">    1071 </span>            : #define GNU_DEBUGALTLINK        &quot;.gnu_debugaltlink&quot;
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            : /*
<span class="lineNum">    1074 </span>            : FUNCTION
<span class="lineNum">    1075 </span>            :         bfd_calc_gnu_debuglink_crc32
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            : SYNOPSIS
<span class="lineNum">    1078 </span>            :         unsigned long bfd_calc_gnu_debuglink_crc32
<span class="lineNum">    1079 </span>            :           (unsigned long crc, const unsigned char *buf, bfd_size_type len);
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            : DESCRIPTION
<span class="lineNum">    1082 </span>            :         Computes a CRC value as used in the .gnu_debuglink section.
<span class="lineNum">    1083 </span>            :         Advances the previously computed @var{crc} value by computing
<span class="lineNum">    1084 </span>            :         and adding in the crc32 for @var{len} bytes of @var{buf}.
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            : RETURNS
<span class="lineNum">    1087 </span>            :         Return the updated CRC32 value.
<span class="lineNum">    1088 </span>            : */
<a name="1089"><span class="lineNum">    1089 </span>            : </a>
<span class="lineNum">    1090 </span>            : unsigned long
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 : bfd_calc_gnu_debuglink_crc32 (unsigned long crc,</span>
<span class="lineNum">    1092 </span>            :                               const unsigned char *buf,
<span class="lineNum">    1093 </span>            :                               bfd_size_type len)
<span class="lineNum">    1094 </span>            : {
<span class="lineNum">    1095 </span>            :   static const unsigned long crc32_table[256] =
<span class="lineNum">    1096 </span>            :     {
<span class="lineNum">    1097 </span>            :       0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
<span class="lineNum">    1098 </span>            :       0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
<span class="lineNum">    1099 </span>            :       0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
<span class="lineNum">    1100 </span>            :       0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
<span class="lineNum">    1101 </span>            :       0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
<span class="lineNum">    1102 </span>            :       0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
<span class="lineNum">    1103 </span>            :       0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
<span class="lineNum">    1104 </span>            :       0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
<span class="lineNum">    1105 </span>            :       0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
<span class="lineNum">    1106 </span>            :       0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
<span class="lineNum">    1107 </span>            :       0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
<span class="lineNum">    1108 </span>            :       0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
<span class="lineNum">    1109 </span>            :       0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
<span class="lineNum">    1110 </span>            :       0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
<span class="lineNum">    1111 </span>            :       0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
<span class="lineNum">    1112 </span>            :       0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
<span class="lineNum">    1113 </span>            :       0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
<span class="lineNum">    1114 </span>            :       0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
<span class="lineNum">    1115 </span>            :       0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
<span class="lineNum">    1116 </span>            :       0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
<span class="lineNum">    1117 </span>            :       0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
<span class="lineNum">    1118 </span>            :       0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
<span class="lineNum">    1119 </span>            :       0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
<span class="lineNum">    1120 </span>            :       0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
<span class="lineNum">    1121 </span>            :       0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
<span class="lineNum">    1122 </span>            :       0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
<span class="lineNum">    1123 </span>            :       0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
<span class="lineNum">    1124 </span>            :       0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
<span class="lineNum">    1125 </span>            :       0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
<span class="lineNum">    1126 </span>            :       0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
<span class="lineNum">    1127 </span>            :       0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
<span class="lineNum">    1128 </span>            :       0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
<span class="lineNum">    1129 </span>            :       0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
<span class="lineNum">    1130 </span>            :       0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
<span class="lineNum">    1131 </span>            :       0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
<span class="lineNum">    1132 </span>            :       0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
<span class="lineNum">    1133 </span>            :       0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
<span class="lineNum">    1134 </span>            :       0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
<span class="lineNum">    1135 </span>            :       0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
<span class="lineNum">    1136 </span>            :       0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
<span class="lineNum">    1137 </span>            :       0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
<span class="lineNum">    1138 </span>            :       0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
<span class="lineNum">    1139 </span>            :       0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
<span class="lineNum">    1140 </span>            :       0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
<span class="lineNum">    1141 </span>            :       0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
<span class="lineNum">    1142 </span>            :       0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
<span class="lineNum">    1143 </span>            :       0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
<span class="lineNum">    1144 </span>            :       0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
<span class="lineNum">    1145 </span>            :       0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
<span class="lineNum">    1146 </span>            :       0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
<span class="lineNum">    1147 </span>            :       0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
<span class="lineNum">    1148 </span>            :       0x2d02ef8d
<span class="lineNum">    1149 </span>            :     };
<span class="lineNum">    1150 </span>            :   const unsigned char *end;
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   crc = ~crc &amp; 0xffffffff;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   for (end = buf + len; buf &lt; end; ++ buf)</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     crc = crc32_table[(crc ^ *buf) &amp; 0xff] ^ (crc &gt;&gt; 8);</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   return ~crc &amp; 0xffffffff;</span>
<span class="lineNum">    1156 </span>            : }
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            : /*
<span class="lineNum">    1160 </span>            : FUNCTION
<span class="lineNum">    1161 </span>            :         bfd_get_debug_link_info
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            : SYNOPSIS
<span class="lineNum">    1164 </span>            :         char *bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out);
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            : DESCRIPTION
<span class="lineNum">    1167 </span>            :         Fetch the filename and CRC32 value for any separate debuginfo
<span class="lineNum">    1168 </span>            :         associated with @var{abfd}.  Return NULL if no such info found,
<span class="lineNum">    1169 </span>            :         otherwise return filename and update @var{crc32_out}.  The
<span class="lineNum">    1170 </span>            :         returned filename is allocated with @code{malloc}; freeing it
<span class="lineNum">    1171 </span>            :         is the responsibility of the caller.
<span class="lineNum">    1172 </span>            : */
<a name="1173"><span class="lineNum">    1173 </span>            : </a>
<span class="lineNum">    1174 </span>            : char *
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 : bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out)</span>
<span class="lineNum">    1176 </span>            : {
<span class="lineNum">    1177 </span>            :   asection *sect;
<span class="lineNum">    1178 </span>            :   unsigned long crc32;
<span class="lineNum">    1179 </span>            :   bfd_byte *contents;
<span class="lineNum">    1180 </span>            :   unsigned int crc_offset;
<span class="lineNum">    1181 </span>            :   char *name;
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :   BFD_ASSERT (abfd);</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   BFD_ASSERT (crc32_out);</span>
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   if (sect == NULL)</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   if (!bfd_malloc_and_get_section (abfd, sect, &amp;contents))</span>
<span class="lineNum">    1192 </span>            :     {
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :       if (contents != NULL)</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         free (contents);</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :   /* CRC value is stored after the filename, aligned up to 4 bytes.  */
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   name = (char *) contents;</span>
<span class="lineNum">    1200 </span>            :   /* PR 17597: avoid reading off the end of the buffer.  */
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   crc_offset = strnlen (name, bfd_get_section_size (sect)) + 1;</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   crc_offset = (crc_offset + 3) &amp; ~3;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   if (crc_offset &gt;= bfd_get_section_size (sect))</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :   crc32 = bfd_get_32 (abfd, contents + crc_offset);</span>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   *crc32_out = crc32;</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   return name;</span>
<span class="lineNum">    1210 </span>            : }
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            : /*
<span class="lineNum">    1213 </span>            : FUNCTION
<span class="lineNum">    1214 </span>            :         bfd_get_alt_debug_link_info
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            : SYNOPSIS
<span class="lineNum">    1217 </span>            :         char *bfd_get_alt_debug_link_info (bfd * abfd,
<span class="lineNum">    1218 </span>            :                                            bfd_size_type *buildid_len,
<span class="lineNum">    1219 </span>            :                                            bfd_byte **buildid_out);
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            : DESCRIPTION
<span class="lineNum">    1222 </span>            :         Fetch the filename and BuildID value for any alternate debuginfo
<span class="lineNum">    1223 </span>            :         associated with @var{abfd}.  Return NULL if no such info found,
<span class="lineNum">    1224 </span>            :         otherwise return filename and update @var{buildid_len} and
<span class="lineNum">    1225 </span>            :         @var{buildid_out}.  The returned filename and build_id are
<span class="lineNum">    1226 </span>            :         allocated with @code{malloc}; freeing them is the
<span class="lineNum">    1227 </span>            :         responsibility of the caller.
<span class="lineNum">    1228 </span>            : */
<a name="1229"><span class="lineNum">    1229 </span>            : </a>
<span class="lineNum">    1230 </span>            : char *
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 : bfd_get_alt_debug_link_info (bfd * abfd, bfd_size_type *buildid_len,</span>
<span class="lineNum">    1232 </span>            :                              bfd_byte **buildid_out)
<span class="lineNum">    1233 </span>            : {
<span class="lineNum">    1234 </span>            :   asection *sect;
<span class="lineNum">    1235 </span>            :   bfd_byte *contents;
<span class="lineNum">    1236 </span>            :   unsigned int buildid_offset;
<span class="lineNum">    1237 </span>            :   char *name;
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :   BFD_ASSERT (abfd);</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :   BFD_ASSERT (buildid_len);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   BFD_ASSERT (buildid_out);</span>
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :   sect = bfd_get_section_by_name (abfd, GNU_DEBUGALTLINK);</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :   if (sect == NULL)</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :   if (!bfd_malloc_and_get_section (abfd, sect, &amp; contents))</span>
<span class="lineNum">    1249 </span>            :     {
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :       if (contents != NULL)</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :         free (contents);</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1253 </span>            :     }
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            :   /* BuildID value is stored after the filename.  */
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :   name = (char *) contents;</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :   buildid_offset = strnlen (name, bfd_get_section_size (sect)) + 1;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :   if (buildid_offset &gt;= bfd_get_section_size (sect))</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   *buildid_len = bfd_get_section_size (sect) - buildid_offset;</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :   *buildid_out = bfd_malloc (*buildid_len);</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :   memcpy (*buildid_out, contents + buildid_offset, *buildid_len);</span>
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :   return name;</span>
<span class="lineNum">    1266 </span>            : }
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            : /*
<span class="lineNum">    1269 </span>            : INTERNAL_FUNCTION
<span class="lineNum">    1270 </span>            :         separate_debug_file_exists
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            : SYNOPSIS
<span class="lineNum">    1273 </span>            :         bfd_boolean separate_debug_file_exists
<span class="lineNum">    1274 </span>            :           (char *name, unsigned long crc32);
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            : DESCRIPTION
<span class="lineNum">    1277 </span>            :         Checks to see if @var{name} is a file and if its contents
<span class="lineNum">    1278 </span>            :         match @var{crc32}.
<span class="lineNum">    1279 </span>            : */
<a name="1280"><span class="lineNum">    1280 </span>            : </a>
<span class="lineNum">    1281 </span>            : static bfd_boolean
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 : separate_debug_file_exists (const char *name, const unsigned long crc)</span>
<span class="lineNum">    1283 </span>            : {
<span class="lineNum">    1284 </span>            :   static unsigned char buffer [8 * 1024];
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :   unsigned long file_crc = 0;</span>
<span class="lineNum">    1286 </span>            :   FILE *f;
<span class="lineNum">    1287 </span>            :   bfd_size_type count;
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :   BFD_ASSERT (name);</span>
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :   f = real_fopen (name, FOPEN_RB);</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   if (f == NULL)</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :   while ((count = fread (buffer, 1, sizeof (buffer), f)) &gt; 0)</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     file_crc = bfd_calc_gnu_debuglink_crc32 (file_crc, buffer, count);</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   fclose (f);</span>
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   return crc == file_crc;</span>
<span class="lineNum">    1301 </span>            : }
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            : /*
<span class="lineNum">    1304 </span>            : INTERNAL_FUNCTION
<span class="lineNum">    1305 </span>            :         separate_alt_debug_file_exists
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            : SYNOPSIS
<span class="lineNum">    1308 </span>            :         bfd_boolean separate_alt_debug_file_exists
<span class="lineNum">    1309 </span>            :           (char *name, unsigned long buildid);
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            : DESCRIPTION
<span class="lineNum">    1312 </span>            :         Checks to see if @var{name} is a file and if its BuildID
<span class="lineNum">    1313 </span>            :         matches @var{buildid}.
<span class="lineNum">    1314 </span>            : */
<a name="1315"><span class="lineNum">    1315 </span>            : </a>
<span class="lineNum">    1316 </span>            : static bfd_boolean
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 : separate_alt_debug_file_exists (const char *name,</span>
<span class="lineNum">    1318 </span>            :                                 const unsigned long buildid ATTRIBUTE_UNUSED)
<span class="lineNum">    1319 </span>            : {
<span class="lineNum">    1320 </span>            :   FILE *f;
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :   BFD_ASSERT (name);</span>
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :   f = real_fopen (name, FOPEN_RB);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   if (f == NULL)</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :   /* FIXME: Add code to check buildid.  */
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   fclose (f);</span>
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    1333 </span>            : }
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            : /*
<span class="lineNum">    1336 </span>            : INTERNAL_FUNCTION
<span class="lineNum">    1337 </span>            :         find_separate_debug_file
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            : SYNOPSIS
<span class="lineNum">    1340 </span>            :         char *find_separate_debug_file
<span class="lineNum">    1341 </span>            :           (bfd *abfd, const char *dir, bfd_boolean include_dirs,
<span class="lineNum">    1342 </span>            :            get_func_type get, check_func_type check);
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            : DESCRIPTION
<span class="lineNum">    1345 </span>            :         Searches for a debug information file corresponding to @var{abfd}.
<span class="lineNum">    1346 </span>            :         The name of the separate debug info file is returned by the @var{get}
<span class="lineNum">    1347 </span>            :         function.  This function scans various fixed locations in the
<span class="lineNum">    1348 </span>            :         filesystem, including the file tree rooted at @var{dir}.  If the
<span class="lineNum">    1349 </span>            :         @var{include_dirs} parameter is true then the directory components of
<span class="lineNum">    1350 </span>            :         @var{abfd}'s filename will be included in the searched locations.
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            :         Returns the filename of the first file to be found which receives a
<span class="lineNum">    1353 </span>            :         TRUE result from the @var{check} function.  Returns NULL if no valid
<span class="lineNum">    1354 </span>            :         file could be found.
<span class="lineNum">    1355 </span>            : */
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            : typedef char *      (* get_func_type) (bfd *, unsigned long *);
<span class="lineNum">    1358 </span>            : typedef bfd_boolean (* check_func_type) (const char *, const unsigned long);
<a name="1359"><span class="lineNum">    1359 </span>            : </a>
<span class="lineNum">    1360 </span>            : static char *
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 : find_separate_debug_file (bfd *           abfd,</span>
<span class="lineNum">    1362 </span>            :                           const char *    debug_file_directory,
<span class="lineNum">    1363 </span>            :                           bfd_boolean     include_dirs,
<span class="lineNum">    1364 </span>            :                           get_func_type   get_func,
<span class="lineNum">    1365 </span>            :                           check_func_type check_func)
<span class="lineNum">    1366 </span>            : {
<span class="lineNum">    1367 </span>            :   char *base;
<span class="lineNum">    1368 </span>            :   char *dir;
<span class="lineNum">    1369 </span>            :   char *debugfile;
<span class="lineNum">    1370 </span>            :   char *canon_dir;
<span class="lineNum">    1371 </span>            :   unsigned long crc32;
<span class="lineNum">    1372 </span>            :   size_t dirlen;
<span class="lineNum">    1373 </span>            :   size_t canon_dirlen;
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :   BFD_ASSERT (abfd);</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :   if (debug_file_directory == NULL)</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     debug_file_directory = &quot;.&quot;;</span>
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :   /* BFD may have been opened from a stream.  */
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :   if (abfd-&gt;filename == NULL)</span>
<span class="lineNum">    1381 </span>            :     {
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1384 </span>            :     }
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :   base = get_func (abfd, &amp; crc32);</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :   if (base == NULL)</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :   if (base[0] == '\0')</span>
<span class="lineNum">    1392 </span>            :     {
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :       free (base);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_debug_section);</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1396 </span>            :     }
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :   if (include_dirs)</span>
<span class="lineNum">    1399 </span>            :     {
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :       for (dirlen = strlen (abfd-&gt;filename); dirlen &gt; 0; dirlen--)</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :         if (IS_DIR_SEPARATOR (abfd-&gt;filename[dirlen - 1]))</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :       dir = (char *) bfd_malloc (dirlen + 1);</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :       if (dir == NULL)</span>
<span class="lineNum">    1406 </span>            :         {
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :           free (base);</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :           return NULL;</span>
<span class="lineNum">    1409 </span>            :         }
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :       memcpy (dir, abfd-&gt;filename, dirlen);</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :       dir[dirlen] = '\0';</span>
<span class="lineNum">    1412 </span>            :     }
<span class="lineNum">    1413 </span>            :   else
<span class="lineNum">    1414 </span>            :     {
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :       dir = (char *) bfd_malloc (1);</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :       * dir = 0;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :       dirlen = 0;</span>
<span class="lineNum">    1418 </span>            :     }
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            :   /* Compute the canonical name of the bfd object with all symbolic links
<span class="lineNum">    1421 </span>            :      resolved, for use in the global debugfile directory.  */
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :   canon_dir = lrealpath (abfd-&gt;filename);</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :   for (canon_dirlen = strlen (canon_dir); canon_dirlen &gt; 0; canon_dirlen--)</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :     if (IS_DIR_SEPARATOR (canon_dir[canon_dirlen - 1]))</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :   canon_dir[canon_dirlen] = '\0';</span>
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            : #ifndef EXTRA_DEBUG_ROOT1
<span class="lineNum">    1429 </span>            : #define EXTRA_DEBUG_ROOT1 &quot;/usr/lib/debug&quot;
<span class="lineNum">    1430 </span>            : #endif
<span class="lineNum">    1431 </span>            : #ifndef EXTRA_DEBUG_ROOT2
<span class="lineNum">    1432 </span>            : #define EXTRA_DEBUG_ROOT2 &quot;/usr/lib/debug/usr&quot;
<span class="lineNum">    1433 </span>            : #endif  
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :   debugfile = (char *)</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :       bfd_malloc (strlen (debug_file_directory) + 1</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :                   + (canon_dirlen &gt; dirlen ? canon_dirlen : dirlen)</span>
<span class="lineNum">    1438 </span>            :                   + strlen (&quot;.debug/&quot;)
<span class="lineNum">    1439 </span>            : #ifdef EXTRA_DEBUG_ROOT1
<span class="lineNum">    1440 </span>            :                   + strlen (EXTRA_DEBUG_ROOT1)
<span class="lineNum">    1441 </span>            : #endif
<span class="lineNum">    1442 </span>            : #ifdef EXTRA_DEBUG_ROOT2
<span class="lineNum">    1443 </span>            :                   + strlen (EXTRA_DEBUG_ROOT2)
<span class="lineNum">    1444 </span>            : #endif
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :                   + strlen (base)</span>
<span class="lineNum">    1446 </span>            :                   + 1);
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :   if (debugfile == NULL)</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     goto found; /* Actually this returns NULL.  */</span>
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span>            :   /* First try in the same directory as the original file.
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            :      FIXME: Strictly speaking if we are using the build-id method,
<span class="lineNum">    1453 </span>            :      (ie include_dirs == FALSE) then we should only check absolute
<span class="lineNum">    1454 </span>            :      paths, not relative ones like this one (and the next one).
<span class="lineNum">    1455 </span>            :      The check is left in however as this allows the binutils
<span class="lineNum">    1456 </span>            :      testsuite to exercise this feature without having to install
<span class="lineNum">    1457 </span>            :      a file into the root filesystem.  (See binutils/testsuite/
<span class="lineNum">    1458 </span>            :      binutils-all/objdump.exp for the test).  */
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :   sprintf (debugfile, &quot;%s%s&quot;, dir, base);</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   if (check_func (debugfile, crc32))</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     goto found;</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            :   /* Then try in a subdirectory called .debug.  */
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   sprintf (debugfile, &quot;%s.debug/%s&quot;, dir, base);</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   if (check_func (debugfile, crc32))</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :     goto found;</span>
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span>            : #ifdef EXTRA_DEBUG_ROOT1
<span class="lineNum">    1469 </span>            :   /* Try the first extra debug file root.  */
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :   sprintf (debugfile, &quot;%s%s%s&quot;, EXTRA_DEBUG_ROOT1,</span>
<span class="lineNum">    1471 </span>            :            include_dirs ? canon_dir : &quot;/&quot;, base);
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :   if (check_func (debugfile, crc32))</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :     goto found;</span>
<span class="lineNum">    1474 </span>            : #endif
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            : #ifdef EXTRA_DEBUG_ROOT2
<span class="lineNum">    1477 </span>            :   /* Try the second extra debug file root.  */
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :   sprintf (debugfile, &quot;%s%s%s&quot;, EXTRA_DEBUG_ROOT2,</span>
<span class="lineNum">    1479 </span>            :            include_dirs ? canon_dir : &quot;/&quot;, base);
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :   if (check_func (debugfile, crc32))</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :     goto found;</span>
<span class="lineNum">    1482 </span>            : #endif
<span class="lineNum">    1483 </span>            :   
<span class="lineNum">    1484 </span>            :   /* Then try in the global debugfile directory.  */
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :   strcpy (debugfile, debug_file_directory);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :   dirlen = strlen (debug_file_directory) - 1;</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :   if (include_dirs)</span>
<span class="lineNum">    1488 </span>            :     {
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :       if (dirlen &gt; 0</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :           &amp;&amp; debug_file_directory[dirlen] != '/'</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :           &amp;&amp; canon_dir[0] != '/')</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :         strcat (debugfile, &quot;/&quot;);</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :       strcat (debugfile, canon_dir);</span>
<span class="lineNum">    1494 </span>            :     }
<span class="lineNum">    1495 </span>            :   else
<span class="lineNum">    1496 </span>            :     {
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :       if (dirlen &gt; 0 &amp;&amp; debug_file_directory[dirlen] != '/')</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :         strcat (debugfile, &quot;/&quot;);</span>
<span class="lineNum">    1499 </span>            :     }
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   strcat (debugfile, base);</span>
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :   if (check_func (debugfile, crc32))</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :     goto found;</span>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :   /* Failed to find the file.  */
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   free (debugfile);</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :   debugfile = NULL;</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :  found:</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :   free (base);</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   free (dir);</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   free (canon_dir);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   return debugfile;</span>
<span class="lineNum">    1514 </span>            : }
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            : /*
<span class="lineNum">    1518 </span>            : FUNCTION
<span class="lineNum">    1519 </span>            :         bfd_follow_gnu_debuglink
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            : SYNOPSIS
<span class="lineNum">    1522 </span>            :         char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span>            : DESCRIPTION
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :         Takes a BFD and searches it for a .gnu_debuglink section.  If this
<span class="lineNum">    1527 </span>            :         section is found, it examines the section for the name and checksum
<span class="lineNum">    1528 </span>            :         of a '.debug' file containing auxiliary debugging information.  It
<span class="lineNum">    1529 </span>            :         then searches the filesystem for this .debug file in some standard
<span class="lineNum">    1530 </span>            :         locations, including the directory tree rooted at @var{dir}, and if
<span class="lineNum">    1531 </span>            :         found returns the full filename.
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            :         If @var{dir} is NULL, the search will take place starting at
<span class="lineNum">    1534 </span>            :         the current directory.
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            : RETURNS
<span class="lineNum">    1537 </span>            :         &lt;&lt;NULL&gt;&gt; on any errors or failure to locate the .debug file,
<span class="lineNum">    1538 </span>            :         otherwise a pointer to a heap-allocated string containing the
<span class="lineNum">    1539 </span>            :         filename.  The caller is responsible for freeing this string.
<span class="lineNum">    1540 </span>            : */
<a name="1541"><span class="lineNum">    1541 </span>            : </a>
<span class="lineNum">    1542 </span>            : char *
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 : bfd_follow_gnu_debuglink (bfd *abfd, const char *dir)</span>
<span class="lineNum">    1544 </span>            : {
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :   return find_separate_debug_file (abfd, dir, TRUE,</span>
<span class="lineNum">    1546 </span>            :                                    bfd_get_debug_link_info,
<span class="lineNum">    1547 </span>            :                                    separate_debug_file_exists);
<span class="lineNum">    1548 </span>            : }
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            : /* Helper for bfd_follow_gnu_debugaltlink.  It just pretends to return
<span class="lineNum">    1551 </span>            :    a CRC.  .gnu_debugaltlink supplies a build-id, which is different,
<span class="lineNum">    1552 </span>            :    but this is ok because separate_alt_debug_file_exists ignores the
<span class="lineNum">    1553 </span>            :    CRC anyway.  */
<a name="1554"><span class="lineNum">    1554 </span>            : </a>
<span class="lineNum">    1555 </span>            : static char *
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 : get_alt_debug_link_info_shim (bfd * abfd, unsigned long *crc32_out)</span>
<span class="lineNum">    1557 </span>            : {
<span class="lineNum">    1558 </span>            :   bfd_size_type len;
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :   bfd_byte *buildid = NULL;</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :   char *result = bfd_get_alt_debug_link_info (abfd, &amp;len, &amp;buildid);</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :   *crc32_out = 0;</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   free (buildid);</span>
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    1566 </span>            : }
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            : /*
<span class="lineNum">    1569 </span>            : FUNCTION
<span class="lineNum">    1570 </span>            :         bfd_follow_gnu_debugaltlink
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span>            : SYNOPSIS
<span class="lineNum">    1573 </span>            :         char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span>            : DESCRIPTION
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            :         Takes a BFD and searches it for a .gnu_debugaltlink section.  If this
<span class="lineNum">    1578 </span>            :         section is found, it examines the section for the name of a file
<span class="lineNum">    1579 </span>            :         containing auxiliary debugging information.  It then searches the
<span class="lineNum">    1580 </span>            :         filesystem for this file in a set of standard locations, including
<span class="lineNum">    1581 </span>            :         the directory tree rooted at @var{dir}, and if found returns the
<span class="lineNum">    1582 </span>            :         full filename.
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span>            :         If @var{dir} is NULL, the search will take place starting at
<span class="lineNum">    1585 </span>            :         the current directory.
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span>            : RETURNS
<span class="lineNum">    1588 </span>            :         &lt;&lt;NULL&gt;&gt; on any errors or failure to locate the debug file,
<span class="lineNum">    1589 </span>            :         otherwise a pointer to a heap-allocated string containing the
<span class="lineNum">    1590 </span>            :         filename.  The caller is responsible for freeing this string.
<span class="lineNum">    1591 </span>            : */
<a name="1592"><span class="lineNum">    1592 </span>            : </a>
<span class="lineNum">    1593 </span>            : char *
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 : bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir)</span>
<span class="lineNum">    1595 </span>            : {
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :   return find_separate_debug_file (abfd, dir, TRUE,</span>
<span class="lineNum">    1597 </span>            :                                    get_alt_debug_link_info_shim,
<span class="lineNum">    1598 </span>            :                                    separate_alt_debug_file_exists);
<span class="lineNum">    1599 </span>            : }
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            : /*
<span class="lineNum">    1602 </span>            : FUNCTION
<span class="lineNum">    1603 </span>            :         bfd_create_gnu_debuglink_section
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span>            : SYNOPSIS
<span class="lineNum">    1606 </span>            :         struct bfd_section *bfd_create_gnu_debuglink_section
<span class="lineNum">    1607 </span>            :           (bfd *abfd, const char *filename);
<span class="lineNum">    1608 </span>            : 
<span class="lineNum">    1609 </span>            : DESCRIPTION
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :         Takes a @var{BFD} and adds a .gnu_debuglink section to it.  The section is sized
<span class="lineNum">    1612 </span>            :         to be big enough to contain a link to the specified @var{filename}.
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            : RETURNS
<span class="lineNum">    1615 </span>            :         A pointer to the new section is returned if all is ok.  Otherwise &lt;&lt;NULL&gt;&gt; is
<span class="lineNum">    1616 </span>            :         returned and bfd_error is set.
<span class="lineNum">    1617 </span>            : */
<a name="1618"><span class="lineNum">    1618 </span>            : </a>
<span class="lineNum">    1619 </span>            : asection *
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 : bfd_create_gnu_debuglink_section (bfd *abfd, const char *filename)</span>
<span class="lineNum">    1621 </span>            : {
<span class="lineNum">    1622 </span>            :   asection *sect;
<span class="lineNum">    1623 </span>            :   bfd_size_type debuglink_size;
<span class="lineNum">    1624 </span>            :   flagword flags;
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :   if (abfd == NULL || filename == NULL)</span>
<span class="lineNum">    1627 </span>            :     {
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1630 </span>            :     }
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span>            :   /* Strip off any path components in filename.  */
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :   filename = lbasename (filename);</span>
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   if (sect)</span>
<span class="lineNum">    1637 </span>            :     {
<span class="lineNum">    1638 </span>            :       /* Section already exists.  */
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1641 </span>            :     }
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :   flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING;</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :   sect = bfd_make_section_with_flags (abfd, GNU_DEBUGLINK, flags);</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :   if (sect == NULL)</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :   debuglink_size = strlen (filename) + 1;</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :   debuglink_size += 3;</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   debuglink_size &amp;= ~3;</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :   debuglink_size += 4;</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :   if (! bfd_set_section_size (abfd, sect, debuglink_size))</span>
<span class="lineNum">    1654 </span>            :     /* XXX Should we delete the section from the bfd ?  */
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :   return sect;</span>
<span class="lineNum">    1658 </span>            : }
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            : /*
<span class="lineNum">    1662 </span>            : FUNCTION
<span class="lineNum">    1663 </span>            :         bfd_fill_in_gnu_debuglink_section
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            : SYNOPSIS
<span class="lineNum">    1666 </span>            :         bfd_boolean bfd_fill_in_gnu_debuglink_section
<span class="lineNum">    1667 </span>            :           (bfd *abfd, struct bfd_section *sect, const char *filename);
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span>            : DESCRIPTION
<span class="lineNum">    1670 </span>            : 
<span class="lineNum">    1671 </span>            :         Takes a @var{BFD} and containing a .gnu_debuglink section @var{SECT}
<span class="lineNum">    1672 </span>            :         and fills in the contents of the section to contain a link to the
<span class="lineNum">    1673 </span>            :         specified @var{filename}.  The filename should be relative to the
<span class="lineNum">    1674 </span>            :         current directory.
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            : RETURNS
<span class="lineNum">    1677 </span>            :         &lt;&lt;TRUE&gt;&gt; is returned if all is ok.  Otherwise &lt;&lt;FALSE&gt;&gt; is returned
<span class="lineNum">    1678 </span>            :         and bfd_error is set.
<span class="lineNum">    1679 </span>            : */
<a name="1680"><span class="lineNum">    1680 </span>            : </a>
<span class="lineNum">    1681 </span>            : bfd_boolean
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 : bfd_fill_in_gnu_debuglink_section (bfd *abfd,</span>
<span class="lineNum">    1683 </span>            :                                    struct bfd_section *sect,
<span class="lineNum">    1684 </span>            :                                    const char *filename)
<span class="lineNum">    1685 </span>            : {
<span class="lineNum">    1686 </span>            :   bfd_size_type debuglink_size;
<span class="lineNum">    1687 </span>            :   unsigned long crc32;
<span class="lineNum">    1688 </span>            :   char * contents;
<span class="lineNum">    1689 </span>            :   bfd_size_type crc_offset;
<span class="lineNum">    1690 </span>            :   FILE * handle;
<span class="lineNum">    1691 </span>            :   static unsigned char buffer[8 * 1024];
<span class="lineNum">    1692 </span>            :   size_t count;
<span class="lineNum">    1693 </span>            :   size_t filelen;
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :   if (abfd == NULL || sect == NULL || filename == NULL)</span>
<span class="lineNum">    1696 </span>            :     {
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1699 </span>            :     }
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span>            :   /* Make sure that we can read the file.
<span class="lineNum">    1702 </span>            :      XXX - Should we attempt to locate the debug info file using the same
<span class="lineNum">    1703 </span>            :      algorithm as gdb ?  At the moment, since we are creating the
<span class="lineNum">    1704 </span>            :      .gnu_debuglink section, we insist upon the user providing us with a
<span class="lineNum">    1705 </span>            :      correct-for-section-creation-time path, but this need not conform to
<span class="lineNum">    1706 </span>            :      the gdb location algorithm.  */
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :   handle = real_fopen (filename, FOPEN_RB);</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :   if (handle == NULL)</span>
<span class="lineNum">    1709 </span>            :     {
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_system_call);</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1712 </span>            :     }
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :   crc32 = 0;</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :   while ((count = fread (buffer, 1, sizeof buffer, handle)) &gt; 0)</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :     crc32 = bfd_calc_gnu_debuglink_crc32 (crc32, buffer, count);</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :   fclose (handle);</span>
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            :   /* Strip off any path components in filename,
<span class="lineNum">    1720 </span>            :      now that we no longer need them.  */
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :   filename = lbasename (filename);</span>
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :   filelen = strlen (filename);</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :   debuglink_size = filelen + 1;</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :   debuglink_size += 3;</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   debuglink_size &amp;= ~3;</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :   debuglink_size += 4;</span>
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :   contents = (char *) bfd_malloc (debuglink_size);</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :   if (contents == NULL)</span>
<span class="lineNum">    1731 </span>            :     {
<span class="lineNum">    1732 </span>            :       /* XXX Should we delete the section from the bfd ?  */
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1734 </span>            :     }
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :   crc_offset = debuglink_size - 4;</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :   memcpy (contents, filename, filelen);</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :   memset (contents + filelen, 0, crc_offset - filelen);</span>
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :   bfd_put_32 (abfd, crc32, contents + crc_offset);</span>
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :   if (! bfd_set_section_contents (abfd, sect, contents, 0, debuglink_size))</span>
<span class="lineNum">    1743 </span>            :     {
<span class="lineNum">    1744 </span>            :       /* XXX Should we delete the section from the bfd ?  */
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :       free (contents);</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1747 </span>            :     }
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    1750 </span>            : }
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span>            : /*
<span class="lineNum">    1753 </span>            : INTERNAL_FUNCTION
<span class="lineNum">    1754 </span>            :         get_build_id
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span>            : SYNOPSIS
<span class="lineNum">    1757 </span>            :         struct bfd_build_id * get_build_id
<span class="lineNum">    1758 </span>            :           (bfd *abfd);
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span>            : DESCRIPTION
<span class="lineNum">    1761 </span>            :         Finds the build-id associated with @var{abfd}.  If the build-id is
<span class="lineNum">    1762 </span>            :         extracted from the note section then a build-id structure is built
<span class="lineNum">    1763 </span>            :         for it, using memory allocated to @var{abfd}, and this is then
<span class="lineNum">    1764 </span>            :         attached to the @var{abfd}.
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            :         Returns a pointer to the build-id structure if a build-id could be
<span class="lineNum">    1767 </span>            :         found.  If no build-id is found NULL is returned and error code is
<span class="lineNum">    1768 </span>            :         set.
<span class="lineNum">    1769 </span>            : */
<a name="1770"><span class="lineNum">    1770 </span>            : </a>
<span class="lineNum">    1771 </span>            : static struct bfd_build_id *
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 : get_build_id (bfd *abfd)</span>
<span class="lineNum">    1773 </span>            : {
<span class="lineNum">    1774 </span>            :   struct bfd_build_id *build_id;
<span class="lineNum">    1775 </span>            :   Elf_Internal_Note inote;
<span class="lineNum">    1776 </span>            :   Elf_External_Note *enote;
<span class="lineNum">    1777 </span>            :   bfd_byte *contents;
<span class="lineNum">    1778 </span>            :   asection *sect;
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :   BFD_ASSERT (abfd);</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :   if (abfd-&gt;build_id &amp;&amp; abfd-&gt;build_id-&gt;size &gt; 0)</span>
<span class="lineNum">    1783 </span>            :     /* Save some time by using the already computed build-id.  */
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :     return (struct bfd_build_id *) abfd-&gt;build_id;</span>
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :   sect = bfd_get_section_by_name (abfd, &quot;.note.gnu.build-id&quot;);</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :   if (sect == NULL)</span>
<span class="lineNum">    1788 </span>            :     {
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_debug_section);</span>
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1791 </span>            :     }
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :   /* FIXME: Should we support smaller build-id notes ?  */
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :   if (bfd_get_section_size (sect) &lt; 0x24)</span>
<span class="lineNum">    1795 </span>            :     {
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1798 </span>            :     }
<span class="lineNum">    1799 </span>            : 
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :   if (!bfd_malloc_and_get_section (abfd, sect, &amp; contents))</span>
<span class="lineNum">    1801 </span>            :     {
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :       if (contents != NULL)</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :         free (contents);</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1805 </span>            :     }
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :   enote = (Elf_External_Note *) contents;</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :   inote.type = H_GET_32 (abfd, enote-&gt;type);</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :   inote.namesz = H_GET_32 (abfd, enote-&gt;namesz);</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :   inote.namedata = enote-&gt;name;</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :   inote.descsz = H_GET_32 (abfd, enote-&gt;descsz);</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :   inote.descdata = inote.namedata + BFD_ALIGN (inote.namesz, 4);</span>
<span class="lineNum">    1813 </span>            :   /* FIXME: Should we check for extra notes in this section ?  */
<span class="lineNum">    1814 </span>            :           
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :   if (inote.descsz == 0</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :       || inote.type != NT_GNU_BUILD_ID</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :       || inote.namesz != 4 /* sizeof &quot;GNU&quot;  */</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :       || strcmp (inote.namedata, &quot;GNU&quot;) != 0)</span>
<span class="lineNum">    1819 </span>            :     {
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :       free (contents);</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1823 </span>            :     }
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :   build_id = bfd_alloc (abfd, sizeof (struct bfd_build_id) + inote.descsz);</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :   if (build_id == NULL)</span>
<span class="lineNum">    1827 </span>            :     {
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :       free (contents);</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1830 </span>            :     }
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :   build_id-&gt;size = inote.descsz;</span>
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :   memcpy (build_id-&gt;data, inote.descdata, inote.descsz);</span>
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :   abfd-&gt;build_id = build_id;</span>
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :   free (contents);</span>
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :   return build_id;</span>
<span class="lineNum">    1838 </span>            : }
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span>            : /*
<span class="lineNum">    1841 </span>            : INTERNAL_FUNCTION
<span class="lineNum">    1842 </span>            :         get_build_id_name
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span>            : SYNOPSIS
<span class="lineNum">    1845 </span>            :         char * get_build_id_name
<span class="lineNum">    1846 </span>            :           (bfd *abfd, unsigned long *build_id_out)
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span>            : DESCRIPTION
<span class="lineNum">    1849 </span>            :         Searches @var{abfd} for a build-id, and then constructs a pathname
<span class="lineNum">    1850 </span>            :         from it.  The path is computed as .build-id/NN/NN+NN.debug where
<span class="lineNum">    1851 </span>            :         NNNN+NN is the build-id value as a hexadecimal string.
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span>            :         Returns the constructed filename or NULL upon error.
<span class="lineNum">    1854 </span>            :         It is the caller's responsibility to free the memory used to hold the
<span class="lineNum">    1855 </span>            :         filename.
<span class="lineNum">    1856 </span>            :         If a filename is returned then the @var{build_id_out} parameter is
<span class="lineNum">    1857 </span>            :         set to a pointer to the build_id structure.
<span class="lineNum">    1858 </span>            : */
<a name="1859"><span class="lineNum">    1859 </span>            : </a>
<span class="lineNum">    1860 </span>            : static char *
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 : get_build_id_name (bfd *abfd, unsigned long *build_id_out)</span>
<span class="lineNum">    1862 </span>            : {
<span class="lineNum">    1863 </span>            :   struct bfd_build_id *build_id;
<span class="lineNum">    1864 </span>            :   char *name;
<span class="lineNum">    1865 </span>            :   char *n;
<span class="lineNum">    1866 </span>            :   bfd_size_type s;
<span class="lineNum">    1867 </span>            :   bfd_byte *d;
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :   if (abfd == NULL || abfd-&gt;filename == NULL || build_id_out == NULL)</span>
<span class="lineNum">    1870 </span>            :     {
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1873 </span>            :     }
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :   build_id = get_build_id (abfd);</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :   if (build_id == NULL)</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            :   /* Compute the debug pathname corresponding to the build-id.  */
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :   name = bfd_malloc (strlen (&quot;.build-id/&quot;) + build_id-&gt;size * 2 + 2 + strlen (&quot;.debug&quot;));</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :   if (name == NULL)</span>
<span class="lineNum">    1882 </span>            :     {
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_memory);</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1885 </span>            :     }
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :   n = name;</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :   d = build_id-&gt;data;</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :   s = build_id-&gt;size;</span>
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :   n += sprintf (n, &quot;.build-id/&quot;);</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :   n += sprintf (n, &quot;%02x&quot;, (unsigned) *d++); s--;</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :   n += sprintf (n, &quot;/&quot;);</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :   while (s--)</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     n += sprintf (n, &quot;%02x&quot;, (unsigned) *d++);</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :   n += sprintf (n, &quot;.debug&quot;);</span>
<span class="lineNum">    1896 </span>            : 
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :   * build_id_out = (unsigned long) build_id;</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :   return name;</span>
<span class="lineNum">    1899 </span>            : }
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span>            : /*
<span class="lineNum">    1902 </span>            : INTERNAL_FUNCTION
<span class="lineNum">    1903 </span>            :         check_build_id_file
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            : SYNOPSIS
<span class="lineNum">    1906 </span>            :         bfd_boolean check_build_id_file
<span class="lineNum">    1907 </span>            :           (char *name, unsigned long buildid);
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            : DESCRIPTION
<span class="lineNum">    1910 </span>            :         Checks to see if @var{name} is a readable file and if its build-id
<span class="lineNum">    1911 </span>            :         matches @var{buildid}.
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span>            :         Returns TRUE if the file exists, is readable, and contains a build-id
<span class="lineNum">    1914 </span>            :         which matches @var{build-id}.
<span class="lineNum">    1915 </span>            : */
<a name="1916"><span class="lineNum">    1916 </span>            : </a>
<span class="lineNum">    1917 </span>            : static bfd_boolean
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 : check_build_id_file (const char *name,</span>
<span class="lineNum">    1919 </span>            :                      const unsigned long buildid)
<span class="lineNum">    1920 </span>            : {
<span class="lineNum">    1921 </span>            :   struct bfd_build_id *orig_build_id;
<span class="lineNum">    1922 </span>            :   struct bfd_build_id *build_id;
<span class="lineNum">    1923 </span>            :   bfd * file;
<span class="lineNum">    1924 </span>            :   bfd_boolean result;
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :   BFD_ASSERT (name);</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :   BFD_ASSERT (buildid);</span>
<span class="lineNum">    1928 </span>            : 
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :   file = bfd_openr (name, NULL);</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :   if (file == NULL)</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span>            :   /* If the file is an archive, process all of its elements.  */
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :   if (! bfd_check_format (file, bfd_object))</span>
<span class="lineNum">    1935 </span>            :     {
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :       bfd_close (file);</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1938 </span>            :     }
<span class="lineNum">    1939 </span>            :   
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :   build_id = get_build_id (file);</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :   if (build_id == NULL)</span>
<span class="lineNum">    1942 </span>            :     {
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :       bfd_close (file);</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1945 </span>            :     }
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :   orig_build_id = (struct bfd_build_id *) buildid;</span>
<span class="lineNum">    1948 </span>            : 
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :   result = build_id-&gt;size == orig_build_id-&gt;size</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :     &amp;&amp; memcmp (build_id-&gt;data, orig_build_id-&gt;data, build_id-&gt;size) == 0;</span>
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :   (void) bfd_close (file);</span>
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    1955 </span>            : }
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span>            : /*
<span class="lineNum">    1958 </span>            : FUNCTION
<span class="lineNum">    1959 </span>            :         bfd_follow_build_id_debuglink
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span>            : SYNOPSIS
<span class="lineNum">    1962 </span>            :         char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span>            : DESCRIPTION
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span>            :         Takes @var{abfd} and searches it for a .note.gnu.build-id section.
<span class="lineNum">    1967 </span>            :         If this section is found, it extracts the value of the NT_GNU_BUILD_ID
<span class="lineNum">    1968 </span>            :         note, which should be a hexadecimal value @var{NNNN+NN} (for
<span class="lineNum">    1969 </span>            :         32+ hex digits).  It then searches the filesystem for a file named
<span class="lineNum">    1970 </span>            :         @var{.build-id/NN/NN+NN.debug} in a set of standard locations,
<span class="lineNum">    1971 </span>            :         including the directory tree rooted at @var{dir}.  The filename
<span class="lineNum">    1972 </span>            :         of the first matching file to be found is returned.  A matching
<span class="lineNum">    1973 </span>            :         file should contain a .note.gnu.build-id section with the same
<span class="lineNum">    1974 </span>            :         @var{NNNN+NN} note as @var{abfd}, although this check is currently
<span class="lineNum">    1975 </span>            :         not implemented.
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            :         If @var{dir} is NULL, the search will take place starting at
<span class="lineNum">    1978 </span>            :         the current directory.
<span class="lineNum">    1979 </span>            : 
<span class="lineNum">    1980 </span>            : RETURNS
<span class="lineNum">    1981 </span>            :         &lt;&lt;NULL&gt;&gt; on any errors or failure to locate the debug file,
<span class="lineNum">    1982 </span>            :         otherwise a pointer to a heap-allocated string containing the
<span class="lineNum">    1983 </span>            :         filename.  The caller is responsible for freeing this string.
<span class="lineNum">    1984 </span>            : */
<a name="1985"><span class="lineNum">    1985 </span>            : </a>
<span class="lineNum">    1986 </span>            : char *
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 : bfd_follow_build_id_debuglink (bfd *abfd, const char *dir)</span>
<span class="lineNum">    1988 </span>            : {
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :   return find_separate_debug_file (abfd, dir, FALSE,</span>
<span class="lineNum">    1990 </span>            :                                    get_build_id_name,
<span class="lineNum">    1991 </span>            :                                    check_build_id_file);
<span class="lineNum">    1992 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
