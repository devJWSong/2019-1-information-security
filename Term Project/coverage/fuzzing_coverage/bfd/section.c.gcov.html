<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - fuzzer_coverage.info - bfd/section.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">bfd</a> - section.c<span style="font-size: 80%;"> (source / <a href="section.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">fuzzer_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">62</td>
            <td class="headerCovTableEntry">235</td>
            <td class="headerCovTableEntryLo">26.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-06-21 09:00:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntryLo">40.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Object file &quot;section&quot; support for the BFD library.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1990-2017 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Written by Cygnus Support.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            :    This file is part of BFD, the Binary File Descriptor library.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            :    This program is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            :    it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            :    the Free Software Foundation; either version 3 of the License, or
<span class="lineNum">      10 </span>            :    (at your option) any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            :    This program is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            :    GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            :    You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            :    along with this program; if not, write to the Free Software
<span class="lineNum">      19 </span>            :    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
<span class="lineNum">      20 </span>            :    MA 02110-1301, USA.  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /*
<span class="lineNum">      23 </span>            : SECTION
<span class="lineNum">      24 </span>            :         Sections
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            :         The raw data contained within a BFD is maintained through the
<span class="lineNum">      27 </span>            :         section abstraction.  A single BFD may have any number of
<span class="lineNum">      28 </span>            :         sections.  It keeps hold of them by pointing to the first;
<span class="lineNum">      29 </span>            :         each one points to the next in the list.
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            :         Sections are supported in BFD in &lt;&lt;section.c&gt;&gt;.
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : @menu
<span class="lineNum">      34 </span>            : @* Section Input::
<span class="lineNum">      35 </span>            : @* Section Output::
<span class="lineNum">      36 </span>            : @* typedef asection::
<span class="lineNum">      37 </span>            : @* section prototypes::
<span class="lineNum">      38 </span>            : @end menu
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : INODE
<span class="lineNum">      41 </span>            : Section Input, Section Output, Sections, Sections
<span class="lineNum">      42 </span>            : SUBSECTION
<span class="lineNum">      43 </span>            :         Section input
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :         When a BFD is opened for reading, the section structures are
<span class="lineNum">      46 </span>            :         created and attached to the BFD.
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            :         Each section has a name which describes the section in the
<span class="lineNum">      49 </span>            :         outside world---for example, &lt;&lt;a.out&gt;&gt; would contain at least
<span class="lineNum">      50 </span>            :         three sections, called &lt;&lt;.text&gt;&gt;, &lt;&lt;.data&gt;&gt; and &lt;&lt;.bss&gt;&gt;.
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :         Names need not be unique; for example a COFF file may have several
<span class="lineNum">      53 </span>            :         sections named &lt;&lt;.data&gt;&gt;.
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :         Sometimes a BFD will contain more than the ``natural'' number of
<span class="lineNum">      56 </span>            :         sections. A back end may attach other sections containing
<span class="lineNum">      57 </span>            :         constructor data, or an application may add a section (using
<span class="lineNum">      58 </span>            :         &lt;&lt;bfd_make_section&gt;&gt;) to the sections attached to an already open
<span class="lineNum">      59 </span>            :         BFD. For example, the linker creates an extra section
<span class="lineNum">      60 </span>            :         &lt;&lt;COMMON&gt;&gt; for each input file's BFD to hold information about
<span class="lineNum">      61 </span>            :         common storage.
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :         The raw data is not necessarily read in when
<span class="lineNum">      64 </span>            :         the section descriptor is created. Some targets may leave the
<span class="lineNum">      65 </span>            :         data in place until a &lt;&lt;bfd_get_section_contents&gt;&gt; call is
<span class="lineNum">      66 </span>            :         made. Other back ends may read in all the data at once.  For
<span class="lineNum">      67 </span>            :         example, an S-record file has to be read once to determine the
<span class="lineNum">      68 </span>            :         size of the data. An IEEE-695 file doesn't contain raw data in
<span class="lineNum">      69 </span>            :         sections, but data and relocation expressions intermixed, so
<span class="lineNum">      70 </span>            :         the data area has to be parsed to get out the data and
<span class="lineNum">      71 </span>            :         relocations.
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : INODE
<span class="lineNum">      74 </span>            : Section Output, typedef asection, Section Input, Sections
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : SUBSECTION
<span class="lineNum">      77 </span>            :         Section output
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :         To write a new object style BFD, the various sections to be
<span class="lineNum">      80 </span>            :         written have to be created. They are attached to the BFD in
<span class="lineNum">      81 </span>            :         the same way as input sections; data is written to the
<span class="lineNum">      82 </span>            :         sections using &lt;&lt;bfd_set_section_contents&gt;&gt;.
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :         Any program that creates or combines sections (e.g., the assembler
<span class="lineNum">      85 </span>            :         and linker) must use the &lt;&lt;asection&gt;&gt; fields &lt;&lt;output_section&gt;&gt; and
<span class="lineNum">      86 </span>            :         &lt;&lt;output_offset&gt;&gt; to indicate the file sections to which each
<span class="lineNum">      87 </span>            :         section must be written.  (If the section is being created from
<span class="lineNum">      88 </span>            :         scratch, &lt;&lt;output_section&gt;&gt; should probably point to the section
<span class="lineNum">      89 </span>            :         itself and &lt;&lt;output_offset&gt;&gt; should probably be zero.)
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :         The data to be written comes from input sections attached
<span class="lineNum">      92 </span>            :         (via &lt;&lt;output_section&gt;&gt; pointers) to
<span class="lineNum">      93 </span>            :         the output sections.  The output section structure can be
<span class="lineNum">      94 </span>            :         considered a filter for the input section: the output section
<span class="lineNum">      95 </span>            :         determines the vma of the output data and the name, but the
<span class="lineNum">      96 </span>            :         input section determines the offset into the output section of
<span class="lineNum">      97 </span>            :         the data to be written.
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :         E.g., to create a section &quot;O&quot;, starting at 0x100, 0x123 long,
<span class="lineNum">     100 </span>            :         containing two subsections, &quot;A&quot; at offset 0x0 (i.e., at vma
<span class="lineNum">     101 </span>            :         0x100) and &quot;B&quot; at offset 0x20 (i.e., at vma 0x120) the &lt;&lt;asection&gt;&gt;
<span class="lineNum">     102 </span>            :         structures would look like:
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : |   section name          &quot;A&quot;
<span class="lineNum">     105 </span>            : |     output_offset   0x00
<span class="lineNum">     106 </span>            : |     size            0x20
<span class="lineNum">     107 </span>            : |     output_section -----------&gt;  section name    &quot;O&quot;
<span class="lineNum">     108 </span>            : |                             |    vma             0x100
<span class="lineNum">     109 </span>            : |   section name          &quot;B&quot; |    size            0x123
<span class="lineNum">     110 </span>            : |     output_offset   0x20    |
<span class="lineNum">     111 </span>            : |     size            0x103   |
<span class="lineNum">     112 </span>            : |     output_section  --------|
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : SUBSECTION
<span class="lineNum">     115 </span>            :         Link orders
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :         The data within a section is stored in a @dfn{link_order}.
<span class="lineNum">     118 </span>            :         These are much like the fixups in &lt;&lt;gas&gt;&gt;.  The link_order
<span class="lineNum">     119 </span>            :         abstraction allows a section to grow and shrink within itself.
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :         A link_order knows how big it is, and which is the next
<span class="lineNum">     122 </span>            :         link_order and where the raw data for it is; it also points to
<span class="lineNum">     123 </span>            :         a list of relocations which apply to it.
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :         The link_order is used by the linker to perform relaxing on
<span class="lineNum">     126 </span>            :         final code.  The compiler creates code which is as big as
<span class="lineNum">     127 </span>            :         necessary to make it work without relaxing, and the user can
<span class="lineNum">     128 </span>            :         select whether to relax.  Sometimes relaxing takes a lot of
<span class="lineNum">     129 </span>            :         time.  The linker runs around the relocations to see if any
<span class="lineNum">     130 </span>            :         are attached to data which can be shrunk, if so it does it on
<span class="lineNum">     131 </span>            :         a link_order by link_order basis.
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : */
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : #include &quot;sysdep.h&quot;
<span class="lineNum">     136 </span>            : #include &quot;bfd.h&quot;
<span class="lineNum">     137 </span>            : #include &quot;libbfd.h&quot;
<span class="lineNum">     138 </span>            : #include &quot;bfdlink.h&quot;
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : /*
<span class="lineNum">     141 </span>            : DOCDD
<span class="lineNum">     142 </span>            : INODE
<span class="lineNum">     143 </span>            : typedef asection, section prototypes, Section Output, Sections
<span class="lineNum">     144 </span>            : SUBSECTION
<span class="lineNum">     145 </span>            :         typedef asection
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :         Here is the section structure:
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : CODE_FRAGMENT
<span class="lineNum">     150 </span>            : .
<span class="lineNum">     151 </span>            : .typedef struct bfd_section
<span class="lineNum">     152 </span>            : .{
<span class="lineNum">     153 </span>            : .  {* The name of the section; the name isn't a copy, the pointer is
<span class="lineNum">     154 </span>            : .     the same as that passed to bfd_make_section.  *}
<span class="lineNum">     155 </span>            : .  const char *name;
<span class="lineNum">     156 </span>            : .
<span class="lineNum">     157 </span>            : .  {* A unique sequence number.  *}
<span class="lineNum">     158 </span>            : .  unsigned int id;
<span class="lineNum">     159 </span>            : .
<span class="lineNum">     160 </span>            : .  {* Which section in the bfd; 0..n-1 as sections are created in a bfd.  *}
<span class="lineNum">     161 </span>            : .  unsigned int index;
<span class="lineNum">     162 </span>            : .
<span class="lineNum">     163 </span>            : .  {* The next section in the list belonging to the BFD, or NULL.  *}
<span class="lineNum">     164 </span>            : .  struct bfd_section *next;
<span class="lineNum">     165 </span>            : .
<span class="lineNum">     166 </span>            : .  {* The previous section in the list belonging to the BFD, or NULL.  *}
<span class="lineNum">     167 </span>            : .  struct bfd_section *prev;
<span class="lineNum">     168 </span>            : .
<span class="lineNum">     169 </span>            : .  {* The field flags contains attributes of the section. Some
<span class="lineNum">     170 </span>            : .     flags are read in from the object file, and some are
<span class="lineNum">     171 </span>            : .     synthesized from other information.  *}
<span class="lineNum">     172 </span>            : .  flagword flags;
<span class="lineNum">     173 </span>            : .
<span class="lineNum">     174 </span>            : .#define SEC_NO_FLAGS   0x000
<span class="lineNum">     175 </span>            : .
<span class="lineNum">     176 </span>            : .  {* Tells the OS to allocate space for this section when loading.
<span class="lineNum">     177 </span>            : .     This is clear for a section containing debug information only.  *}
<span class="lineNum">     178 </span>            : .#define SEC_ALLOC      0x001
<span class="lineNum">     179 </span>            : .
<span class="lineNum">     180 </span>            : .  {* Tells the OS to load the section from the file when loading.
<span class="lineNum">     181 </span>            : .     This is clear for a .bss section.  *}
<span class="lineNum">     182 </span>            : .#define SEC_LOAD       0x002
<span class="lineNum">     183 </span>            : .
<span class="lineNum">     184 </span>            : .  {* The section contains data still to be relocated, so there is
<span class="lineNum">     185 </span>            : .     some relocation information too.  *}
<span class="lineNum">     186 </span>            : .#define SEC_RELOC      0x004
<span class="lineNum">     187 </span>            : .
<span class="lineNum">     188 </span>            : .  {* A signal to the OS that the section contains read only data.  *}
<span class="lineNum">     189 </span>            : .#define SEC_READONLY   0x008
<span class="lineNum">     190 </span>            : .
<span class="lineNum">     191 </span>            : .  {* The section contains code only.  *}
<span class="lineNum">     192 </span>            : .#define SEC_CODE       0x010
<span class="lineNum">     193 </span>            : .
<span class="lineNum">     194 </span>            : .  {* The section contains data only.  *}
<span class="lineNum">     195 </span>            : .#define SEC_DATA       0x020
<span class="lineNum">     196 </span>            : .
<span class="lineNum">     197 </span>            : .  {* The section will reside in ROM.  *}
<span class="lineNum">     198 </span>            : .#define SEC_ROM        0x040
<span class="lineNum">     199 </span>            : .
<span class="lineNum">     200 </span>            : .  {* The section contains constructor information. This section
<span class="lineNum">     201 </span>            : .     type is used by the linker to create lists of constructors and
<span class="lineNum">     202 </span>            : .     destructors used by &lt;&lt;g++&gt;&gt;. When a back end sees a symbol
<span class="lineNum">     203 </span>            : .     which should be used in a constructor list, it creates a new
<span class="lineNum">     204 </span>            : .     section for the type of name (e.g., &lt;&lt;__CTOR_LIST__&gt;&gt;), attaches
<span class="lineNum">     205 </span>            : .     the symbol to it, and builds a relocation. To build the lists
<span class="lineNum">     206 </span>            : .     of constructors, all the linker has to do is catenate all the
<span class="lineNum">     207 </span>            : .     sections called &lt;&lt;__CTOR_LIST__&gt;&gt; and relocate the data
<span class="lineNum">     208 </span>            : .     contained within - exactly the operations it would peform on
<span class="lineNum">     209 </span>            : .     standard data.  *}
<span class="lineNum">     210 </span>            : .#define SEC_CONSTRUCTOR 0x080
<span class="lineNum">     211 </span>            : .
<span class="lineNum">     212 </span>            : .  {* The section has contents - a data section could be
<span class="lineNum">     213 </span>            : .     &lt;&lt;SEC_ALLOC&gt;&gt; | &lt;&lt;SEC_HAS_CONTENTS&gt;&gt;; a debug section could be
<span class="lineNum">     214 </span>            : .     &lt;&lt;SEC_HAS_CONTENTS&gt;&gt;  *}
<span class="lineNum">     215 </span>            : .#define SEC_HAS_CONTENTS 0x100
<span class="lineNum">     216 </span>            : .
<span class="lineNum">     217 </span>            : .  {* An instruction to the linker to not output the section
<span class="lineNum">     218 </span>            : .     even if it has information which would normally be written.  *}
<span class="lineNum">     219 </span>            : .#define SEC_NEVER_LOAD 0x200
<span class="lineNum">     220 </span>            : .
<span class="lineNum">     221 </span>            : .  {* The section contains thread local data.  *}
<span class="lineNum">     222 </span>            : .#define SEC_THREAD_LOCAL 0x400
<span class="lineNum">     223 </span>            : .
<span class="lineNum">     224 </span>            : .  {* The section has GOT references.  This flag is only for the
<span class="lineNum">     225 </span>            : .     linker, and is currently only used by the elf32-hppa back end.
<span class="lineNum">     226 </span>            : .     It will be set if global offset table references were detected
<span class="lineNum">     227 </span>            : .     in this section, which indicate to the linker that the section
<span class="lineNum">     228 </span>            : .     contains PIC code, and must be handled specially when doing a
<span class="lineNum">     229 </span>            : .     static link.  *}
<span class="lineNum">     230 </span>            : .#define SEC_HAS_GOT_REF 0x800
<span class="lineNum">     231 </span>            : .
<span class="lineNum">     232 </span>            : .  {* The section contains common symbols (symbols may be defined
<span class="lineNum">     233 </span>            : .     multiple times, the value of a symbol is the amount of
<span class="lineNum">     234 </span>            : .     space it requires, and the largest symbol value is the one
<span class="lineNum">     235 </span>            : .     used).  Most targets have exactly one of these (which we
<span class="lineNum">     236 </span>            : .     translate to bfd_com_section_ptr), but ECOFF has two.  *}
<span class="lineNum">     237 </span>            : .#define SEC_IS_COMMON 0x1000
<span class="lineNum">     238 </span>            : .
<span class="lineNum">     239 </span>            : .  {* The section contains only debugging information.  For
<span class="lineNum">     240 </span>            : .     example, this is set for ELF .debug and .stab sections.
<span class="lineNum">     241 </span>            : .     strip tests this flag to see if a section can be
<span class="lineNum">     242 </span>            : .     discarded.  *}
<span class="lineNum">     243 </span>            : .#define SEC_DEBUGGING 0x2000
<span class="lineNum">     244 </span>            : .
<span class="lineNum">     245 </span>            : .  {* The contents of this section are held in memory pointed to
<span class="lineNum">     246 </span>            : .     by the contents field.  This is checked by bfd_get_section_contents,
<span class="lineNum">     247 </span>            : .     and the data is retrieved from memory if appropriate.  *}
<span class="lineNum">     248 </span>            : .#define SEC_IN_MEMORY 0x4000
<span class="lineNum">     249 </span>            : .
<span class="lineNum">     250 </span>            : .  {* The contents of this section are to be excluded by the
<span class="lineNum">     251 </span>            : .     linker for executable and shared objects unless those
<span class="lineNum">     252 </span>            : .     objects are to be further relocated.  *}
<span class="lineNum">     253 </span>            : .#define SEC_EXCLUDE 0x8000
<span class="lineNum">     254 </span>            : .
<span class="lineNum">     255 </span>            : .  {* The contents of this section are to be sorted based on the sum of
<span class="lineNum">     256 </span>            : .     the symbol and addend values specified by the associated relocation
<span class="lineNum">     257 </span>            : .     entries.  Entries without associated relocation entries will be
<span class="lineNum">     258 </span>            : .     appended to the end of the section in an unspecified order.  *}
<span class="lineNum">     259 </span>            : .#define SEC_SORT_ENTRIES 0x10000
<span class="lineNum">     260 </span>            : .
<span class="lineNum">     261 </span>            : .  {* When linking, duplicate sections of the same name should be
<span class="lineNum">     262 </span>            : .     discarded, rather than being combined into a single section as
<span class="lineNum">     263 </span>            : .     is usually done.  This is similar to how common symbols are
<span class="lineNum">     264 </span>            : .     handled.  See SEC_LINK_DUPLICATES below.  *}
<span class="lineNum">     265 </span>            : .#define SEC_LINK_ONCE 0x20000
<span class="lineNum">     266 </span>            : .
<span class="lineNum">     267 </span>            : .  {* If SEC_LINK_ONCE is set, this bitfield describes how the linker
<span class="lineNum">     268 </span>            : .     should handle duplicate sections.  *}
<span class="lineNum">     269 </span>            : .#define SEC_LINK_DUPLICATES 0xc0000
<span class="lineNum">     270 </span>            : .
<span class="lineNum">     271 </span>            : .  {* This value for SEC_LINK_DUPLICATES means that duplicate
<span class="lineNum">     272 </span>            : .     sections with the same name should simply be discarded.  *}
<span class="lineNum">     273 </span>            : .#define SEC_LINK_DUPLICATES_DISCARD 0x0
<span class="lineNum">     274 </span>            : .
<span class="lineNum">     275 </span>            : .  {* This value for SEC_LINK_DUPLICATES means that the linker
<span class="lineNum">     276 </span>            : .     should warn if there are any duplicate sections, although
<span class="lineNum">     277 </span>            : .     it should still only link one copy.  *}
<span class="lineNum">     278 </span>            : .#define SEC_LINK_DUPLICATES_ONE_ONLY 0x40000
<span class="lineNum">     279 </span>            : .
<span class="lineNum">     280 </span>            : .  {* This value for SEC_LINK_DUPLICATES means that the linker
<span class="lineNum">     281 </span>            : .     should warn if any duplicate sections are a different size.  *}
<span class="lineNum">     282 </span>            : .#define SEC_LINK_DUPLICATES_SAME_SIZE 0x80000
<span class="lineNum">     283 </span>            : .
<span class="lineNum">     284 </span>            : .  {* This value for SEC_LINK_DUPLICATES means that the linker
<span class="lineNum">     285 </span>            : .     should warn if any duplicate sections contain different
<span class="lineNum">     286 </span>            : .     contents.  *}
<span class="lineNum">     287 </span>            : .#define SEC_LINK_DUPLICATES_SAME_CONTENTS \
<span class="lineNum">     288 </span>            : .  (SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE)
<span class="lineNum">     289 </span>            : .
<span class="lineNum">     290 </span>            : .  {* This section was created by the linker as part of dynamic
<span class="lineNum">     291 </span>            : .     relocation or other arcane processing.  It is skipped when
<span class="lineNum">     292 </span>            : .     going through the first-pass output, trusting that someone
<span class="lineNum">     293 </span>            : .     else up the line will take care of it later.  *}
<span class="lineNum">     294 </span>            : .#define SEC_LINKER_CREATED 0x100000
<span class="lineNum">     295 </span>            : .
<span class="lineNum">     296 </span>            : .  {* This section should not be subject to garbage collection.
<span class="lineNum">     297 </span>            : .     Also set to inform the linker that this section should not be
<span class="lineNum">     298 </span>            : .     listed in the link map as discarded.  *}
<span class="lineNum">     299 </span>            : .#define SEC_KEEP 0x200000
<span class="lineNum">     300 </span>            : .
<span class="lineNum">     301 </span>            : .  {* This section contains &quot;short&quot; data, and should be placed
<span class="lineNum">     302 </span>            : .     &quot;near&quot; the GP.  *}
<span class="lineNum">     303 </span>            : .#define SEC_SMALL_DATA 0x400000
<span class="lineNum">     304 </span>            : .
<span class="lineNum">     305 </span>            : .  {* Attempt to merge identical entities in the section.
<span class="lineNum">     306 </span>            : .     Entity size is given in the entsize field.  *}
<span class="lineNum">     307 </span>            : .#define SEC_MERGE 0x800000
<span class="lineNum">     308 </span>            : .
<span class="lineNum">     309 </span>            : .  {* If given with SEC_MERGE, entities to merge are zero terminated
<span class="lineNum">     310 </span>            : .     strings where entsize specifies character size instead of fixed
<span class="lineNum">     311 </span>            : .     size entries.  *}
<span class="lineNum">     312 </span>            : .#define SEC_STRINGS 0x1000000
<span class="lineNum">     313 </span>            : .
<span class="lineNum">     314 </span>            : .  {* This section contains data about section groups.  *}
<span class="lineNum">     315 </span>            : .#define SEC_GROUP 0x2000000
<span class="lineNum">     316 </span>            : .
<span class="lineNum">     317 </span>            : .  {* The section is a COFF shared library section.  This flag is
<span class="lineNum">     318 </span>            : .     only for the linker.  If this type of section appears in
<span class="lineNum">     319 </span>            : .     the input file, the linker must copy it to the output file
<span class="lineNum">     320 </span>            : .     without changing the vma or size.  FIXME: Although this
<span class="lineNum">     321 </span>            : .     was originally intended to be general, it really is COFF
<span class="lineNum">     322 </span>            : .     specific (and the flag was renamed to indicate this).  It
<span class="lineNum">     323 </span>            : .     might be cleaner to have some more general mechanism to
<span class="lineNum">     324 </span>            : .     allow the back end to control what the linker does with
<span class="lineNum">     325 </span>            : .     sections.  *}
<span class="lineNum">     326 </span>            : .#define SEC_COFF_SHARED_LIBRARY 0x4000000
<span class="lineNum">     327 </span>            : .
<span class="lineNum">     328 </span>            : .  {* This input section should be copied to output in reverse order
<span class="lineNum">     329 </span>            : .     as an array of pointers.  This is for ELF linker internal use
<span class="lineNum">     330 </span>            : .     only.  *}
<span class="lineNum">     331 </span>            : .#define SEC_ELF_REVERSE_COPY 0x4000000
<span class="lineNum">     332 </span>            : .
<span class="lineNum">     333 </span>            : .  {* This section contains data which may be shared with other
<span class="lineNum">     334 </span>            : .     executables or shared objects. This is for COFF only.  *}
<span class="lineNum">     335 </span>            : .#define SEC_COFF_SHARED 0x8000000
<span class="lineNum">     336 </span>            : .
<span class="lineNum">     337 </span>            : .  {* This section should be compressed.  This is for ELF linker
<span class="lineNum">     338 </span>            : .     internal use only.  *}
<span class="lineNum">     339 </span>            : .#define SEC_ELF_COMPRESS 0x8000000
<span class="lineNum">     340 </span>            : .
<span class="lineNum">     341 </span>            : .  {* When a section with this flag is being linked, then if the size of
<span class="lineNum">     342 </span>            : .     the input section is less than a page, it should not cross a page
<span class="lineNum">     343 </span>            : .     boundary.  If the size of the input section is one page or more,
<span class="lineNum">     344 </span>            : .     it should be aligned on a page boundary.  This is for TI
<span class="lineNum">     345 </span>            : .     TMS320C54X only.  *}
<span class="lineNum">     346 </span>            : .#define SEC_TIC54X_BLOCK 0x10000000
<span class="lineNum">     347 </span>            : .
<span class="lineNum">     348 </span>            : .  {* This section should be renamed.  This is for ELF linker
<span class="lineNum">     349 </span>            : .     internal use only.  *}
<span class="lineNum">     350 </span>            : .#define SEC_ELF_RENAME 0x10000000
<span class="lineNum">     351 </span>            : .
<span class="lineNum">     352 </span>            : .  {* Conditionally link this section; do not link if there are no
<span class="lineNum">     353 </span>            : .     references found to any symbol in the section.  This is for TI
<span class="lineNum">     354 </span>            : .     TMS320C54X only.  *}
<span class="lineNum">     355 </span>            : .#define SEC_TIC54X_CLINK 0x20000000
<span class="lineNum">     356 </span>            : .
<span class="lineNum">     357 </span>            : .  {* This section contains vliw code.  This is for Toshiba MeP only.  *}
<span class="lineNum">     358 </span>            : .#define SEC_MEP_VLIW 0x20000000
<span class="lineNum">     359 </span>            : .
<span class="lineNum">     360 </span>            : .  {* Indicate that section has the no read flag set. This happens
<span class="lineNum">     361 </span>            : .     when memory read flag isn't set. *}
<span class="lineNum">     362 </span>            : .#define SEC_COFF_NOREAD 0x40000000
<span class="lineNum">     363 </span>            : .
<span class="lineNum">     364 </span>            : .  {* Indicate that section has the purecode flag set.  *}
<span class="lineNum">     365 </span>            : .#define SEC_ELF_PURECODE 0x80000000
<span class="lineNum">     366 </span>            : .
<span class="lineNum">     367 </span>            : .  {*  End of section flags.  *}
<span class="lineNum">     368 </span>            : .
<span class="lineNum">     369 </span>            : .  {* Some internal packed boolean fields.  *}
<span class="lineNum">     370 </span>            : .
<span class="lineNum">     371 </span>            : .  {* See the vma field.  *}
<span class="lineNum">     372 </span>            : .  unsigned int user_set_vma : 1;
<span class="lineNum">     373 </span>            : .
<span class="lineNum">     374 </span>            : .  {* A mark flag used by some of the linker backends.  *}
<span class="lineNum">     375 </span>            : .  unsigned int linker_mark : 1;
<span class="lineNum">     376 </span>            : .
<span class="lineNum">     377 </span>            : .  {* Another mark flag used by some of the linker backends.  Set for
<span class="lineNum">     378 </span>            : .     output sections that have an input section.  *}
<span class="lineNum">     379 </span>            : .  unsigned int linker_has_input : 1;
<span class="lineNum">     380 </span>            : .
<span class="lineNum">     381 </span>            : .  {* Mark flag used by some linker backends for garbage collection.  *}
<span class="lineNum">     382 </span>            : .  unsigned int gc_mark : 1;
<span class="lineNum">     383 </span>            : .
<span class="lineNum">     384 </span>            : .  {* Section compression status.  *}
<span class="lineNum">     385 </span>            : .  unsigned int compress_status : 2;
<span class="lineNum">     386 </span>            : .#define COMPRESS_SECTION_NONE    0
<span class="lineNum">     387 </span>            : .#define COMPRESS_SECTION_DONE    1
<span class="lineNum">     388 </span>            : .#define DECOMPRESS_SECTION_SIZED 2
<span class="lineNum">     389 </span>            : .
<span class="lineNum">     390 </span>            : .  {* The following flags are used by the ELF linker. *}
<span class="lineNum">     391 </span>            : .
<span class="lineNum">     392 </span>            : .  {* Mark sections which have been allocated to segments.  *}
<span class="lineNum">     393 </span>            : .  unsigned int segment_mark : 1;
<span class="lineNum">     394 </span>            : .
<span class="lineNum">     395 </span>            : .  {* Type of sec_info information.  *}
<span class="lineNum">     396 </span>            : .  unsigned int sec_info_type:3;
<span class="lineNum">     397 </span>            : .#define SEC_INFO_TYPE_NONE      0
<span class="lineNum">     398 </span>            : .#define SEC_INFO_TYPE_STABS     1
<span class="lineNum">     399 </span>            : .#define SEC_INFO_TYPE_MERGE     2
<span class="lineNum">     400 </span>            : .#define SEC_INFO_TYPE_EH_FRAME  3
<span class="lineNum">     401 </span>            : .#define SEC_INFO_TYPE_JUST_SYMS 4
<span class="lineNum">     402 </span>            : .#define SEC_INFO_TYPE_TARGET    5
<span class="lineNum">     403 </span>            : .#define SEC_INFO_TYPE_EH_FRAME_ENTRY 6
<span class="lineNum">     404 </span>            : .
<span class="lineNum">     405 </span>            : .  {* Nonzero if this section uses RELA relocations, rather than REL.  *}
<span class="lineNum">     406 </span>            : .  unsigned int use_rela_p:1;
<span class="lineNum">     407 </span>            : .
<span class="lineNum">     408 </span>            : .  {* Bits used by various backends.  The generic code doesn't touch
<span class="lineNum">     409 </span>            : .     these fields.  *}
<span class="lineNum">     410 </span>            : .
<span class="lineNum">     411 </span>            : .  unsigned int sec_flg0:1;
<span class="lineNum">     412 </span>            : .  unsigned int sec_flg1:1;
<span class="lineNum">     413 </span>            : .  unsigned int sec_flg2:1;
<span class="lineNum">     414 </span>            : .  unsigned int sec_flg3:1;
<span class="lineNum">     415 </span>            : .  unsigned int sec_flg4:1;
<span class="lineNum">     416 </span>            : .  unsigned int sec_flg5:1;
<span class="lineNum">     417 </span>            : .
<span class="lineNum">     418 </span>            : .  {* End of internal packed boolean fields.  *}
<span class="lineNum">     419 </span>            : .
<span class="lineNum">     420 </span>            : .  {*  The virtual memory address of the section - where it will be
<span class="lineNum">     421 </span>            : .      at run time.  The symbols are relocated against this.  The
<span class="lineNum">     422 </span>            : .      user_set_vma flag is maintained by bfd; if it's not set, the
<span class="lineNum">     423 </span>            : .      backend can assign addresses (for example, in &lt;&lt;a.out&gt;&gt;, where
<span class="lineNum">     424 </span>            : .      the default address for &lt;&lt;.data&gt;&gt; is dependent on the specific
<span class="lineNum">     425 </span>            : .      target and various flags).  *}
<span class="lineNum">     426 </span>            : .  bfd_vma vma;
<span class="lineNum">     427 </span>            : .
<span class="lineNum">     428 </span>            : .  {*  The load address of the section - where it would be in a
<span class="lineNum">     429 </span>            : .      rom image; really only used for writing section header
<span class="lineNum">     430 </span>            : .      information.  *}
<span class="lineNum">     431 </span>            : .  bfd_vma lma;
<span class="lineNum">     432 </span>            : .
<span class="lineNum">     433 </span>            : .  {* The size of the section in *octets*, as it will be output.
<span class="lineNum">     434 </span>            : .     Contains a value even if the section has no contents (e.g., the
<span class="lineNum">     435 </span>            : .     size of &lt;&lt;.bss&gt;&gt;).  *}
<span class="lineNum">     436 </span>            : .  bfd_size_type size;
<span class="lineNum">     437 </span>            : .
<span class="lineNum">     438 </span>            : .  {* For input sections, the original size on disk of the section, in
<span class="lineNum">     439 </span>            : .     octets.  This field should be set for any section whose size is
<span class="lineNum">     440 </span>            : .     changed by linker relaxation.  It is required for sections where
<span class="lineNum">     441 </span>            : .     the linker relaxation scheme doesn't cache altered section and
<span class="lineNum">     442 </span>            : .     reloc contents (stabs, eh_frame, SEC_MERGE, some coff relaxing
<span class="lineNum">     443 </span>            : .     targets), and thus the original size needs to be kept to read the
<span class="lineNum">     444 </span>            : .     section multiple times.  For output sections, rawsize holds the
<span class="lineNum">     445 </span>            : .     section size calculated on a previous linker relaxation pass.  *}
<span class="lineNum">     446 </span>            : .  bfd_size_type rawsize;
<span class="lineNum">     447 </span>            : .
<span class="lineNum">     448 </span>            : .  {* The compressed size of the section in octets.  *}
<span class="lineNum">     449 </span>            : .  bfd_size_type compressed_size;
<span class="lineNum">     450 </span>            : .
<span class="lineNum">     451 </span>            : .  {* Relaxation table. *}
<span class="lineNum">     452 </span>            : .  struct relax_table *relax;
<span class="lineNum">     453 </span>            : .
<span class="lineNum">     454 </span>            : .  {* Count of used relaxation table entries. *}
<span class="lineNum">     455 </span>            : .  int relax_count;
<span class="lineNum">     456 </span>            : .
<span class="lineNum">     457 </span>            : .
<span class="lineNum">     458 </span>            : .  {* If this section is going to be output, then this value is the
<span class="lineNum">     459 </span>            : .     offset in *bytes* into the output section of the first byte in the
<span class="lineNum">     460 </span>            : .     input section (byte ==&gt; smallest addressable unit on the
<span class="lineNum">     461 </span>            : .     target).  In most cases, if this was going to start at the
<span class="lineNum">     462 </span>            : .     100th octet (8-bit quantity) in the output section, this value
<span class="lineNum">     463 </span>            : .     would be 100.  However, if the target byte size is 16 bits
<span class="lineNum">     464 </span>            : .     (bfd_octets_per_byte is &quot;2&quot;), this value would be 50.  *}
<span class="lineNum">     465 </span>            : .  bfd_vma output_offset;
<span class="lineNum">     466 </span>            : .
<span class="lineNum">     467 </span>            : .  {* The output section through which to map on output.  *}
<span class="lineNum">     468 </span>            : .  struct bfd_section *output_section;
<span class="lineNum">     469 </span>            : .
<span class="lineNum">     470 </span>            : .  {* The alignment requirement of the section, as an exponent of 2 -
<span class="lineNum">     471 </span>            : .     e.g., 3 aligns to 2^3 (or 8).  *}
<span class="lineNum">     472 </span>            : .  unsigned int alignment_power;
<span class="lineNum">     473 </span>            : .
<span class="lineNum">     474 </span>            : .  {* If an input section, a pointer to a vector of relocation
<span class="lineNum">     475 </span>            : .     records for the data in this section.  *}
<span class="lineNum">     476 </span>            : .  struct reloc_cache_entry *relocation;
<span class="lineNum">     477 </span>            : .
<span class="lineNum">     478 </span>            : .  {* If an output section, a pointer to a vector of pointers to
<span class="lineNum">     479 </span>            : .     relocation records for the data in this section.  *}
<span class="lineNum">     480 </span>            : .  struct reloc_cache_entry **orelocation;
<span class="lineNum">     481 </span>            : .
<span class="lineNum">     482 </span>            : .  {* The number of relocation records in one of the above.  *}
<span class="lineNum">     483 </span>            : .  unsigned reloc_count;
<span class="lineNum">     484 </span>            : .
<span class="lineNum">     485 </span>            : .  {* Information below is back end specific - and not always used
<span class="lineNum">     486 </span>            : .     or updated.  *}
<span class="lineNum">     487 </span>            : .
<span class="lineNum">     488 </span>            : .  {* File position of section data.  *}
<span class="lineNum">     489 </span>            : .  file_ptr filepos;
<span class="lineNum">     490 </span>            : .
<span class="lineNum">     491 </span>            : .  {* File position of relocation info.  *}
<span class="lineNum">     492 </span>            : .  file_ptr rel_filepos;
<span class="lineNum">     493 </span>            : .
<span class="lineNum">     494 </span>            : .  {* File position of line data.  *}
<span class="lineNum">     495 </span>            : .  file_ptr line_filepos;
<span class="lineNum">     496 </span>            : .
<span class="lineNum">     497 </span>            : .  {* Pointer to data for applications.  *}
<span class="lineNum">     498 </span>            : .  void *userdata;
<span class="lineNum">     499 </span>            : .
<span class="lineNum">     500 </span>            : .  {* If the SEC_IN_MEMORY flag is set, this points to the actual
<span class="lineNum">     501 </span>            : .     contents.  *}
<span class="lineNum">     502 </span>            : .  unsigned char *contents;
<span class="lineNum">     503 </span>            : .
<span class="lineNum">     504 </span>            : .  {* Attached line number information.  *}
<span class="lineNum">     505 </span>            : .  alent *lineno;
<span class="lineNum">     506 </span>            : .
<span class="lineNum">     507 </span>            : .  {* Number of line number records.  *}
<span class="lineNum">     508 </span>            : .  unsigned int lineno_count;
<span class="lineNum">     509 </span>            : .
<span class="lineNum">     510 </span>            : .  {* Entity size for merging purposes.  *}
<span class="lineNum">     511 </span>            : .  unsigned int entsize;
<span class="lineNum">     512 </span>            : .
<span class="lineNum">     513 </span>            : .  {* Points to the kept section if this section is a link-once section,
<span class="lineNum">     514 </span>            : .     and is discarded.  *}
<span class="lineNum">     515 </span>            : .  struct bfd_section *kept_section;
<span class="lineNum">     516 </span>            : .
<span class="lineNum">     517 </span>            : .  {* When a section is being output, this value changes as more
<span class="lineNum">     518 </span>            : .     linenumbers are written out.  *}
<span class="lineNum">     519 </span>            : .  file_ptr moving_line_filepos;
<span class="lineNum">     520 </span>            : .
<span class="lineNum">     521 </span>            : .  {* What the section number is in the target world.  *}
<span class="lineNum">     522 </span>            : .  int target_index;
<span class="lineNum">     523 </span>            : .
<span class="lineNum">     524 </span>            : .  void *used_by_bfd;
<span class="lineNum">     525 </span>            : .
<span class="lineNum">     526 </span>            : .  {* If this is a constructor section then here is a list of the
<span class="lineNum">     527 </span>            : .     relocations created to relocate items within it.  *}
<span class="lineNum">     528 </span>            : .  struct relent_chain *constructor_chain;
<span class="lineNum">     529 </span>            : .
<span class="lineNum">     530 </span>            : .  {* The BFD which owns the section.  *}
<span class="lineNum">     531 </span>            : .  bfd *owner;
<span class="lineNum">     532 </span>            : .
<span class="lineNum">     533 </span>            : .  {* A symbol which points at this section only.  *}
<span class="lineNum">     534 </span>            : .  struct bfd_symbol *symbol;
<span class="lineNum">     535 </span>            : .  struct bfd_symbol **symbol_ptr_ptr;
<span class="lineNum">     536 </span>            : .
<span class="lineNum">     537 </span>            : .  {* Early in the link process, map_head and map_tail are used to build
<span class="lineNum">     538 </span>            : .     a list of input sections attached to an output section.  Later,
<span class="lineNum">     539 </span>            : .     output sections use these fields for a list of bfd_link_order
<span class="lineNum">     540 </span>            : .     structs.  *}
<span class="lineNum">     541 </span>            : .  union {
<span class="lineNum">     542 </span>            : .    struct bfd_link_order *link_order;
<span class="lineNum">     543 </span>            : .    struct bfd_section *s;
<span class="lineNum">     544 </span>            : .  } map_head, map_tail;
<span class="lineNum">     545 </span>            : .} asection;
<span class="lineNum">     546 </span>            : .
<span class="lineNum">     547 </span>            : .{* Relax table contains information about instructions which can
<span class="lineNum">     548 </span>            : .   be removed by relaxation -- replacing a long address with a
<span class="lineNum">     549 </span>            : .   short address.  *}
<span class="lineNum">     550 </span>            : .struct relax_table {
<span class="lineNum">     551 </span>            : .  {* Address where bytes may be deleted. *}
<span class="lineNum">     552 </span>            : .  bfd_vma addr;
<span class="lineNum">     553 </span>            : .
<span class="lineNum">     554 </span>            : .  {* Number of bytes to be deleted.  *}
<span class="lineNum">     555 </span>            : .  int size;
<span class="lineNum">     556 </span>            : .};
<span class="lineNum">     557 </span>            : .
<span class="lineNum">     558 </span>            : .{* Note: the following are provided as inline functions rather than macros
<span class="lineNum">     559 </span>            : .   because not all callers use the return value.  A macro implementation
<span class="lineNum">     560 </span>            : .   would use a comma expression, eg: &quot;((ptr)-&gt;foo = val, TRUE)&quot; and some
<span class="lineNum">     561 </span>            : .   compilers will complain about comma expressions that have no effect.  *}
<span class="lineNum">     562 </span>            : .static inline bfd_boolean
<span class="lineNum">     563 </span>            : .bfd_set_section_userdata (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr, void * val)
<span class="lineNum">     564 </span>            : .{
<span class="lineNum">     565 </span>            : .  ptr-&gt;userdata = val;
<span class="lineNum">     566 </span>            : .  return TRUE;
<span class="lineNum">     567 </span>            : .}
<span class="lineNum">     568 </span>            : .
<span class="lineNum">     569 </span>            : .static inline bfd_boolean
<span class="lineNum">     570 </span>            : .bfd_set_section_vma (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr, bfd_vma val)
<span class="lineNum">     571 </span>            : .{
<span class="lineNum">     572 </span>            : .  ptr-&gt;vma = ptr-&gt;lma = val;
<span class="lineNum">     573 </span>            : .  ptr-&gt;user_set_vma = TRUE;
<span class="lineNum">     574 </span>            : .  return TRUE;
<span class="lineNum">     575 </span>            : .}
<span class="lineNum">     576 </span>            : .
<span class="lineNum">     577 </span>            : .static inline bfd_boolean
<span class="lineNum">     578 </span>            : .bfd_set_section_alignment (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr, unsigned int val)
<span class="lineNum">     579 </span>            : .{
<span class="lineNum">     580 </span>            : .  ptr-&gt;alignment_power = val;
<span class="lineNum">     581 </span>            : .  return TRUE;
<span class="lineNum">     582 </span>            : .}
<span class="lineNum">     583 </span>            : .
<span class="lineNum">     584 </span>            : .{* These sections are global, and are managed by BFD.  The application
<span class="lineNum">     585 </span>            : .   and target back end are not permitted to change the values in
<span class="lineNum">     586 </span>            : .   these sections.  *}
<span class="lineNum">     587 </span>            : .extern asection _bfd_std_section[4];
<span class="lineNum">     588 </span>            : .
<span class="lineNum">     589 </span>            : .#define BFD_ABS_SECTION_NAME &quot;*ABS*&quot;
<span class="lineNum">     590 </span>            : .#define BFD_UND_SECTION_NAME &quot;*UND*&quot;
<span class="lineNum">     591 </span>            : .#define BFD_COM_SECTION_NAME &quot;*COM*&quot;
<span class="lineNum">     592 </span>            : .#define BFD_IND_SECTION_NAME &quot;*IND*&quot;
<span class="lineNum">     593 </span>            : .
<span class="lineNum">     594 </span>            : .{* Pointer to the common section.  *}
<span class="lineNum">     595 </span>            : .#define bfd_com_section_ptr (&amp;_bfd_std_section[0])
<span class="lineNum">     596 </span>            : .{* Pointer to the undefined section.  *}
<span class="lineNum">     597 </span>            : .#define bfd_und_section_ptr (&amp;_bfd_std_section[1])
<span class="lineNum">     598 </span>            : .{* Pointer to the absolute section.  *}
<span class="lineNum">     599 </span>            : .#define bfd_abs_section_ptr (&amp;_bfd_std_section[2])
<span class="lineNum">     600 </span>            : .{* Pointer to the indirect section.  *}
<span class="lineNum">     601 </span>            : .#define bfd_ind_section_ptr (&amp;_bfd_std_section[3])
<span class="lineNum">     602 </span>            : .
<span class="lineNum">     603 </span>            : .#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
<span class="lineNum">     604 </span>            : .#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
<span class="lineNum">     605 </span>            : .#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
<span class="lineNum">     606 </span>            : .
<span class="lineNum">     607 </span>            : .#define bfd_is_const_section(SEC)              \
<span class="lineNum">     608 </span>            : . (   ((SEC) == bfd_abs_section_ptr)            \
<span class="lineNum">     609 </span>            : .  || ((SEC) == bfd_und_section_ptr)            \
<span class="lineNum">     610 </span>            : .  || ((SEC) == bfd_com_section_ptr)            \
<span class="lineNum">     611 </span>            : .  || ((SEC) == bfd_ind_section_ptr))
<span class="lineNum">     612 </span>            : .
<span class="lineNum">     613 </span>            : .{* Macros to handle insertion and deletion of a bfd's sections.  These
<span class="lineNum">     614 </span>            : .   only handle the list pointers, ie. do not adjust section_count,
<span class="lineNum">     615 </span>            : .   target_index etc.  *}
<span class="lineNum">     616 </span>            : .#define bfd_section_list_remove(ABFD, S) \
<span class="lineNum">     617 </span>            : .  do                                                   \
<span class="lineNum">     618 </span>            : .    {                                                  \
<span class="lineNum">     619 </span>            : .      asection *_s = S;                                \
<span class="lineNum">     620 </span>            : .      asection *_next = _s-&gt;next;                   \
<span class="lineNum">     621 </span>            : .      asection *_prev = _s-&gt;prev;                   \
<span class="lineNum">     622 </span>            : .      if (_prev)                                       \
<span class="lineNum">     623 </span>            : .        _prev-&gt;next = _next;                                \
<span class="lineNum">     624 </span>            : .      else                                             \
<span class="lineNum">     625 </span>            : .        (ABFD)-&gt;sections = _next;                   \
<span class="lineNum">     626 </span>            : .      if (_next)                                       \
<span class="lineNum">     627 </span>            : .        _next-&gt;prev = _prev;                                \
<span class="lineNum">     628 </span>            : .      else                                             \
<span class="lineNum">     629 </span>            : .        (ABFD)-&gt;section_last = _prev;                       \
<span class="lineNum">     630 </span>            : .    }                                                  \
<span class="lineNum">     631 </span>            : .  while (0)
<span class="lineNum">     632 </span>            : .#define bfd_section_list_append(ABFD, S) \
<span class="lineNum">     633 </span>            : .  do                                                   \
<span class="lineNum">     634 </span>            : .    {                                                  \
<span class="lineNum">     635 </span>            : .      asection *_s = S;                                \
<span class="lineNum">     636 </span>            : .      bfd *_abfd = ABFD;                               \
<span class="lineNum">     637 </span>            : .      _s-&gt;next = NULL;                                      \
<span class="lineNum">     638 </span>            : .      if (_abfd-&gt;section_last)                              \
<span class="lineNum">     639 </span>            : .        {                                              \
<span class="lineNum">     640 </span>            : .          _s-&gt;prev = _abfd-&gt;section_last;                \
<span class="lineNum">     641 </span>            : .          _abfd-&gt;section_last-&gt;next = _s;                \
<span class="lineNum">     642 </span>            : .        }                                              \
<span class="lineNum">     643 </span>            : .      else                                             \
<span class="lineNum">     644 </span>            : .        {                                              \
<span class="lineNum">     645 </span>            : .          _s-&gt;prev = NULL;                          \
<span class="lineNum">     646 </span>            : .          _abfd-&gt;sections = _s;                     \
<span class="lineNum">     647 </span>            : .        }                                              \
<span class="lineNum">     648 </span>            : .      _abfd-&gt;section_last = _s;                     \
<span class="lineNum">     649 </span>            : .    }                                                  \
<span class="lineNum">     650 </span>            : .  while (0)
<span class="lineNum">     651 </span>            : .#define bfd_section_list_prepend(ABFD, S) \
<span class="lineNum">     652 </span>            : .  do                                                   \
<span class="lineNum">     653 </span>            : .    {                                                  \
<span class="lineNum">     654 </span>            : .      asection *_s = S;                                \
<span class="lineNum">     655 </span>            : .      bfd *_abfd = ABFD;                               \
<span class="lineNum">     656 </span>            : .      _s-&gt;prev = NULL;                                      \
<span class="lineNum">     657 </span>            : .      if (_abfd-&gt;sections)                          \
<span class="lineNum">     658 </span>            : .        {                                              \
<span class="lineNum">     659 </span>            : .          _s-&gt;next = _abfd-&gt;sections;                    \
<span class="lineNum">     660 </span>            : .          _abfd-&gt;sections-&gt;prev = _s;                    \
<span class="lineNum">     661 </span>            : .        }                                              \
<span class="lineNum">     662 </span>            : .      else                                             \
<span class="lineNum">     663 </span>            : .        {                                              \
<span class="lineNum">     664 </span>            : .          _s-&gt;next = NULL;                          \
<span class="lineNum">     665 </span>            : .          _abfd-&gt;section_last = _s;                 \
<span class="lineNum">     666 </span>            : .        }                                              \
<span class="lineNum">     667 </span>            : .      _abfd-&gt;sections = _s;                         \
<span class="lineNum">     668 </span>            : .    }                                                  \
<span class="lineNum">     669 </span>            : .  while (0)
<span class="lineNum">     670 </span>            : .#define bfd_section_list_insert_after(ABFD, A, S) \
<span class="lineNum">     671 </span>            : .  do                                                   \
<span class="lineNum">     672 </span>            : .    {                                                  \
<span class="lineNum">     673 </span>            : .      asection *_a = A;                                \
<span class="lineNum">     674 </span>            : .      asection *_s = S;                                \
<span class="lineNum">     675 </span>            : .      asection *_next = _a-&gt;next;                   \
<span class="lineNum">     676 </span>            : .      _s-&gt;next = _next;                             \
<span class="lineNum">     677 </span>            : .      _s-&gt;prev = _a;                                        \
<span class="lineNum">     678 </span>            : .      _a-&gt;next = _s;                                        \
<span class="lineNum">     679 </span>            : .      if (_next)                                       \
<span class="lineNum">     680 </span>            : .        _next-&gt;prev = _s;                           \
<span class="lineNum">     681 </span>            : .      else                                             \
<span class="lineNum">     682 </span>            : .        (ABFD)-&gt;section_last = _s;                  \
<span class="lineNum">     683 </span>            : .    }                                                  \
<span class="lineNum">     684 </span>            : .  while (0)
<span class="lineNum">     685 </span>            : .#define bfd_section_list_insert_before(ABFD, B, S) \
<span class="lineNum">     686 </span>            : .  do                                                   \
<span class="lineNum">     687 </span>            : .    {                                                  \
<span class="lineNum">     688 </span>            : .      asection *_b = B;                                \
<span class="lineNum">     689 </span>            : .      asection *_s = S;                                \
<span class="lineNum">     690 </span>            : .      asection *_prev = _b-&gt;prev;                   \
<span class="lineNum">     691 </span>            : .      _s-&gt;prev = _prev;                             \
<span class="lineNum">     692 </span>            : .      _s-&gt;next = _b;                                        \
<span class="lineNum">     693 </span>            : .      _b-&gt;prev = _s;                                        \
<span class="lineNum">     694 </span>            : .      if (_prev)                                       \
<span class="lineNum">     695 </span>            : .        _prev-&gt;next = _s;                           \
<span class="lineNum">     696 </span>            : .      else                                             \
<span class="lineNum">     697 </span>            : .        (ABFD)-&gt;sections = _s;                              \
<span class="lineNum">     698 </span>            : .    }                                                  \
<span class="lineNum">     699 </span>            : .  while (0)
<span class="lineNum">     700 </span>            : .#define bfd_section_removed_from_list(ABFD, S) \
<span class="lineNum">     701 </span>            : .  ((S)-&gt;next == NULL ? (ABFD)-&gt;section_last != (S) : (S)-&gt;next-&gt;prev != (S))
<span class="lineNum">     702 </span>            : .
<span class="lineNum">     703 </span>            : .#define BFD_FAKE_SECTION(SEC, SYM, NAME, IDX, FLAGS)                   \
<span class="lineNum">     704 </span>            : .  {* name, id,  index, next, prev, flags, user_set_vma,            *}  \
<span class="lineNum">     705 </span>            : .  {  NAME, IDX, 0,     NULL, NULL, FLAGS, 0,                           \
<span class="lineNum">     706 </span>            : .                                                                       \
<span class="lineNum">     707 </span>            : .  {* linker_mark, linker_has_input, gc_mark, decompress_status,    *}  \
<span class="lineNum">     708 </span>            : .     0,           0,                1,       0,                        \
<span class="lineNum">     709 </span>            : .                                                                       \
<span class="lineNum">     710 </span>            : .  {* segment_mark, sec_info_type, use_rela_p,                      *}  \
<span class="lineNum">     711 </span>            : .     0,            0,             0,                                   \
<span class="lineNum">     712 </span>            : .                                                                       \
<span class="lineNum">     713 </span>            : .  {* sec_flg0, sec_flg1, sec_flg2, sec_flg3, sec_flg4, sec_flg5,   *}  \
<span class="lineNum">     714 </span>            : .     0,        0,        0,        0,        0,        0,              \
<span class="lineNum">     715 </span>            : .                                                                       \
<span class="lineNum">     716 </span>            : .  {* vma, lma, size, rawsize, compressed_size, relax, relax_count, *}  \
<span class="lineNum">     717 </span>            : .     0,   0,   0,    0,       0,               0,     0,               \
<span class="lineNum">     718 </span>            : .                                                                       \
<span class="lineNum">     719 </span>            : .  {* output_offset, output_section, alignment_power,               *}  \
<span class="lineNum">     720 </span>            : .     0,             &amp;SEC,           0,                                     \
<span class="lineNum">     721 </span>            : .                                                                       \
<span class="lineNum">     722 </span>            : .  {* relocation, orelocation, reloc_count, filepos, rel_filepos,   *}  \
<span class="lineNum">     723 </span>            : .     NULL,       NULL,        0,           0,       0,                 \
<span class="lineNum">     724 </span>            : .                                                                       \
<span class="lineNum">     725 </span>            : .  {* line_filepos, userdata, contents, lineno, lineno_count,       *}  \
<span class="lineNum">     726 </span>            : .     0,            NULL,     NULL,     NULL,   0,                      \
<span class="lineNum">     727 </span>            : .                                                                       \
<span class="lineNum">     728 </span>            : .  {* entsize, kept_section, moving_line_filepos,                    *} \
<span class="lineNum">     729 </span>            : .     0,       NULL,          0,                                        \
<span class="lineNum">     730 </span>            : .                                                                       \
<span class="lineNum">     731 </span>            : .  {* target_index, used_by_bfd, constructor_chain, owner,          *}  \
<span class="lineNum">     732 </span>            : .     0,            NULL,        NULL,              NULL,               \
<span class="lineNum">     733 </span>            : .                                                                       \
<span class="lineNum">     734 </span>            : .  {* symbol,                    symbol_ptr_ptr,                    *}  \
<span class="lineNum">     735 </span>            : .     (struct bfd_symbol *) SYM, &amp;SEC.symbol,                               \
<span class="lineNum">     736 </span>            : .                                                                       \
<span class="lineNum">     737 </span>            : .  {* map_head, map_tail                                            *}  \
<span class="lineNum">     738 </span>            : .     { NULL }, { NULL }                                                \
<span class="lineNum">     739 </span>            : .    }
<span class="lineNum">     740 </span>            : .
<span class="lineNum">     741 </span>            : */
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            : /* We use a macro to initialize the static asymbol structures because
<span class="lineNum">     744 </span>            :    traditional C does not permit us to initialize a union member while
<span class="lineNum">     745 </span>            :    gcc warns if we don't initialize it.  */
<span class="lineNum">     746 </span>            :  /* the_bfd, name, value, attr, section [, udata] */
<span class="lineNum">     747 </span>            : #ifdef __STDC__
<span class="lineNum">     748 </span>            : #define GLOBAL_SYM_INIT(NAME, SECTION) \
<span class="lineNum">     749 </span>            :   { 0, NAME, 0, BSF_SECTION_SYM, SECTION, { 0 }}
<span class="lineNum">     750 </span>            : #else
<span class="lineNum">     751 </span>            : #define GLOBAL_SYM_INIT(NAME, SECTION) \
<span class="lineNum">     752 </span>            :   { 0, NAME, 0, BSF_SECTION_SYM, SECTION }
<span class="lineNum">     753 </span>            : #endif
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : /* These symbols are global, not specific to any BFD.  Therefore, anything
<span class="lineNum">     756 </span>            :    that tries to change them is broken, and should be repaired.  */
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            : static const asymbol global_syms[] =
<span class="lineNum">     759 </span>            : {
<span class="lineNum">     760 </span>            :   GLOBAL_SYM_INIT (BFD_COM_SECTION_NAME, bfd_com_section_ptr),
<span class="lineNum">     761 </span>            :   GLOBAL_SYM_INIT (BFD_UND_SECTION_NAME, bfd_und_section_ptr),
<span class="lineNum">     762 </span>            :   GLOBAL_SYM_INIT (BFD_ABS_SECTION_NAME, bfd_abs_section_ptr),
<span class="lineNum">     763 </span>            :   GLOBAL_SYM_INIT (BFD_IND_SECTION_NAME, bfd_ind_section_ptr)
<span class="lineNum">     764 </span>            : };
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : #define STD_SECTION(NAME, IDX, FLAGS) \
<span class="lineNum">     767 </span>            :   BFD_FAKE_SECTION(_bfd_std_section[IDX], &amp;global_syms[IDX], NAME, IDX, FLAGS)
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : asection _bfd_std_section[] = {
<span class="lineNum">     770 </span>            :   STD_SECTION (BFD_COM_SECTION_NAME, 0, SEC_IS_COMMON),
<span class="lineNum">     771 </span>            :   STD_SECTION (BFD_UND_SECTION_NAME, 1, 0),
<span class="lineNum">     772 </span>            :   STD_SECTION (BFD_ABS_SECTION_NAME, 2, 0),
<span class="lineNum">     773 </span>            :   STD_SECTION (BFD_IND_SECTION_NAME, 3, 0)
<span class="lineNum">     774 </span>            : };
<span class="lineNum">     775 </span>            : #undef STD_SECTION
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            : /* Initialize an entry in the section hash table.  */
<a name="778"><span class="lineNum">     778 </span>            : </a>
<span class="lineNum">     779 </span>            : struct bfd_hash_entry *
<span class="lineNum">     780 </span><span class="lineCov">       2940 : bfd_section_hash_newfunc (struct bfd_hash_entry *entry,</span>
<span class="lineNum">     781 </span>            :                           struct bfd_hash_table *table,
<span class="lineNum">     782 </span>            :                           const char *string)
<span class="lineNum">     783 </span>            : {
<span class="lineNum">     784 </span>            :   /* Allocate the structure if it has not already been allocated by a
<span class="lineNum">     785 </span>            :      subclass.  */
<span class="lineNum">     786 </span><span class="lineCov">       2940 :   if (entry == NULL)</span>
<span class="lineNum">     787 </span>            :     {
<span class="lineNum">     788 </span><span class="lineCov">       2940 :       entry = (struct bfd_hash_entry *)</span>
<span class="lineNum">     789 </span>            :         bfd_hash_allocate (table, sizeof (struct section_hash_entry));
<span class="lineNum">     790 </span><span class="lineCov">       2940 :       if (entry == NULL)</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         return entry;</span>
<span class="lineNum">     792 </span>            :     }
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :   /* Call the allocation method of the superclass.  */
<span class="lineNum">     795 </span><span class="lineCov">       2940 :   entry = bfd_hash_newfunc (entry, table, string);</span>
<span class="lineNum">     796 </span><span class="lineCov">       2940 :   if (entry != NULL)</span>
<span class="lineNum">     797 </span><span class="lineCov">       2940 :     memset (&amp;((struct section_hash_entry *) entry)-&gt;section, 0,</span>
<span class="lineNum">     798 </span>            :             sizeof (asection));
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineCov">       2940 :   return entry;</span>
<span class="lineNum">     801 </span>            : }
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : #define section_hash_lookup(table, string, create, copy) \
<span class="lineNum">     804 </span>            :   ((struct section_hash_entry *) \
<span class="lineNum">     805 </span>            :    bfd_hash_lookup ((table), (string), (create), (copy)))
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : /* Create a symbol whose only job is to point to this section.  This
<span class="lineNum">     808 </span>            :    is useful for things like relocs which are relative to the base
<span class="lineNum">     809 </span>            :    of a section.  */
<a name="810"><span class="lineNum">     810 </span>            : </a>
<span class="lineNum">     811 </span>            : bfd_boolean
<span class="lineNum">     812 </span><span class="lineCov">       2940 : _bfd_generic_new_section_hook (bfd *abfd, asection *newsect)</span>
<span class="lineNum">     813 </span>            : {
<span class="lineNum">     814 </span><span class="lineCov">       2940 :   newsect-&gt;symbol = bfd_make_empty_symbol (abfd);</span>
<span class="lineNum">     815 </span><span class="lineCov">       2940 :   if (newsect-&gt;symbol == NULL)</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineCov">       2940 :   newsect-&gt;symbol-&gt;name = newsect-&gt;name;</span>
<span class="lineNum">     819 </span><span class="lineCov">       2940 :   newsect-&gt;symbol-&gt;value = 0;</span>
<span class="lineNum">     820 </span><span class="lineCov">       2940 :   newsect-&gt;symbol-&gt;section = newsect;</span>
<span class="lineNum">     821 </span><span class="lineCov">       2940 :   newsect-&gt;symbol-&gt;flags = BSF_SECTION_SYM;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineCov">       2940 :   newsect-&gt;symbol_ptr_ptr = &amp;newsect-&gt;symbol;</span>
<span class="lineNum">     824 </span><span class="lineCov">       2940 :   return TRUE;</span>
<span class="lineNum">     825 </span>            : }
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : static unsigned int section_id = 0x10;  /* id 0 to 3 used by STD_SECTION.  */
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            : /* Initializes a new section.  NEWSECT-&gt;NAME is already set.  */
<a name="830"><span class="lineNum">     830 </span>            : </a>
<span class="lineNum">     831 </span>            : static asection *
<span class="lineNum">     832 </span><span class="lineCov">       2940 : bfd_section_init (bfd *abfd, asection *newsect)</span>
<span class="lineNum">     833 </span>            : {
<span class="lineNum">     834 </span><span class="lineCov">       2940 :   newsect-&gt;id = section_id;</span>
<span class="lineNum">     835 </span><span class="lineCov">       2940 :   newsect-&gt;index = abfd-&gt;section_count;</span>
<span class="lineNum">     836 </span><span class="lineCov">       2940 :   newsect-&gt;owner = abfd;</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineCov">       2940 :   if (! BFD_SEND (abfd, _new_section_hook, (abfd, newsect)))</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">       2940 :   section_id++;</span>
<span class="lineNum">     842 </span><span class="lineCov">       2940 :   abfd-&gt;section_count++;</span>
<span class="lineNum">     843 </span><span class="lineCov">       2940 :   bfd_section_list_append (abfd, newsect);</span>
<span class="lineNum">     844 </span><span class="lineCov">       2940 :   return newsect;</span>
<span class="lineNum">     845 </span>            : }
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            : /*
<span class="lineNum">     848 </span>            : DOCDD
<span class="lineNum">     849 </span>            : INODE
<span class="lineNum">     850 </span>            : section prototypes,  , typedef asection, Sections
<span class="lineNum">     851 </span>            : SUBSECTION
<span class="lineNum">     852 </span>            :         Section prototypes
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            : These are the functions exported by the section handling part of BFD.
<span class="lineNum">     855 </span>            : */
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : /*
<span class="lineNum">     858 </span>            : FUNCTION
<span class="lineNum">     859 </span>            :         bfd_section_list_clear
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : SYNOPSIS
<span class="lineNum">     862 </span>            :         void bfd_section_list_clear (bfd *);
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : DESCRIPTION
<span class="lineNum">     865 </span>            :         Clears the section list, and also resets the section count and
<span class="lineNum">     866 </span>            :         hash table entries.
<span class="lineNum">     867 </span>            : */
<a name="868"><span class="lineNum">     868 </span>            : </a>
<span class="lineNum">     869 </span>            : void
<span class="lineNum">     870 </span><span class="lineCov">       9164 : bfd_section_list_clear (bfd *abfd)</span>
<span class="lineNum">     871 </span>            : {
<span class="lineNum">     872 </span><span class="lineCov">       9164 :   abfd-&gt;sections = NULL;</span>
<span class="lineNum">     873 </span><span class="lineCov">       9164 :   abfd-&gt;section_last = NULL;</span>
<span class="lineNum">     874 </span><span class="lineCov">       9164 :   abfd-&gt;section_count = 0;</span>
<span class="lineNum">     875 </span><span class="lineCov">       9164 :   memset (abfd-&gt;section_htab.table, 0,</span>
<span class="lineNum">     876 </span><span class="lineCov">       9164 :           abfd-&gt;section_htab.size * sizeof (struct bfd_hash_entry *));</span>
<span class="lineNum">     877 </span><span class="lineCov">       9164 :   abfd-&gt;section_htab.count = 0;</span>
<span class="lineNum">     878 </span><span class="lineCov">       9164 : }</span>
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            : /*
<span class="lineNum">     881 </span>            : FUNCTION
<span class="lineNum">     882 </span>            :         bfd_get_section_by_name
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : SYNOPSIS
<span class="lineNum">     885 </span>            :         asection *bfd_get_section_by_name (bfd *abfd, const char *name);
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            : DESCRIPTION
<span class="lineNum">     888 </span>            :         Return the most recently created section attached to @var{abfd}
<span class="lineNum">     889 </span>            :         named @var{name}.  Return NULL if no such section exists.
<span class="lineNum">     890 </span>            : */
<a name="891"><span class="lineNum">     891 </span>            : </a>
<span class="lineNum">     892 </span>            : asection *
<span class="lineNum">     893 </span><span class="lineCov">        284 : bfd_get_section_by_name (bfd *abfd, const char *name)</span>
<span class="lineNum">     894 </span>            : {
<span class="lineNum">     895 </span>            :   struct section_hash_entry *sh;
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineCov">        284 :   sh = section_hash_lookup (&amp;abfd-&gt;section_htab, name, FALSE, FALSE);</span>
<span class="lineNum">     898 </span><span class="lineCov">        284 :   if (sh != NULL)</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     return &amp;sh-&gt;section;</span>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span><span class="lineCov">        284 :   return NULL;</span>
<span class="lineNum">     902 </span>            : }
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span>            : /*
<span class="lineNum">     905 </span>            : FUNCTION
<span class="lineNum">     906 </span>            :        bfd_get_next_section_by_name
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            : SYNOPSIS
<span class="lineNum">     909 </span>            :        asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : DESCRIPTION
<span class="lineNum">     912 </span>            :        Given @var{sec} is a section returned by @code{bfd_get_section_by_name},
<span class="lineNum">     913 </span>            :        return the next most recently created section attached to the same
<span class="lineNum">     914 </span>            :        BFD with the same name, or if no such section exists in the same BFD and
<span class="lineNum">     915 </span>            :        IBFD is non-NULL, the next section with the same name in any input
<span class="lineNum">     916 </span>            :        BFD following IBFD.  Return NULL on finding no section.
<span class="lineNum">     917 </span>            : */
<a name="918"><span class="lineNum">     918 </span>            : </a>
<span class="lineNum">     919 </span>            : asection *
<span class="lineNum">     920 </span><span class="lineNoCov">          0 : bfd_get_next_section_by_name (bfd *ibfd, asection *sec)</span>
<span class="lineNum">     921 </span>            : {
<span class="lineNum">     922 </span>            :   struct section_hash_entry *sh;
<span class="lineNum">     923 </span>            :   const char *name;
<span class="lineNum">     924 </span>            :   unsigned long hash;
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :   sh = ((struct section_hash_entry *)</span>
<span class="lineNum">     927 </span>            :         ((char *) sec - offsetof (struct section_hash_entry, section)));
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   hash = sh-&gt;root.hash;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   name = sec-&gt;name;</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   for (sh = (struct section_hash_entry *) sh-&gt;root.next;</span>
<span class="lineNum">     932 </span>            :        sh != NULL;
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :        sh = (struct section_hash_entry *) sh-&gt;root.next)</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     if (sh-&gt;root.hash == hash</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :        &amp;&amp; strcmp (sh-&gt;root.string, name) == 0)</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :       return &amp;sh-&gt;section;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   if (ibfd != NULL)</span>
<span class="lineNum">     939 </span>            :     {
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :       while ((ibfd = ibfd-&gt;link.next) != NULL)</span>
<span class="lineNum">     941 </span>            :         {
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :           asection *s = bfd_get_section_by_name (ibfd, name);</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :           if (s != NULL)</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :             return s;</span>
<span class="lineNum">     945 </span>            :         }
<span class="lineNum">     946 </span>            :     }
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   return NULL;</span>
<span class="lineNum">     949 </span>            : }
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : /*
<span class="lineNum">     952 </span>            : FUNCTION
<span class="lineNum">     953 </span>            :         bfd_get_linker_section
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            : SYNOPSIS
<span class="lineNum">     956 </span>            :         asection *bfd_get_linker_section (bfd *abfd, const char *name);
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            : DESCRIPTION
<span class="lineNum">     959 </span>            :         Return the linker created section attached to @var{abfd}
<span class="lineNum">     960 </span>            :         named @var{name}.  Return NULL if no such section exists.
<span class="lineNum">     961 </span>            : */
<a name="962"><span class="lineNum">     962 </span>            : </a>
<span class="lineNum">     963 </span>            : asection *
<span class="lineNum">     964 </span><span class="lineNoCov">          0 : bfd_get_linker_section (bfd *abfd, const char *name)</span>
<span class="lineNum">     965 </span>            : {
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   asection *sec = bfd_get_section_by_name (abfd, name);</span>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   while (sec != NULL &amp;&amp; (sec-&gt;flags &amp; SEC_LINKER_CREATED) == 0)</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     sec = bfd_get_next_section_by_name (NULL, sec);</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   return sec;</span>
<span class="lineNum">     971 </span>            : }
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            : /*
<span class="lineNum">     974 </span>            : FUNCTION
<span class="lineNum">     975 </span>            :         bfd_get_section_by_name_if
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : SYNOPSIS
<span class="lineNum">     978 </span>            :         asection *bfd_get_section_by_name_if
<span class="lineNum">     979 </span>            :           (bfd *abfd,
<span class="lineNum">     980 </span>            :            const char *name,
<span class="lineNum">     981 </span>            :            bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
<span class="lineNum">     982 </span>            :            void *obj);
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            : DESCRIPTION
<span class="lineNum">     985 </span>            :         Call the provided function @var{func} for each section
<span class="lineNum">     986 </span>            :         attached to the BFD @var{abfd} whose name matches @var{name},
<span class="lineNum">     987 </span>            :         passing @var{obj} as an argument. The function will be called
<span class="lineNum">     988 </span>            :         as if by
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            : |       func (abfd, the_section, obj);
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            :         It returns the first section for which @var{func} returns true,
<span class="lineNum">     993 </span>            :         otherwise &lt;&lt;NULL&gt;&gt;.
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : */
<a name="996"><span class="lineNum">     996 </span>            : </a>
<span class="lineNum">     997 </span>            : asection *
<span class="lineNum">     998 </span><span class="lineNoCov">          0 : bfd_get_section_by_name_if (bfd *abfd, const char *name,</span>
<span class="lineNum">     999 </span>            :                             bfd_boolean (*operation) (bfd *,
<span class="lineNum">    1000 </span>            :                                                       asection *,
<span class="lineNum">    1001 </span>            :                                                       void *),
<span class="lineNum">    1002 </span>            :                             void *user_storage)
<span class="lineNum">    1003 </span>            : {
<span class="lineNum">    1004 </span>            :   struct section_hash_entry *sh;
<span class="lineNum">    1005 </span>            :   unsigned long hash;
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   sh = section_hash_lookup (&amp;abfd-&gt;section_htab, name, FALSE, FALSE);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   if (sh == NULL)</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   hash = sh-&gt;root.hash;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   for (; sh != NULL; sh = (struct section_hash_entry *) sh-&gt;root.next)</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :     if (sh-&gt;root.hash == hash</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :         &amp;&amp; strcmp (sh-&gt;root.string, name) == 0</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :         &amp;&amp; (*operation) (abfd, &amp;sh-&gt;section, user_storage))</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :       return &amp;sh-&gt;section;</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   return NULL;</span>
<span class="lineNum">    1019 </span>            : }
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span>            : /*
<span class="lineNum">    1022 </span>            : FUNCTION
<span class="lineNum">    1023 </span>            :         bfd_get_unique_section_name
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            : SYNOPSIS
<span class="lineNum">    1026 </span>            :         char *bfd_get_unique_section_name
<span class="lineNum">    1027 </span>            :           (bfd *abfd, const char *templat, int *count);
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span>            : DESCRIPTION
<span class="lineNum">    1030 </span>            :         Invent a section name that is unique in @var{abfd} by tacking
<span class="lineNum">    1031 </span>            :         a dot and a digit suffix onto the original @var{templat}.  If
<span class="lineNum">    1032 </span>            :         @var{count} is non-NULL, then it specifies the first number
<span class="lineNum">    1033 </span>            :         tried as a suffix to generate a unique name.  The value
<span class="lineNum">    1034 </span>            :         pointed to by @var{count} will be incremented in this case.
<span class="lineNum">    1035 </span>            : */
<a name="1036"><span class="lineNum">    1036 </span>            : </a>
<span class="lineNum">    1037 </span>            : char *
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 : bfd_get_unique_section_name (bfd *abfd, const char *templat, int *count)</span>
<span class="lineNum">    1039 </span>            : {
<span class="lineNum">    1040 </span>            :   int num;
<span class="lineNum">    1041 </span>            :   unsigned int len;
<span class="lineNum">    1042 </span>            :   char *sname;
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   len = strlen (templat);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   sname = (char *) bfd_malloc (len + 8);</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   if (sname == NULL)</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :   memcpy (sname, templat, len);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   num = 1;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   if (count != NULL)</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     num = *count;</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :   do
<span class="lineNum">    1054 </span>            :     {
<span class="lineNum">    1055 </span>            :       /* If we have a million sections, something is badly wrong.  */
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :       if (num &gt; 999999)</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         abort ();</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :       sprintf (sname + len, &quot;.%d&quot;, num++);</span>
<span class="lineNum">    1059 </span>            :     }
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   while (section_hash_lookup (&amp;abfd-&gt;section_htab, sname, FALSE, FALSE));</span>
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   if (count != NULL)</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     *count = num;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   return sname;</span>
<span class="lineNum">    1065 </span>            : }
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            : /*
<span class="lineNum">    1068 </span>            : FUNCTION
<span class="lineNum">    1069 </span>            :         bfd_make_section_old_way
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            : SYNOPSIS
<span class="lineNum">    1072 </span>            :         asection *bfd_make_section_old_way (bfd *abfd, const char *name);
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            : DESCRIPTION
<span class="lineNum">    1075 </span>            :         Create a new empty section called @var{name}
<span class="lineNum">    1076 </span>            :         and attach it to the end of the chain of sections for the
<span class="lineNum">    1077 </span>            :         BFD @var{abfd}. An attempt to create a section with a name which
<span class="lineNum">    1078 </span>            :         is already in use returns its pointer without changing the
<span class="lineNum">    1079 </span>            :         section chain.
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            :         It has the funny name since this is the way it used to be
<span class="lineNum">    1082 </span>            :         before it was rewritten....
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            :         Possible errors are:
<span class="lineNum">    1085 </span>            :         o &lt;&lt;bfd_error_invalid_operation&gt;&gt; -
<span class="lineNum">    1086 </span>            :         If output has already started for this BFD.
<span class="lineNum">    1087 </span>            :         o &lt;&lt;bfd_error_no_memory&gt;&gt; -
<span class="lineNum">    1088 </span>            :         If memory allocation fails.
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            : */
<a name="1091"><span class="lineNum">    1091 </span>            : </a>
<span class="lineNum">    1092 </span>            : asection *
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 : bfd_make_section_old_way (bfd *abfd, const char *name)</span>
<span class="lineNum">    1094 </span>            : {
<span class="lineNum">    1095 </span>            :   asection *newsect;
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   if (abfd-&gt;output_has_begun)</span>
<span class="lineNum">    1098 </span>            :     {
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1101 </span>            :     }
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   if (strcmp (name, BFD_ABS_SECTION_NAME) == 0)</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     newsect = bfd_abs_section_ptr;</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   else if (strcmp (name, BFD_COM_SECTION_NAME) == 0)</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     newsect = bfd_com_section_ptr;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :   else if (strcmp (name, BFD_UND_SECTION_NAME) == 0)</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     newsect = bfd_und_section_ptr;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :   else if (strcmp (name, BFD_IND_SECTION_NAME) == 0)</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     newsect = bfd_ind_section_ptr;</span>
<span class="lineNum">    1111 </span>            :   else
<span class="lineNum">    1112 </span>            :     {
<span class="lineNum">    1113 </span>            :       struct section_hash_entry *sh;
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :       sh = section_hash_lookup (&amp;abfd-&gt;section_htab, name, TRUE, FALSE);</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       if (sh == NULL)</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       newsect = &amp;sh-&gt;section;</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :       if (newsect-&gt;name != NULL)</span>
<span class="lineNum">    1121 </span>            :         {
<span class="lineNum">    1122 </span>            :           /* Section already exists.  */
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :           return newsect;</span>
<span class="lineNum">    1124 </span>            :         }
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :       newsect-&gt;name = name;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :       return bfd_section_init (abfd, newsect);</span>
<span class="lineNum">    1128 </span>            :     }
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :   /* Call new_section_hook when &quot;creating&quot; the standard abs, com, und
<span class="lineNum">    1131 </span>            :      and ind sections to tack on format specific section data.
<span class="lineNum">    1132 </span>            :      Also, create a proper section symbol.  */
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   if (! BFD_SEND (abfd, _new_section_hook, (abfd, newsect)))</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :   return newsect;</span>
<span class="lineNum">    1136 </span>            : }
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : /*
<span class="lineNum">    1139 </span>            : FUNCTION
<span class="lineNum">    1140 </span>            :         bfd_make_section_anyway_with_flags
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : SYNOPSIS
<span class="lineNum">    1143 </span>            :         asection *bfd_make_section_anyway_with_flags
<span class="lineNum">    1144 </span>            :           (bfd *abfd, const char *name, flagword flags);
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            : DESCRIPTION
<span class="lineNum">    1147 </span>            :    Create a new empty section called @var{name} and attach it to the end of
<span class="lineNum">    1148 </span>            :    the chain of sections for @var{abfd}.  Create a new section even if there
<span class="lineNum">    1149 </span>            :    is already a section with that name.  Also set the attributes of the
<span class="lineNum">    1150 </span>            :    new section to the value @var{flags}.
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :    Return &lt;&lt;NULL&gt;&gt; and set &lt;&lt;bfd_error&gt;&gt; on error; possible errors are:
<span class="lineNum">    1153 </span>            :    o &lt;&lt;bfd_error_invalid_operation&gt;&gt; - If output has already started for @var{abfd}.
<span class="lineNum">    1154 </span>            :    o &lt;&lt;bfd_error_no_memory&gt;&gt; - If memory allocation fails.
<span class="lineNum">    1155 </span>            : */
<a name="1156"><span class="lineNum">    1156 </span>            : </a>
<span class="lineNum">    1157 </span>            : sec_ptr
<span class="lineNum">    1158 </span><span class="lineCov">       2940 : bfd_make_section_anyway_with_flags (bfd *abfd, const char *name,</span>
<span class="lineNum">    1159 </span>            :                                     flagword flags)
<span class="lineNum">    1160 </span>            : {
<span class="lineNum">    1161 </span>            :   struct section_hash_entry *sh;
<span class="lineNum">    1162 </span>            :   asection *newsect;
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span><span class="lineCov">       2940 :   if (abfd-&gt;output_has_begun)</span>
<span class="lineNum">    1165 </span>            :     {
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1168 </span>            :     }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineCov">       2940 :   sh = section_hash_lookup (&amp;abfd-&gt;section_htab, name, TRUE, FALSE);</span>
<span class="lineNum">    1171 </span><span class="lineCov">       2940 :   if (sh == NULL)</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineCov">       2940 :   newsect = &amp;sh-&gt;section;</span>
<span class="lineNum">    1175 </span><span class="lineCov">       2940 :   if (newsect-&gt;name != NULL)</span>
<span class="lineNum">    1176 </span>            :     {
<span class="lineNum">    1177 </span>            :       /* We are making a section of the same name.  Put it in the
<span class="lineNum">    1178 </span>            :          section hash table.  Even though we can't find it directly by a
<span class="lineNum">    1179 </span>            :          hash lookup, we'll be able to find the section by traversing
<span class="lineNum">    1180 </span>            :          sh-&gt;root.next quicker than looking at all the bfd sections.  */
<span class="lineNum">    1181 </span>            :       struct section_hash_entry *new_sh;
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :       new_sh = (struct section_hash_entry *)</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :         bfd_section_hash_newfunc (NULL, &amp;abfd-&gt;section_htab, name);</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :       if (new_sh == NULL)</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :       new_sh-&gt;root = sh-&gt;root;</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :       sh-&gt;root.next = &amp;new_sh-&gt;root;</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :       newsect = &amp;new_sh-&gt;section;</span>
<span class="lineNum">    1190 </span>            :     }
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineCov">       2940 :   newsect-&gt;flags = flags;</span>
<span class="lineNum">    1193 </span><span class="lineCov">       2940 :   newsect-&gt;name = name;</span>
<span class="lineNum">    1194 </span><span class="lineCov">       2940 :   return bfd_section_init (abfd, newsect);</span>
<span class="lineNum">    1195 </span>            : }
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            : /*
<span class="lineNum">    1198 </span>            : FUNCTION
<span class="lineNum">    1199 </span>            :         bfd_make_section_anyway
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span>            : SYNOPSIS
<span class="lineNum">    1202 </span>            :         asection *bfd_make_section_anyway (bfd *abfd, const char *name);
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            : DESCRIPTION
<span class="lineNum">    1205 </span>            :    Create a new empty section called @var{name} and attach it to the end of
<span class="lineNum">    1206 </span>            :    the chain of sections for @var{abfd}.  Create a new section even if there
<span class="lineNum">    1207 </span>            :    is already a section with that name.
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            :    Return &lt;&lt;NULL&gt;&gt; and set &lt;&lt;bfd_error&gt;&gt; on error; possible errors are:
<span class="lineNum">    1210 </span>            :    o &lt;&lt;bfd_error_invalid_operation&gt;&gt; - If output has already started for @var{abfd}.
<span class="lineNum">    1211 </span>            :    o &lt;&lt;bfd_error_no_memory&gt;&gt; - If memory allocation fails.
<span class="lineNum">    1212 </span>            : */
<a name="1213"><span class="lineNum">    1213 </span>            : </a>
<span class="lineNum">    1214 </span>            : sec_ptr
<span class="lineNum">    1215 </span><span class="lineCov">       2940 : bfd_make_section_anyway (bfd *abfd, const char *name)</span>
<span class="lineNum">    1216 </span>            : {
<span class="lineNum">    1217 </span><span class="lineCov">       2940 :   return bfd_make_section_anyway_with_flags (abfd, name, 0);</span>
<span class="lineNum">    1218 </span>            : }
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            : /*
<span class="lineNum">    1221 </span>            : FUNCTION
<span class="lineNum">    1222 </span>            :         bfd_make_section_with_flags
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : SYNOPSIS
<span class="lineNum">    1225 </span>            :         asection *bfd_make_section_with_flags
<span class="lineNum">    1226 </span>            :           (bfd *, const char *name, flagword flags);
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            : DESCRIPTION
<span class="lineNum">    1229 </span>            :    Like &lt;&lt;bfd_make_section_anyway&gt;&gt;, but return &lt;&lt;NULL&gt;&gt; (without calling
<span class="lineNum">    1230 </span>            :    bfd_set_error ()) without changing the section chain if there is already a
<span class="lineNum">    1231 </span>            :    section named @var{name}.  Also set the attributes of the new section to
<span class="lineNum">    1232 </span>            :    the value @var{flags}.  If there is an error, return &lt;&lt;NULL&gt;&gt; and set
<span class="lineNum">    1233 </span>            :    &lt;&lt;bfd_error&gt;&gt;.
<span class="lineNum">    1234 </span>            : */
<a name="1235"><span class="lineNum">    1235 </span>            : </a>
<span class="lineNum">    1236 </span>            : asection *
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 : bfd_make_section_with_flags (bfd *abfd, const char *name,</span>
<span class="lineNum">    1238 </span>            :                              flagword flags)
<span class="lineNum">    1239 </span>            : {
<span class="lineNum">    1240 </span>            :   struct section_hash_entry *sh;
<span class="lineNum">    1241 </span>            :   asection *newsect;
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :   if (abfd-&gt;output_has_begun)</span>
<span class="lineNum">    1244 </span>            :     {
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1247 </span>            :     }
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :   if (strcmp (name, BFD_ABS_SECTION_NAME) == 0</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :       || strcmp (name, BFD_COM_SECTION_NAME) == 0</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :       || strcmp (name, BFD_UND_SECTION_NAME) == 0</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :       || strcmp (name, BFD_IND_SECTION_NAME) == 0)</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :   sh = section_hash_lookup (&amp;abfd-&gt;section_htab, name, TRUE, FALSE);</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :   if (sh == NULL)</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   newsect = &amp;sh-&gt;section;</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :   if (newsect-&gt;name != NULL)</span>
<span class="lineNum">    1261 </span>            :     {
<span class="lineNum">    1262 </span>            :       /* Section already exists.  */
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1264 </span>            :     }
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   newsect-&gt;name = name;</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :   newsect-&gt;flags = flags;</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   return bfd_section_init (abfd, newsect);</span>
<span class="lineNum">    1269 </span>            : }
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span>            : /*
<span class="lineNum">    1272 </span>            : FUNCTION
<span class="lineNum">    1273 </span>            :         bfd_make_section
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            : SYNOPSIS
<span class="lineNum">    1276 </span>            :         asection *bfd_make_section (bfd *, const char *name);
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            : DESCRIPTION
<span class="lineNum">    1279 </span>            :    Like &lt;&lt;bfd_make_section_anyway&gt;&gt;, but return &lt;&lt;NULL&gt;&gt; (without calling
<span class="lineNum">    1280 </span>            :    bfd_set_error ()) without changing the section chain if there is already a
<span class="lineNum">    1281 </span>            :    section named @var{name}.  If there is an error, return &lt;&lt;NULL&gt;&gt; and set
<span class="lineNum">    1282 </span>            :    &lt;&lt;bfd_error&gt;&gt;.
<span class="lineNum">    1283 </span>            : */
<a name="1284"><span class="lineNum">    1284 </span>            : </a>
<span class="lineNum">    1285 </span>            : asection *
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 : bfd_make_section (bfd *abfd, const char *name)</span>
<span class="lineNum">    1287 </span>            : {
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   return bfd_make_section_with_flags (abfd, name, 0);</span>
<span class="lineNum">    1289 </span>            : }
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            : /*
<span class="lineNum">    1292 </span>            : FUNCTION
<span class="lineNum">    1293 </span>            :         bfd_get_next_section_id
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            : SYNOPSIS
<span class="lineNum">    1296 </span>            :         int bfd_get_next_section_id (void);
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : DESCRIPTION
<span class="lineNum">    1299 </span>            :         Returns the id that the next section created will have.
<span class="lineNum">    1300 </span>            : */
<a name="1301"><span class="lineNum">    1301 </span>            : </a>
<span class="lineNum">    1302 </span>            : int
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 : bfd_get_next_section_id (void)</span>
<span class="lineNum">    1304 </span>            : {
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :   return section_id;</span>
<span class="lineNum">    1306 </span>            : }
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span>            : /*
<span class="lineNum">    1309 </span>            : FUNCTION
<span class="lineNum">    1310 </span>            :         bfd_set_section_flags
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span>            : SYNOPSIS
<span class="lineNum">    1313 </span>            :         bfd_boolean bfd_set_section_flags
<span class="lineNum">    1314 </span>            :           (bfd *abfd, asection *sec, flagword flags);
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span>            : DESCRIPTION
<span class="lineNum">    1317 </span>            :         Set the attributes of the section @var{sec} in the BFD
<span class="lineNum">    1318 </span>            :         @var{abfd} to the value @var{flags}. Return &lt;&lt;TRUE&gt;&gt; on success,
<span class="lineNum">    1319 </span>            :         &lt;&lt;FALSE&gt;&gt; on error. Possible error returns are:
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            :         o &lt;&lt;bfd_error_invalid_operation&gt;&gt; -
<span class="lineNum">    1322 </span>            :         The section cannot have one or more of the attributes
<span class="lineNum">    1323 </span>            :         requested. For example, a .bss section in &lt;&lt;a.out&gt;&gt; may not
<span class="lineNum">    1324 </span>            :         have the &lt;&lt;SEC_HAS_CONTENTS&gt;&gt; field set.
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            : */
<a name="1327"><span class="lineNum">    1327 </span>            : </a>
<span class="lineNum">    1328 </span>            : bfd_boolean
<span class="lineNum">    1329 </span><span class="lineCov">       2940 : bfd_set_section_flags (bfd *abfd ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    1330 </span>            :                        sec_ptr section,
<span class="lineNum">    1331 </span>            :                        flagword flags)
<span class="lineNum">    1332 </span>            : {
<span class="lineNum">    1333 </span><span class="lineCov">       2940 :   section-&gt;flags = flags;</span>
<span class="lineNum">    1334 </span><span class="lineCov">       2940 :   return TRUE;</span>
<span class="lineNum">    1335 </span>            : }
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            : /*
<span class="lineNum">    1338 </span>            : FUNCTION
<span class="lineNum">    1339 </span>            :         bfd_rename_section
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : SYNOPSIS
<span class="lineNum">    1342 </span>            :         void bfd_rename_section
<span class="lineNum">    1343 </span>            :           (bfd *abfd, asection *sec, const char *newname);
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            : DESCRIPTION
<span class="lineNum">    1346 </span>            :         Rename section @var{sec} in @var{abfd} to @var{newname}.
<span class="lineNum">    1347 </span>            : */
<a name="1348"><span class="lineNum">    1348 </span>            : </a>
<span class="lineNum">    1349 </span>            : void
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 : bfd_rename_section (bfd *abfd, sec_ptr sec, const char *newname)</span>
<span class="lineNum">    1351 </span>            : {
<span class="lineNum">    1352 </span>            :   struct section_hash_entry *sh;
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :   sh = (struct section_hash_entry *)</span>
<span class="lineNum">    1355 </span>            :     ((char *) sec - offsetof (struct section_hash_entry, section));
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :   sh-&gt;section.name = newname;</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :   bfd_hash_rename (&amp;abfd-&gt;section_htab, newname, &amp;sh-&gt;root);</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span>            : /*
<span class="lineNum">    1361 </span>            : FUNCTION
<span class="lineNum">    1362 </span>            :         bfd_map_over_sections
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            : SYNOPSIS
<span class="lineNum">    1365 </span>            :         void bfd_map_over_sections
<span class="lineNum">    1366 </span>            :           (bfd *abfd,
<span class="lineNum">    1367 </span>            :            void (*func) (bfd *abfd, asection *sect, void *obj),
<span class="lineNum">    1368 </span>            :            void *obj);
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            : DESCRIPTION
<span class="lineNum">    1371 </span>            :         Call the provided function @var{func} for each section
<span class="lineNum">    1372 </span>            :         attached to the BFD @var{abfd}, passing @var{obj} as an
<span class="lineNum">    1373 </span>            :         argument. The function will be called as if by
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span>            : |       func (abfd, the_section, obj);
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            :         This is the preferred method for iterating over sections; an
<span class="lineNum">    1378 </span>            :         alternative would be to use a loop:
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : |          asection *p;
<span class="lineNum">    1381 </span>            : |          for (p = abfd-&gt;sections; p != NULL; p = p-&gt;next)
<span class="lineNum">    1382 </span>            : |             func (abfd, p, ...)
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            : */
<a name="1385"><span class="lineNum">    1385 </span>            : </a>
<span class="lineNum">    1386 </span>            : void
<span class="lineNum">    1387 </span><span class="lineCov">        494 : bfd_map_over_sections (bfd *abfd,</span>
<span class="lineNum">    1388 </span>            :                        void (*operation) (bfd *, asection *, void *),
<span class="lineNum">    1389 </span>            :                        void *user_storage)
<span class="lineNum">    1390 </span>            : {
<span class="lineNum">    1391 </span>            :   asection *sect;
<span class="lineNum">    1392 </span><span class="lineCov">        494 :   unsigned int i = 0;</span>
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span><span class="lineCov">       2624 :   for (sect = abfd-&gt;sections; sect != NULL; i++, sect = sect-&gt;next)</span>
<span class="lineNum">    1395 </span><span class="lineCov">       2377 :     (*operation) (abfd, sect, user_storage);</span>
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineCov">        247 :   if (i != abfd-&gt;section_count)      /* Debugging */</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     abort ();</span>
<span class="lineNum">    1399 </span><span class="lineCov">        247 : }</span>
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span>            : /*
<span class="lineNum">    1402 </span>            : FUNCTION
<span class="lineNum">    1403 </span>            :         bfd_sections_find_if
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span>            : SYNOPSIS
<span class="lineNum">    1406 </span>            :         asection *bfd_sections_find_if
<span class="lineNum">    1407 </span>            :           (bfd *abfd,
<span class="lineNum">    1408 </span>            :            bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
<span class="lineNum">    1409 </span>            :            void *obj);
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            : DESCRIPTION
<span class="lineNum">    1412 </span>            :         Call the provided function @var{operation} for each section
<span class="lineNum">    1413 </span>            :         attached to the BFD @var{abfd}, passing @var{obj} as an
<span class="lineNum">    1414 </span>            :         argument. The function will be called as if by
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span>            : |       operation (abfd, the_section, obj);
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            :         It returns the first section for which @var{operation} returns true.
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            : */
<a name="1421"><span class="lineNum">    1421 </span>            : </a>
<span class="lineNum">    1422 </span>            : asection *
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 : bfd_sections_find_if (bfd *abfd,</span>
<span class="lineNum">    1424 </span>            :                       bfd_boolean (*operation) (bfd *, asection *, void *),
<span class="lineNum">    1425 </span>            :                       void *user_storage)
<span class="lineNum">    1426 </span>            : {
<span class="lineNum">    1427 </span>            :   asection *sect;
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :   for (sect = abfd-&gt;sections; sect != NULL; sect = sect-&gt;next)</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     if ((*operation) (abfd, sect, user_storage))</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   return sect;</span>
<span class="lineNum">    1434 </span>            : }
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            : /*
<span class="lineNum">    1437 </span>            : FUNCTION
<span class="lineNum">    1438 </span>            :         bfd_set_section_size
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span>            : SYNOPSIS
<span class="lineNum">    1441 </span>            :         bfd_boolean bfd_set_section_size
<span class="lineNum">    1442 </span>            :           (bfd *abfd, asection *sec, bfd_size_type val);
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span>            : DESCRIPTION
<span class="lineNum">    1445 </span>            :         Set @var{sec} to the size @var{val}. If the operation is
<span class="lineNum">    1446 </span>            :         ok, then &lt;&lt;TRUE&gt;&gt; is returned, else &lt;&lt;FALSE&gt;&gt;.
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            :         Possible error returns:
<span class="lineNum">    1449 </span>            :         o &lt;&lt;bfd_error_invalid_operation&gt;&gt; -
<span class="lineNum">    1450 </span>            :         Writing has started to the BFD, so setting the size is invalid.
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            : */
<a name="1453"><span class="lineNum">    1453 </span>            : </a>
<span class="lineNum">    1454 </span>            : bfd_boolean
<span class="lineNum">    1455 </span><span class="lineCov">       2940 : bfd_set_section_size (bfd *abfd, sec_ptr ptr, bfd_size_type val)</span>
<span class="lineNum">    1456 </span>            : {
<span class="lineNum">    1457 </span>            :   /* Once you've started writing to any section you cannot create or change
<span class="lineNum">    1458 </span>            :      the size of any others.  */
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineCov">       2940 :   if (abfd-&gt;output_has_begun)</span>
<span class="lineNum">    1461 </span>            :     {
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1464 </span>            :     }
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span><span class="lineCov">       2940 :   ptr-&gt;size = val;</span>
<span class="lineNum">    1467 </span><span class="lineCov">       2940 :   return TRUE;</span>
<span class="lineNum">    1468 </span>            : }
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            : /*
<span class="lineNum">    1471 </span>            : FUNCTION
<span class="lineNum">    1472 </span>            :         bfd_set_section_contents
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            : SYNOPSIS
<span class="lineNum">    1475 </span>            :         bfd_boolean bfd_set_section_contents
<span class="lineNum">    1476 </span>            :           (bfd *abfd, asection *section, const void *data,
<span class="lineNum">    1477 </span>            :            file_ptr offset, bfd_size_type count);
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span>            : DESCRIPTION
<span class="lineNum">    1480 </span>            :         Sets the contents of the section @var{section} in BFD
<span class="lineNum">    1481 </span>            :         @var{abfd} to the data starting in memory at @var{data}. The
<span class="lineNum">    1482 </span>            :         data is written to the output section starting at offset
<span class="lineNum">    1483 </span>            :         @var{offset} for @var{count} octets.
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            :         Normally &lt;&lt;TRUE&gt;&gt; is returned, else &lt;&lt;FALSE&gt;&gt;. Possible error
<span class="lineNum">    1486 </span>            :         returns are:
<span class="lineNum">    1487 </span>            :         o &lt;&lt;bfd_error_no_contents&gt;&gt; -
<span class="lineNum">    1488 </span>            :         The output section does not have the &lt;&lt;SEC_HAS_CONTENTS&gt;&gt;
<span class="lineNum">    1489 </span>            :         attribute, so nothing can be written to it.
<span class="lineNum">    1490 </span>            :         o and some more too
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            :         This routine is front end to the back end function
<span class="lineNum">    1493 </span>            :         &lt;&lt;_bfd_set_section_contents&gt;&gt;.
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span>            : */
<a name="1496"><span class="lineNum">    1496 </span>            : </a>
<span class="lineNum">    1497 </span>            : bfd_boolean
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 : bfd_set_section_contents (bfd *abfd,</span>
<span class="lineNum">    1499 </span>            :                           sec_ptr section,
<span class="lineNum">    1500 </span>            :                           const void *location,
<span class="lineNum">    1501 </span>            :                           file_ptr offset,
<span class="lineNum">    1502 </span>            :                           bfd_size_type count)
<span class="lineNum">    1503 </span>            : {
<span class="lineNum">    1504 </span>            :   bfd_size_type sz;
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   if (!(bfd_get_section_flags (abfd, section) &amp; SEC_HAS_CONTENTS))</span>
<span class="lineNum">    1507 </span>            :     {
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_no_contents);</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1510 </span>            :     }
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   sz = section-&gt;size;</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   if ((bfd_size_type) offset &gt; sz</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :       || count &gt; sz</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :       || offset + count &gt; sz</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :       || count != (size_t) count)</span>
<span class="lineNum">    1517 </span>            :     {
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_bad_value);</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1520 </span>            :     }
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :   if (!bfd_write_p (abfd))</span>
<span class="lineNum">    1523 </span>            :     {
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1526 </span>            :     }
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            :   /* Record a copy of the data in memory if desired.  */
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :   if (section-&gt;contents</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :       &amp;&amp; location != section-&gt;contents + offset)</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     memcpy (section-&gt;contents + offset, location, (size_t) count);</span>
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :   if (BFD_SEND (abfd, _bfd_set_section_contents,</span>
<span class="lineNum">    1534 </span>            :                 (abfd, section, location, offset, count)))
<span class="lineNum">    1535 </span>            :     {
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :       abfd-&gt;output_has_begun = TRUE;</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :       return TRUE;</span>
<span class="lineNum">    1538 </span>            :     }
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   return FALSE;</span>
<span class="lineNum">    1541 </span>            : }
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            : /*
<span class="lineNum">    1544 </span>            : FUNCTION
<span class="lineNum">    1545 </span>            :         bfd_get_section_contents
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            : SYNOPSIS
<span class="lineNum">    1548 </span>            :         bfd_boolean bfd_get_section_contents
<span class="lineNum">    1549 </span>            :           (bfd *abfd, asection *section, void *location, file_ptr offset,
<span class="lineNum">    1550 </span>            :            bfd_size_type count);
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            : DESCRIPTION
<span class="lineNum">    1553 </span>            :         Read data from @var{section} in BFD @var{abfd}
<span class="lineNum">    1554 </span>            :         into memory starting at @var{location}. The data is read at an
<span class="lineNum">    1555 </span>            :         offset of @var{offset} from the start of the input section,
<span class="lineNum">    1556 </span>            :         and is read for @var{count} bytes.
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :         If the contents of a constructor with the &lt;&lt;SEC_CONSTRUCTOR&gt;&gt;
<span class="lineNum">    1559 </span>            :         flag set are requested or if the section does not have the
<span class="lineNum">    1560 </span>            :         &lt;&lt;SEC_HAS_CONTENTS&gt;&gt; flag set, then the @var{location} is filled
<span class="lineNum">    1561 </span>            :         with zeroes. If no errors occur, &lt;&lt;TRUE&gt;&gt; is returned, else
<span class="lineNum">    1562 </span>            :         &lt;&lt;FALSE&gt;&gt;.
<span class="lineNum">    1563 </span>            : 
<a name="1564"><span class="lineNum">    1564 </span>            : */</a>
<span class="lineNum">    1565 </span>            : bfd_boolean
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 : bfd_get_section_contents (bfd *abfd,</span>
<span class="lineNum">    1567 </span>            :                           sec_ptr section,
<span class="lineNum">    1568 </span>            :                           void *location,
<span class="lineNum">    1569 </span>            :                           file_ptr offset,
<span class="lineNum">    1570 </span>            :                           bfd_size_type count)
<span class="lineNum">    1571 </span>            : {
<span class="lineNum">    1572 </span>            :   bfd_size_type sz;
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :   if (section-&gt;flags &amp; SEC_CONSTRUCTOR)</span>
<span class="lineNum">    1575 </span>            :     {
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :       memset (location, 0, (size_t) count);</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :       return TRUE;</span>
<span class="lineNum">    1578 </span>            :     }
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :   if (abfd-&gt;direction != write_direction &amp;&amp; section-&gt;rawsize != 0)</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :     sz = section-&gt;rawsize;</span>
<span class="lineNum">    1582 </span>            :   else
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     sz = section-&gt;size;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :   if ((bfd_size_type) offset &gt; sz</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :       || count &gt; sz</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :       || offset + count &gt; sz</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :       || count != (size_t) count)</span>
<span class="lineNum">    1588 </span>            :     {
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :       bfd_set_error (bfd_error_bad_value);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :       return FALSE;</span>
<span class="lineNum">    1591 </span>            :     }
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :   if (count == 0)</span>
<span class="lineNum">    1594 </span>            :     /* Don't bother.  */
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :   if ((section-&gt;flags &amp; SEC_HAS_CONTENTS) == 0)</span>
<span class="lineNum">    1598 </span>            :     {
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :       memset (location, 0, (size_t) count);</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :       return TRUE;</span>
<span class="lineNum">    1601 </span>            :     }
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   if ((section-&gt;flags &amp; SEC_IN_MEMORY) != 0)</span>
<span class="lineNum">    1604 </span>            :     {
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :       if (section-&gt;contents == NULL)</span>
<span class="lineNum">    1606 </span>            :         {
<span class="lineNum">    1607 </span>            :           /* This can happen because of errors earlier on in the linking process.
<span class="lineNum">    1608 </span>            :              We do not want to seg-fault here, so clear the flag and return an
<span class="lineNum">    1609 </span>            :              error code.  */
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :           section-&gt;flags &amp;= ~ SEC_IN_MEMORY;</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :           bfd_set_error (bfd_error_invalid_operation);</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :           return FALSE;</span>
<span class="lineNum">    1613 </span>            :         }
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :       memmove (location, section-&gt;contents + offset, (size_t) count);</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :       return TRUE;</span>
<span class="lineNum">    1617 </span>            :     }
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :   return BFD_SEND (abfd, _bfd_get_section_contents,</span>
<span class="lineNum">    1620 </span>            :                    (abfd, section, location, offset, count));
<span class="lineNum">    1621 </span>            : }
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span>            : /*
<span class="lineNum">    1624 </span>            : FUNCTION
<span class="lineNum">    1625 </span>            :         bfd_malloc_and_get_section
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span>            : SYNOPSIS
<span class="lineNum">    1628 </span>            :         bfd_boolean bfd_malloc_and_get_section
<span class="lineNum">    1629 </span>            :           (bfd *abfd, asection *section, bfd_byte **buf);
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            : DESCRIPTION
<span class="lineNum">    1632 </span>            :         Read all data from @var{section} in BFD @var{abfd}
<span class="lineNum">    1633 </span>            :         into a buffer, *@var{buf}, malloc'd by this function.
<span class="lineNum">    1634 </span>            : */
<a name="1635"><span class="lineNum">    1635 </span>            : </a>
<span class="lineNum">    1636 </span>            : bfd_boolean
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 : bfd_malloc_and_get_section (bfd *abfd, sec_ptr sec, bfd_byte **buf)</span>
<span class="lineNum">    1638 </span>            : {
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :   *buf = NULL;</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :   return bfd_get_full_section_contents (abfd, sec, buf);</span>
<span class="lineNum">    1641 </span>            : }
<span class="lineNum">    1642 </span>            : /*
<span class="lineNum">    1643 </span>            : FUNCTION
<span class="lineNum">    1644 </span>            :         bfd_copy_private_section_data
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span>            : SYNOPSIS
<span class="lineNum">    1647 </span>            :         bfd_boolean bfd_copy_private_section_data
<span class="lineNum">    1648 </span>            :           (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span>            : DESCRIPTION
<span class="lineNum">    1651 </span>            :         Copy private section information from @var{isec} in the BFD
<span class="lineNum">    1652 </span>            :         @var{ibfd} to the section @var{osec} in the BFD @var{obfd}.
<span class="lineNum">    1653 </span>            :         Return &lt;&lt;TRUE&gt;&gt; on success, &lt;&lt;FALSE&gt;&gt; on error.  Possible error
<span class="lineNum">    1654 </span>            :         returns are:
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span>            :         o &lt;&lt;bfd_error_no_memory&gt;&gt; -
<span class="lineNum">    1657 </span>            :         Not enough memory exists to create private data for @var{osec}.
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            : .#define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
<span class="lineNum">    1660 </span>            : .     BFD_SEND (obfd, _bfd_copy_private_section_data, \
<span class="lineNum">    1661 </span>            : .               (ibfd, isection, obfd, osection))
<span class="lineNum">    1662 </span>            : */
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span>            : /*
<span class="lineNum">    1665 </span>            : FUNCTION
<span class="lineNum">    1666 </span>            :         bfd_generic_is_group_section
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            : SYNOPSIS
<span class="lineNum">    1669 </span>            :         bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);
<span class="lineNum">    1670 </span>            : 
<span class="lineNum">    1671 </span>            : DESCRIPTION
<span class="lineNum">    1672 </span>            :         Returns TRUE if @var{sec} is a member of a group.
<span class="lineNum">    1673 </span>            : */
<a name="1674"><span class="lineNum">    1674 </span>            : </a>
<span class="lineNum">    1675 </span>            : bfd_boolean
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 : bfd_generic_is_group_section (bfd *abfd ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    1677 </span>            :                               const asection *sec ATTRIBUTE_UNUSED)
<span class="lineNum">    1678 </span>            : {
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :   return FALSE;</span>
<span class="lineNum">    1680 </span>            : }
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            : /*
<span class="lineNum">    1683 </span>            : FUNCTION
<span class="lineNum">    1684 </span>            :         bfd_generic_discard_group
<span class="lineNum">    1685 </span>            : 
<span class="lineNum">    1686 </span>            : SYNOPSIS
<span class="lineNum">    1687 </span>            :         bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span>            : DESCRIPTION
<span class="lineNum">    1690 </span>            :         Remove all members of @var{group} from the output.
<span class="lineNum">    1691 </span>            : */
<a name="1692"><span class="lineNum">    1692 </span>            : </a>
<span class="lineNum">    1693 </span>            : bfd_boolean
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 : bfd_generic_discard_group (bfd *abfd ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    1695 </span>            :                            asection *group ATTRIBUTE_UNUSED)
<span class="lineNum">    1696 </span>            : {
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :   return TRUE;</span>
<span class="lineNum">    1698 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
